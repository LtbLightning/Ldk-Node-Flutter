// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.31.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/error.dart';
import 'api/node.dart';
import 'api/types.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.io.dart' if (dart.library.html) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class LdkCore extends BaseEntrypoint<LdkCoreApi, LdkCoreApiImpl, LdkCoreWire> {
  @internal
  static final instance = LdkCore._();

  LdkCore._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    LdkCoreApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<LdkCoreApiImpl, LdkCoreWire> get apiImplConstructor =>
      LdkCoreApiImpl.new;

  @override
  WireConstructor<LdkCoreWire> get wireConstructor =>
      LdkCoreWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.0.0-dev.31';

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'ldk_node',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class LdkCoreApi extends BaseApi {
  Future<LdkNode> nodeBuilderBuild({required NodeBuilder that, dynamic hint});

  Future<LdkNode> nodeBuilderBuildWithFsStore(
      {required NodeBuilder that, dynamic hint});

  Future<NodeBuilder> nodeBuilderCreateBuilder(
      {required Config config,
      ChainDataSourceConfig? chainDataSourceConfig,
      EntropySourceConfig? entropySourceConfig,
      GossipSourceConfig? gossipSourceConfig,
      LiquiditySourceConfig? liquiditySourceConfig,
      dynamic hint});

  Future<Bolt11Invoice> ldkBolt11PaymentReceive(
      {required LdkBolt11Payment that,
      required int amountMsat,
      required String description,
      required int expirySecs,
      dynamic hint});

  Future<Bolt11Invoice> ldkBolt11PaymentReceiveVariableAmount(
      {required LdkBolt11Payment that,
      required String description,
      required int expirySecs,
      dynamic hint});

  Future<Bolt11Invoice> ldkBolt11PaymentReceiveVariableAmountViaJitChannel(
      {required LdkBolt11Payment that,
      required String description,
      required int expirySecs,
      int? maxProportionalLspFeeLimitPpmMsat,
      dynamic hint});

  Future<Bolt11Invoice> ldkBolt11PaymentReceiveViaJitChannel(
      {required LdkBolt11Payment that,
      required int amountMsat,
      required String description,
      required int expirySecs,
      int? maxTotalLspFeeLimitMsat,
      dynamic hint});

  Future<PaymentId> ldkBolt11PaymentSend(
      {required LdkBolt11Payment that,
      required Bolt11Invoice invoice,
      dynamic hint});

  Future<void> ldkBolt11PaymentSendProbes(
      {required LdkBolt11Payment that,
      required Bolt11Invoice invoice,
      dynamic hint});

  Future<void> ldkBolt11PaymentSendProbesUsingAmount(
      {required LdkBolt11Payment that,
      required Bolt11Invoice invoice,
      required int amountMsat,
      dynamic hint});

  Future<PaymentId> ldkBolt11PaymentSendUsingAmount(
      {required LdkBolt11Payment that,
      required Bolt11Invoice invoice,
      required int amountMsat,
      dynamic hint});

  Future<LdkMnemonic> ldkMnemonicGenerate({dynamic hint});

  Future<LdkBolt11Payment> ldkNodeBolt11Payment(
      {required LdkNode ptr, dynamic hint});

  Future<void> ldkNodeCloseChannel(
      {required LdkNode that,
      required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId,
      dynamic hint});

  Future<Config> ldkNodeConfig({required LdkNode that, dynamic hint});

  Future<void> ldkNodeConnect(
      {required LdkNode that,
      required PublicKey nodeId,
      required SocketAddress address,
      required bool persist,
      dynamic hint});

  Future<UserChannelId> ldkNodeConnectOpenChannel(
      {required LdkNode that,
      required SocketAddress socketAddress,
      required PublicKey nodeId,
      required int channelAmountSats,
      int? pushToCounterpartyMsat,
      required bool announceChannel,
      ChannelConfig? channelConfig,
      dynamic hint});

  Future<void> ldkNodeDisconnect(
      {required LdkNode that,
      required PublicKey counterpartyNodeId,
      dynamic hint});

  Future<void> ldkNodeEventHandled({required LdkNode that, dynamic hint});

  Future<BalanceDetails> ldkNodeListBalances(
      {required LdkNode that, dynamic hint});

  Future<List<ChannelDetails>> ldkNodeListChannels(
      {required LdkNode that, dynamic hint});

  Future<List<PaymentDetails>> ldkNodeListPayments(
      {required LdkNode that, dynamic hint});

  Future<List<PaymentDetails>> ldkNodeListPaymentsWithFilter(
      {required LdkNode that,
      required PaymentDirection paymentDirection,
      dynamic hint});

  Future<List<PeerDetails>> ldkNodeListPeers(
      {required LdkNode that, dynamic hint});

  Future<List<SocketAddress>?> ldkNodeListeningAddresses(
      {required LdkNode that, dynamic hint});

  Future<Event?> ldkNodeNextEvent({required LdkNode that, dynamic hint});

  Future<Event> ldkNodeNextEventAsync({required LdkNode that, dynamic hint});

  Future<PublicKey> ldkNodeNodeId({required LdkNode that, dynamic hint});

  Future<LdkOnChainPayment> ldkNodeOnChainPayment(
      {required LdkNode ptr, dynamic hint});

  Future<PaymentDetails?> ldkNodePayment(
      {required LdkNode that, required PaymentId paymentId, dynamic hint});

  Future<void> ldkNodeRemovePayment(
      {required LdkNode that, required PaymentId paymentId, dynamic hint});

  Future<String> ldkNodeSignMessage(
      {required LdkNode that, required List<int> msg, dynamic hint});

  Future<LdkSpontaneousPayment> ldkNodeSpontaneousPayment(
      {required LdkNode ptr, dynamic hint});

  Future<void> ldkNodeStart({required LdkNode that, dynamic hint});

  Future<NodeStatus> ldkNodeStatus({required LdkNode that, dynamic hint});

  Future<void> ldkNodeStop({required LdkNode that, dynamic hint});

  Future<void> ldkNodeSyncWallets({required LdkNode that, dynamic hint});

  Future<void> ldkNodeUpdateChannelConfig(
      {required LdkNode that,
      required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId,
      required ChannelConfig channelConfig,
      dynamic hint});

  Future<bool> ldkNodeVerifySignature(
      {required LdkNode that,
      required List<int> msg,
      required String sig,
      required PublicKey publicKey,
      dynamic hint});

  Future<Event> ldkNodeWaitNextEvent({required LdkNode that, dynamic hint});

  Future<Address> ldkOnChainPaymentNewAddress(
      {required LdkOnChainPayment that, dynamic hint});

  Future<Txid> ldkOnChainPaymentSendAllToAddress(
      {required LdkOnChainPayment that,
      required Address address,
      dynamic hint});

  Future<Txid> ldkOnChainPaymentSendToAddress(
      {required LdkOnChainPayment that,
      required Address address,
      required int amountSats,
      dynamic hint});

  Future<PaymentId> ldkSpontaneousPaymentSend(
      {required LdkSpontaneousPayment that,
      required int amountMsat,
      required PublicKey nodeId,
      dynamic hint});

  Future<void> ldkSpontaneousPaymentSendProbes(
      {required LdkSpontaneousPayment that,
      required int amountMsat,
      required PublicKey nodeId,
      dynamic hint});

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Node;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Node;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_NodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_NodeBuilder;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_NodeBuilder;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_NodeBuilderPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_LdkNodePaymentBolt11Payment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_LdkNodePaymentBolt11Payment;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_LdkNodePaymentBolt11PaymentPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_LdkNodePaymentOnchainPayment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_LdkNodePaymentOnchainPayment;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_LdkNodePaymentOnchainPaymentPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_LdkNodePaymentSpontaneousPayment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_LdkNodePaymentSpontaneousPayment;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_LdkNodePaymentSpontaneousPaymentPtr;
}

class LdkCoreApiImpl extends LdkCoreApiImplPlatform implements LdkCoreApi {
  LdkCoreApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<LdkNode> nodeBuilderBuild({required NodeBuilder that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockNodeBuilder(
                that);
        return wire.wire_NodeBuilder_build(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ldk_node,
        decodeErrorData: dco_decode_builder_exception,
      ),
      constMeta: kNodeBuilderBuildConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBuilderBuildConstMeta => const TaskConstMeta(
        debugName: "NodeBuilder_build",
        argNames: ["that"],
      );

  @override
  Future<LdkNode> nodeBuilderBuildWithFsStore(
      {required NodeBuilder that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockNodeBuilder(
                that);
        return wire.wire_NodeBuilder_build_with_fs_store(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ldk_node,
        decodeErrorData: dco_decode_builder_exception,
      ),
      constMeta: kNodeBuilderBuildWithFsStoreConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBuilderBuildWithFsStoreConstMeta =>
      const TaskConstMeta(
        debugName: "NodeBuilder_build_with_fs_store",
        argNames: ["that"],
      );

  @override
  Future<NodeBuilder> nodeBuilderCreateBuilder(
      {required Config config,
      ChainDataSourceConfig? chainDataSourceConfig,
      EntropySourceConfig? entropySourceConfig,
      GossipSourceConfig? gossipSourceConfig,
      LiquiditySourceConfig? liquiditySourceConfig,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_config(config);
        var arg1 = cst_encode_opt_box_autoadd_chain_data_source_config(
            chainDataSourceConfig);
        var arg2 = cst_encode_opt_box_autoadd_entropy_source_config(
            entropySourceConfig);
        var arg3 =
            cst_encode_opt_box_autoadd_gossip_source_config(gossipSourceConfig);
        var arg4 = cst_encode_opt_box_autoadd_liquidity_source_config(
            liquiditySourceConfig);
        return wire.wire_NodeBuilder_create_builder(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockNodeBuilder,
        decodeErrorData: dco_decode_builder_exception,
      ),
      constMeta: kNodeBuilderCreateBuilderConstMeta,
      argValues: [
        config,
        chainDataSourceConfig,
        entropySourceConfig,
        gossipSourceConfig,
        liquiditySourceConfig
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kNodeBuilderCreateBuilderConstMeta => const TaskConstMeta(
        debugName: "NodeBuilder_create_builder",
        argNames: [
          "config",
          "chainDataSourceConfig",
          "entropySourceConfig",
          "gossipSourceConfig",
          "liquiditySourceConfig"
        ],
      );

  @override
  Future<Bolt11Invoice> ldkBolt11PaymentReceive(
      {required LdkBolt11Payment that,
      required int amountMsat,
      required String description,
      required int expirySecs,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_String(description);
        var arg3 = cst_encode_u_32(expirySecs);
        return wire.wire_ldk_bolt_11_payment_receive(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkBolt11PaymentReceiveConstMeta,
      argValues: [that, amountMsat, description, expirySecs],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkBolt11PaymentReceiveConstMeta => const TaskConstMeta(
        debugName: "ldk_bolt_11_payment_receive",
        argNames: ["that", "amountMsat", "description", "expirySecs"],
      );

  @override
  Future<Bolt11Invoice> ldkBolt11PaymentReceiveVariableAmount(
      {required LdkBolt11Payment that,
      required String description,
      required int expirySecs,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_String(description);
        var arg2 = cst_encode_u_32(expirySecs);
        return wire.wire_ldk_bolt_11_payment_receive_variable_amount(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkBolt11PaymentReceiveVariableAmountConstMeta,
      argValues: [that, description, expirySecs],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkBolt11PaymentReceiveVariableAmountConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_bolt_11_payment_receive_variable_amount",
        argNames: ["that", "description", "expirySecs"],
      );

  @override
  Future<Bolt11Invoice> ldkBolt11PaymentReceiveVariableAmountViaJitChannel(
      {required LdkBolt11Payment that,
      required String description,
      required int expirySecs,
      int? maxProportionalLspFeeLimitPpmMsat,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_String(description);
        var arg2 = cst_encode_u_32(expirySecs);
        var arg3 =
            cst_encode_opt_box_autoadd_u_64(maxProportionalLspFeeLimitPpmMsat);
        return wire
            .wire_ldk_bolt_11_payment_receive_variable_amount_via_jit_channel(
                port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkBolt11PaymentReceiveVariableAmountViaJitChannelConstMeta,
      argValues: [
        that,
        description,
        expirySecs,
        maxProportionalLspFeeLimitPpmMsat
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta
      get kLdkBolt11PaymentReceiveVariableAmountViaJitChannelConstMeta =>
          const TaskConstMeta(
            debugName:
                "ldk_bolt_11_payment_receive_variable_amount_via_jit_channel",
            argNames: [
              "that",
              "description",
              "expirySecs",
              "maxProportionalLspFeeLimitPpmMsat"
            ],
          );

  @override
  Future<Bolt11Invoice> ldkBolt11PaymentReceiveViaJitChannel(
      {required LdkBolt11Payment that,
      required int amountMsat,
      required String description,
      required int expirySecs,
      int? maxTotalLspFeeLimitMsat,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_String(description);
        var arg3 = cst_encode_u_32(expirySecs);
        var arg4 = cst_encode_opt_box_autoadd_u_64(maxTotalLspFeeLimitMsat);
        return wire.wire_ldk_bolt_11_payment_receive_via_jit_channel(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkBolt11PaymentReceiveViaJitChannelConstMeta,
      argValues: [
        that,
        amountMsat,
        description,
        expirySecs,
        maxTotalLspFeeLimitMsat
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkBolt11PaymentReceiveViaJitChannelConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_bolt_11_payment_receive_via_jit_channel",
        argNames: [
          "that",
          "amountMsat",
          "description",
          "expirySecs",
          "maxTotalLspFeeLimitMsat"
        ],
      );

  @override
  Future<PaymentId> ldkBolt11PaymentSend(
      {required LdkBolt11Payment that,
      required Bolt11Invoice invoice,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_bolt_11_invoice(invoice);
        return wire.wire_ldk_bolt_11_payment_send(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payment_id,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkBolt11PaymentSendConstMeta,
      argValues: [that, invoice],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkBolt11PaymentSendConstMeta => const TaskConstMeta(
        debugName: "ldk_bolt_11_payment_send",
        argNames: ["that", "invoice"],
      );

  @override
  Future<void> ldkBolt11PaymentSendProbes(
      {required LdkBolt11Payment that,
      required Bolt11Invoice invoice,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_bolt_11_invoice(invoice);
        return wire.wire_ldk_bolt_11_payment_send_probes(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkBolt11PaymentSendProbesConstMeta,
      argValues: [that, invoice],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkBolt11PaymentSendProbesConstMeta => const TaskConstMeta(
        debugName: "ldk_bolt_11_payment_send_probes",
        argNames: ["that", "invoice"],
      );

  @override
  Future<void> ldkBolt11PaymentSendProbesUsingAmount(
      {required LdkBolt11Payment that,
      required Bolt11Invoice invoice,
      required int amountMsat,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_bolt_11_invoice(invoice);
        var arg2 = cst_encode_u_64(amountMsat);
        return wire.wire_ldk_bolt_11_payment_send_probes_using_amount(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkBolt11PaymentSendProbesUsingAmountConstMeta,
      argValues: [that, invoice, amountMsat],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkBolt11PaymentSendProbesUsingAmountConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_bolt_11_payment_send_probes_using_amount",
        argNames: ["that", "invoice", "amountMsat"],
      );

  @override
  Future<PaymentId> ldkBolt11PaymentSendUsingAmount(
      {required LdkBolt11Payment that,
      required Bolt11Invoice invoice,
      required int amountMsat,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_bolt_11_invoice(invoice);
        var arg2 = cst_encode_u_64(amountMsat);
        return wire.wire_ldk_bolt_11_payment_send_using_amount(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payment_id,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkBolt11PaymentSendUsingAmountConstMeta,
      argValues: [that, invoice, amountMsat],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkBolt11PaymentSendUsingAmountConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_bolt_11_payment_send_using_amount",
        argNames: ["that", "invoice", "amountMsat"],
      );

  @override
  Future<LdkMnemonic> ldkMnemonicGenerate({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire_ldk_mnemonic_generate(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ldk_mnemonic,
        decodeErrorData: null,
      ),
      constMeta: kLdkMnemonicGenerateConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkMnemonicGenerateConstMeta => const TaskConstMeta(
        debugName: "ldk_mnemonic_generate",
        argNames: [],
      );

  @override
  Future<LdkBolt11Payment> ldkNodeBolt11Payment(
      {required LdkNode ptr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(ptr);
        return wire.wire_ldk_node_bolt11_payment(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ldk_bolt_11_payment,
        decodeErrorData: null,
      ),
      constMeta: kLdkNodeBolt11PaymentConstMeta,
      argValues: [ptr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeBolt11PaymentConstMeta => const TaskConstMeta(
        debugName: "ldk_node_bolt11_payment",
        argNames: ["ptr"],
      );

  @override
  Future<void> ldkNodeCloseChannel(
      {required LdkNode that,
      required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_box_autoadd_user_channel_id(userChannelId);
        var arg2 = cst_encode_box_autoadd_public_key(counterpartyNodeId);
        return wire.wire_ldk_node_close_channel(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkNodeCloseChannelConstMeta,
      argValues: [that, userChannelId, counterpartyNodeId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeCloseChannelConstMeta => const TaskConstMeta(
        debugName: "ldk_node_close_channel",
        argNames: ["that", "userChannelId", "counterpartyNodeId"],
      );

  @override
  Future<Config> ldkNodeConfig({required LdkNode that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire_ldk_node_config(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_config,
        decodeErrorData: null,
      ),
      constMeta: kLdkNodeConfigConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeConfigConstMeta => const TaskConstMeta(
        debugName: "ldk_node_config",
        argNames: ["that"],
      );

  @override
  Future<void> ldkNodeConnect(
      {required LdkNode that,
      required PublicKey nodeId,
      required SocketAddress address,
      required bool persist,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_box_autoadd_public_key(nodeId);
        var arg2 = cst_encode_box_autoadd_socket_address(address);
        var arg3 = cst_encode_bool(persist);
        return wire.wire_ldk_node_connect(port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkNodeConnectConstMeta,
      argValues: [that, nodeId, address, persist],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeConnectConstMeta => const TaskConstMeta(
        debugName: "ldk_node_connect",
        argNames: ["that", "nodeId", "address", "persist"],
      );

  @override
  Future<UserChannelId> ldkNodeConnectOpenChannel(
      {required LdkNode that,
      required SocketAddress socketAddress,
      required PublicKey nodeId,
      required int channelAmountSats,
      int? pushToCounterpartyMsat,
      required bool announceChannel,
      ChannelConfig? channelConfig,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_box_autoadd_socket_address(socketAddress);
        var arg2 = cst_encode_box_autoadd_public_key(nodeId);
        var arg3 = cst_encode_u_64(channelAmountSats);
        var arg4 = cst_encode_opt_box_autoadd_u_64(pushToCounterpartyMsat);
        var arg5 = cst_encode_bool(announceChannel);
        var arg6 = cst_encode_opt_box_autoadd_channel_config(channelConfig);
        return wire.wire_ldk_node_connect_open_channel(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_user_channel_id,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkNodeConnectOpenChannelConstMeta,
      argValues: [
        that,
        socketAddress,
        nodeId,
        channelAmountSats,
        pushToCounterpartyMsat,
        announceChannel,
        channelConfig
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeConnectOpenChannelConstMeta => const TaskConstMeta(
        debugName: "ldk_node_connect_open_channel",
        argNames: [
          "that",
          "socketAddress",
          "nodeId",
          "channelAmountSats",
          "pushToCounterpartyMsat",
          "announceChannel",
          "channelConfig"
        ],
      );

  @override
  Future<void> ldkNodeDisconnect(
      {required LdkNode that,
      required PublicKey counterpartyNodeId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_box_autoadd_public_key(counterpartyNodeId);
        return wire.wire_ldk_node_disconnect(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkNodeDisconnectConstMeta,
      argValues: [that, counterpartyNodeId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeDisconnectConstMeta => const TaskConstMeta(
        debugName: "ldk_node_disconnect",
        argNames: ["that", "counterpartyNodeId"],
      );

  @override
  Future<void> ldkNodeEventHandled({required LdkNode that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire_ldk_node_event_handled(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kLdkNodeEventHandledConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeEventHandledConstMeta => const TaskConstMeta(
        debugName: "ldk_node_event_handled",
        argNames: ["that"],
      );

  @override
  Future<BalanceDetails> ldkNodeListBalances(
      {required LdkNode that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire_ldk_node_list_balances(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_balance_details,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkNodeListBalancesConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeListBalancesConstMeta => const TaskConstMeta(
        debugName: "ldk_node_list_balances",
        argNames: ["that"],
      );

  @override
  Future<List<ChannelDetails>> ldkNodeListChannels(
      {required LdkNode that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire_ldk_node_list_channels(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_channel_details,
        decodeErrorData: null,
      ),
      constMeta: kLdkNodeListChannelsConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeListChannelsConstMeta => const TaskConstMeta(
        debugName: "ldk_node_list_channels",
        argNames: ["that"],
      );

  @override
  Future<List<PaymentDetails>> ldkNodeListPayments(
      {required LdkNode that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire_ldk_node_list_payments(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_payment_details,
        decodeErrorData: null,
      ),
      constMeta: kLdkNodeListPaymentsConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeListPaymentsConstMeta => const TaskConstMeta(
        debugName: "ldk_node_list_payments",
        argNames: ["that"],
      );

  @override
  Future<List<PaymentDetails>> ldkNodeListPaymentsWithFilter(
      {required LdkNode that,
      required PaymentDirection paymentDirection,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_payment_direction(paymentDirection);
        return wire.wire_ldk_node_list_payments_with_filter(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_payment_details,
        decodeErrorData: null,
      ),
      constMeta: kLdkNodeListPaymentsWithFilterConstMeta,
      argValues: [that, paymentDirection],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeListPaymentsWithFilterConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_list_payments_with_filter",
        argNames: ["that", "paymentDirection"],
      );

  @override
  Future<List<PeerDetails>> ldkNodeListPeers(
      {required LdkNode that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire_ldk_node_list_peers(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_peer_details,
        decodeErrorData: null,
      ),
      constMeta: kLdkNodeListPeersConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeListPeersConstMeta => const TaskConstMeta(
        debugName: "ldk_node_list_peers",
        argNames: ["that"],
      );

  @override
  Future<List<SocketAddress>?> ldkNodeListeningAddresses(
      {required LdkNode that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire_ldk_node_listening_addresses(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_list_socket_address,
        decodeErrorData: null,
      ),
      constMeta: kLdkNodeListeningAddressesConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeListeningAddressesConstMeta => const TaskConstMeta(
        debugName: "ldk_node_listening_addresses",
        argNames: ["that"],
      );

  @override
  Future<Event?> ldkNodeNextEvent({required LdkNode that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire_ldk_node_next_event(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_event,
        decodeErrorData: null,
      ),
      constMeta: kLdkNodeNextEventConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeNextEventConstMeta => const TaskConstMeta(
        debugName: "ldk_node_next_event",
        argNames: ["that"],
      );

  @override
  Future<Event> ldkNodeNextEventAsync({required LdkNode that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire_ldk_node_next_event_async(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_event,
        decodeErrorData: null,
      ),
      constMeta: kLdkNodeNextEventAsyncConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeNextEventAsyncConstMeta => const TaskConstMeta(
        debugName: "ldk_node_next_event_async",
        argNames: ["that"],
      );

  @override
  Future<PublicKey> ldkNodeNodeId({required LdkNode that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire_ldk_node_node_id(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_public_key,
        decodeErrorData: null,
      ),
      constMeta: kLdkNodeNodeIdConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeNodeIdConstMeta => const TaskConstMeta(
        debugName: "ldk_node_node_id",
        argNames: ["that"],
      );

  @override
  Future<LdkOnChainPayment> ldkNodeOnChainPayment(
      {required LdkNode ptr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(ptr);
        return wire.wire_ldk_node_on_chain_payment(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ldk_on_chain_payment,
        decodeErrorData: null,
      ),
      constMeta: kLdkNodeOnChainPaymentConstMeta,
      argValues: [ptr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeOnChainPaymentConstMeta => const TaskConstMeta(
        debugName: "ldk_node_on_chain_payment",
        argNames: ["ptr"],
      );

  @override
  Future<PaymentDetails?> ldkNodePayment(
      {required LdkNode that, required PaymentId paymentId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_box_autoadd_payment_id(paymentId);
        return wire.wire_ldk_node_payment(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_payment_details,
        decodeErrorData: null,
      ),
      constMeta: kLdkNodePaymentConstMeta,
      argValues: [that, paymentId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodePaymentConstMeta => const TaskConstMeta(
        debugName: "ldk_node_payment",
        argNames: ["that", "paymentId"],
      );

  @override
  Future<void> ldkNodeRemovePayment(
      {required LdkNode that, required PaymentId paymentId, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_box_autoadd_payment_id(paymentId);
        return wire.wire_ldk_node_remove_payment(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkNodeRemovePaymentConstMeta,
      argValues: [that, paymentId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeRemovePaymentConstMeta => const TaskConstMeta(
        debugName: "ldk_node_remove_payment",
        argNames: ["that", "paymentId"],
      );

  @override
  Future<String> ldkNodeSignMessage(
      {required LdkNode that, required List<int> msg, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_list_prim_u_8_loose(msg);
        return wire.wire_ldk_node_sign_message(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkNodeSignMessageConstMeta,
      argValues: [that, msg],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeSignMessageConstMeta => const TaskConstMeta(
        debugName: "ldk_node_sign_message",
        argNames: ["that", "msg"],
      );

  @override
  Future<LdkSpontaneousPayment> ldkNodeSpontaneousPayment(
      {required LdkNode ptr, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(ptr);
        return wire.wire_ldk_node_spontaneous_payment(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ldk_spontaneous_payment,
        decodeErrorData: null,
      ),
      constMeta: kLdkNodeSpontaneousPaymentConstMeta,
      argValues: [ptr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeSpontaneousPaymentConstMeta => const TaskConstMeta(
        debugName: "ldk_node_spontaneous_payment",
        argNames: ["ptr"],
      );

  @override
  Future<void> ldkNodeStart({required LdkNode that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire_ldk_node_start(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkNodeStartConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeStartConstMeta => const TaskConstMeta(
        debugName: "ldk_node_start",
        argNames: ["that"],
      );

  @override
  Future<NodeStatus> ldkNodeStatus({required LdkNode that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire_ldk_node_status(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_node_status,
        decodeErrorData: null,
      ),
      constMeta: kLdkNodeStatusConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeStatusConstMeta => const TaskConstMeta(
        debugName: "ldk_node_status",
        argNames: ["that"],
      );

  @override
  Future<void> ldkNodeStop({required LdkNode that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire_ldk_node_stop(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkNodeStopConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeStopConstMeta => const TaskConstMeta(
        debugName: "ldk_node_stop",
        argNames: ["that"],
      );

  @override
  Future<void> ldkNodeSyncWallets({required LdkNode that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire_ldk_node_sync_wallets(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkNodeSyncWalletsConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeSyncWalletsConstMeta => const TaskConstMeta(
        debugName: "ldk_node_sync_wallets",
        argNames: ["that"],
      );

  @override
  Future<void> ldkNodeUpdateChannelConfig(
      {required LdkNode that,
      required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId,
      required ChannelConfig channelConfig,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_box_autoadd_user_channel_id(userChannelId);
        var arg2 = cst_encode_box_autoadd_public_key(counterpartyNodeId);
        var arg3 = cst_encode_box_autoadd_channel_config(channelConfig);
        return wire.wire_ldk_node_update_channel_config(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkNodeUpdateChannelConfigConstMeta,
      argValues: [that, userChannelId, counterpartyNodeId, channelConfig],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeUpdateChannelConfigConstMeta => const TaskConstMeta(
        debugName: "ldk_node_update_channel_config",
        argNames: [
          "that",
          "userChannelId",
          "counterpartyNodeId",
          "channelConfig"
        ],
      );

  @override
  Future<bool> ldkNodeVerifySignature(
      {required LdkNode that,
      required List<int> msg,
      required String sig,
      required PublicKey publicKey,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_list_prim_u_8_loose(msg);
        var arg2 = cst_encode_String(sig);
        var arg3 = cst_encode_box_autoadd_public_key(publicKey);
        return wire.wire_ldk_node_verify_signature(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkNodeVerifySignatureConstMeta,
      argValues: [that, msg, sig, publicKey],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeVerifySignatureConstMeta => const TaskConstMeta(
        debugName: "ldk_node_verify_signature",
        argNames: ["that", "msg", "sig", "publicKey"],
      );

  @override
  Future<Event> ldkNodeWaitNextEvent({required LdkNode that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire_ldk_node_wait_next_event(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_event,
        decodeErrorData: null,
      ),
      constMeta: kLdkNodeWaitNextEventConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkNodeWaitNextEventConstMeta => const TaskConstMeta(
        debugName: "ldk_node_wait_next_event",
        argNames: ["that"],
      );

  @override
  Future<Address> ldkOnChainPaymentNewAddress(
      {required LdkOnChainPayment that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_on_chain_payment(that);
        return wire.wire_ldk_on_chain_payment_new_address(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_address,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkOnChainPaymentNewAddressConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkOnChainPaymentNewAddressConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_on_chain_payment_new_address",
        argNames: ["that"],
      );

  @override
  Future<Txid> ldkOnChainPaymentSendAllToAddress(
      {required LdkOnChainPayment that,
      required Address address,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_on_chain_payment(that);
        var arg1 = cst_encode_box_autoadd_address(address);
        return wire.wire_ldk_on_chain_payment_send_all_to_address(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_txid,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkOnChainPaymentSendAllToAddressConstMeta,
      argValues: [that, address],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkOnChainPaymentSendAllToAddressConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_on_chain_payment_send_all_to_address",
        argNames: ["that", "address"],
      );

  @override
  Future<Txid> ldkOnChainPaymentSendToAddress(
      {required LdkOnChainPayment that,
      required Address address,
      required int amountSats,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_on_chain_payment(that);
        var arg1 = cst_encode_box_autoadd_address(address);
        var arg2 = cst_encode_u_64(amountSats);
        return wire.wire_ldk_on_chain_payment_send_to_address(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_txid,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkOnChainPaymentSendToAddressConstMeta,
      argValues: [that, address, amountSats],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkOnChainPaymentSendToAddressConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_on_chain_payment_send_to_address",
        argNames: ["that", "address", "amountSats"],
      );

  @override
  Future<PaymentId> ldkSpontaneousPaymentSend(
      {required LdkSpontaneousPayment that,
      required int amountMsat,
      required PublicKey nodeId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_spontaneous_payment(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_box_autoadd_public_key(nodeId);
        return wire.wire_ldk_spontaneous_payment_send(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payment_id,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkSpontaneousPaymentSendConstMeta,
      argValues: [that, amountMsat, nodeId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkSpontaneousPaymentSendConstMeta => const TaskConstMeta(
        debugName: "ldk_spontaneous_payment_send",
        argNames: ["that", "amountMsat", "nodeId"],
      );

  @override
  Future<void> ldkSpontaneousPaymentSendProbes(
      {required LdkSpontaneousPayment that,
      required int amountMsat,
      required PublicKey nodeId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_spontaneous_payment(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_box_autoadd_public_key(nodeId);
        return wire.wire_ldk_spontaneous_payment_send_probes(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_node_exception,
      ),
      constMeta: kLdkSpontaneousPaymentSendProbesConstMeta,
      argValues: [that, amountMsat, nodeId],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLdkSpontaneousPaymentSendProbesConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_spontaneous_payment_send_probes",
        argNames: ["that", "amountMsat", "nodeId"],
      );

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Node =>
      wire.rust_arc_increment_strong_count_RustOpaque_Node;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Node =>
      wire.rust_arc_decrement_strong_count_RustOpaque_Node;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_NodeBuilder => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockNodeBuilder;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_NodeBuilder => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockNodeBuilder;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_LdkNodePaymentBolt11Payment => wire
          .rust_arc_increment_strong_count_RustOpaque_ldk_nodepaymentBolt11Payment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_LdkNodePaymentBolt11Payment => wire
          .rust_arc_decrement_strong_count_RustOpaque_ldk_nodepaymentBolt11Payment;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_LdkNodePaymentOnchainPayment => wire
          .rust_arc_increment_strong_count_RustOpaque_ldk_nodepaymentOnchainPayment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_LdkNodePaymentOnchainPayment => wire
          .rust_arc_decrement_strong_count_RustOpaque_ldk_nodepaymentOnchainPayment;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_LdkNodePaymentSpontaneousPayment => wire
          .rust_arc_increment_strong_count_RustOpaque_ldk_nodepaymentSpontaneousPayment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_LdkNodePaymentSpontaneousPayment => wire
          .rust_arc_decrement_strong_count_RustOpaque_ldk_nodepaymentSpontaneousPayment;

  @protected
  NodeBuilder
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockNodeBuilder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NodeBuilder.dcoDecode(raw as List<dynamic>);
  }

  @protected
  Node dco_decode_RustOpaque_Node(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Node.dcoDecode(raw as List<dynamic>);
  }

  @protected
  NodeBuilder
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockNodeBuilder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NodeBuilder.dcoDecode(raw as List<dynamic>);
  }

  @protected
  LdkNodePaymentBolt11Payment
      dco_decode_RustOpaque_ldk_nodepaymentBolt11Payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return LdkNodePaymentBolt11Payment.dcoDecode(raw as List<dynamic>);
  }

  @protected
  LdkNodePaymentOnchainPayment
      dco_decode_RustOpaque_ldk_nodepaymentOnchainPayment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return LdkNodePaymentOnchainPayment.dcoDecode(raw as List<dynamic>);
  }

  @protected
  LdkNodePaymentSpontaneousPayment
      dco_decode_RustOpaque_ldk_nodepaymentSpontaneousPayment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return LdkNodePaymentSpontaneousPayment.dcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  Address dco_decode_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Address(
      s: dco_decode_String(arr[0]),
    );
  }

  @protected
  BalanceDetails dco_decode_balance_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return BalanceDetails(
      totalOnchainBalanceSats: dco_decode_u_64(arr[0]),
      spendableOnchainBalanceSats: dco_decode_u_64(arr[1]),
      totalLightningBalanceSats: dco_decode_u_64(arr[2]),
      lightningBalances: dco_decode_list_lightning_balance(arr[3]),
      pendingBalancesFromChannelClosures:
          dco_decode_list_pending_sweep_balance(arr[4]),
    );
  }

  @protected
  BestBlock dco_decode_best_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BestBlock(
      blockHash: dco_decode_String(arr[0]),
      height: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  Bolt11Invoice dco_decode_bolt_11_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Bolt11Invoice(
      signedRawInvoice: dco_decode_String(arr[0]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  Address dco_decode_box_autoadd_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_address(raw);
  }

  @protected
  Bolt11Invoice dco_decode_box_autoadd_bolt_11_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bolt_11_invoice(raw);
  }

  @protected
  ChainDataSourceConfig dco_decode_box_autoadd_chain_data_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_chain_data_source_config(raw);
  }

  @protected
  ChannelConfig dco_decode_box_autoadd_channel_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_channel_config(raw);
  }

  @protected
  ChannelId dco_decode_box_autoadd_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_channel_id(raw);
  }

  @protected
  ClosureReason dco_decode_box_autoadd_closure_reason(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_closure_reason(raw);
  }

  @protected
  Config dco_decode_box_autoadd_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_config(raw);
  }

  @protected
  EntropySourceConfig dco_decode_box_autoadd_entropy_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_entropy_source_config(raw);
  }

  @protected
  Event dco_decode_box_autoadd_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_event(raw);
  }

  @protected
  GossipSourceConfig dco_decode_box_autoadd_gossip_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_gossip_source_config(raw);
  }

  @protected
  LdkBolt11Payment dco_decode_box_autoadd_ldk_bolt_11_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ldk_bolt_11_payment(raw);
  }

  @protected
  LdkMnemonic dco_decode_box_autoadd_ldk_mnemonic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ldk_mnemonic(raw);
  }

  @protected
  LdkNode dco_decode_box_autoadd_ldk_node(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ldk_node(raw);
  }

  @protected
  LdkOnChainPayment dco_decode_box_autoadd_ldk_on_chain_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ldk_on_chain_payment(raw);
  }

  @protected
  LdkSpontaneousPayment dco_decode_box_autoadd_ldk_spontaneous_payment(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ldk_spontaneous_payment(raw);
  }

  @protected
  LiquiditySourceConfig dco_decode_box_autoadd_liquidity_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_liquidity_source_config(raw);
  }

  @protected
  LSPFeeLimits dco_decode_box_autoadd_lsp_fee_limits(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_lsp_fee_limits(raw);
  }

  @protected
  MaxDustHTLCExposure dco_decode_box_autoadd_max_dust_htlc_exposure(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_max_dust_htlc_exposure(raw);
  }

  @protected
  OutPoint dco_decode_box_autoadd_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_out_point(raw);
  }

  @protected
  PaymentDetails dco_decode_box_autoadd_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_details(raw);
  }

  @protected
  PaymentFailureReason dco_decode_box_autoadd_payment_failure_reason(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_failure_reason(raw);
  }

  @protected
  PaymentHash dco_decode_box_autoadd_payment_hash(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_hash(raw);
  }

  @protected
  PaymentId dco_decode_box_autoadd_payment_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_id(raw);
  }

  @protected
  PaymentPreimage dco_decode_box_autoadd_payment_preimage(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_preimage(raw);
  }

  @protected
  PaymentSecret dco_decode_box_autoadd_payment_secret(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_secret(raw);
  }

  @protected
  PublicKey dco_decode_box_autoadd_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_public_key(raw);
  }

  @protected
  SocketAddress dco_decode_box_autoadd_socket_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_socket_address(raw);
  }

  @protected
  Txid dco_decode_box_autoadd_txid(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_txid(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  UserChannelId dco_decode_box_autoadd_user_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_user_channel_id(raw);
  }

  @protected
  BuilderException dco_decode_builder_exception(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BuilderException.values[raw as int];
  }

  @protected
  ChainDataSourceConfig dco_decode_chain_data_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ChainDataSourceConfig_Esplora(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ChannelConfig dco_decode_channel_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ChannelConfig(
      forwardingFeeProportionalMillionths: dco_decode_u_32(arr[0]),
      forwardingFeeBaseMsat: dco_decode_u_32(arr[1]),
      cltvExpiryDelta: dco_decode_u_16(arr[2]),
      maxDustHtlcExposure:
          dco_decode_opt_box_autoadd_max_dust_htlc_exposure(arr[3]),
      forceCloseAvoidanceMaxFeeSatoshis: dco_decode_u_64(arr[4]),
      acceptUnderpayingHtlcs: dco_decode_bool(arr[5]),
    );
  }

  @protected
  ChannelDetails dco_decode_channel_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 28)
      throw Exception('unexpected arr length: expect 28 but see ${arr.length}');
    return ChannelDetails(
      channelId: dco_decode_channel_id(arr[0]),
      counterpartyNodeId: dco_decode_public_key(arr[1]),
      fundingTxo: dco_decode_opt_box_autoadd_out_point(arr[2]),
      channelValueSats: dco_decode_u_64(arr[3]),
      unspendablePunishmentReserve: dco_decode_opt_box_autoadd_u_64(arr[4]),
      userChannelId: dco_decode_user_channel_id(arr[5]),
      feerateSatPer1000Weight: dco_decode_u_32(arr[6]),
      outboundCapacityMsat: dco_decode_u_64(arr[7]),
      inboundCapacityMsat: dco_decode_u_64(arr[8]),
      confirmationsRequired: dco_decode_opt_box_autoadd_u_32(arr[9]),
      confirmations: dco_decode_opt_box_autoadd_u_32(arr[10]),
      isOutbound: dco_decode_bool(arr[11]),
      isChannelReady: dco_decode_bool(arr[12]),
      isUsable: dco_decode_bool(arr[13]),
      isPublic: dco_decode_bool(arr[14]),
      cltvExpiryDelta: dco_decode_opt_box_autoadd_u_16(arr[15]),
      counterpartyUnspendablePunishmentReserve: dco_decode_u_64(arr[16]),
      counterpartyOutboundHtlcMinimumMsat:
          dco_decode_opt_box_autoadd_u_64(arr[17]),
      counterpartyOutboundHtlcMaximumMsat:
          dco_decode_opt_box_autoadd_u_64(arr[18]),
      counterpartyForwardingInfoFeeBaseMsat:
          dco_decode_opt_box_autoadd_u_32(arr[19]),
      counterpartyForwardingInfoFeeProportionalMillionths:
          dco_decode_opt_box_autoadd_u_32(arr[20]),
      counterpartyForwardingInfoCltvExpiryDelta:
          dco_decode_opt_box_autoadd_u_16(arr[21]),
      nextOutboundHtlcLimitMsat: dco_decode_u_64(arr[22]),
      nextOutboundHtlcMinimumMsat: dco_decode_u_64(arr[23]),
      forceCloseSpendDelay: dco_decode_opt_box_autoadd_u_16(arr[24]),
      inboundHtlcMinimumMsat: dco_decode_u_64(arr[25]),
      inboundHtlcMaximumMsat: dco_decode_opt_box_autoadd_u_64(arr[26]),
      config: dco_decode_channel_config(arr[27]),
    );
  }

  @protected
  ChannelId dco_decode_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return ChannelId(
      data: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  ClosureReason dco_decode_closure_reason(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ClosureReason_CounterpartyForceClosed(
          peerMsg: dco_decode_String(raw[1]),
        );
      case 1:
        return ClosureReason_HolderForceClosed();
      case 2:
        return ClosureReason_LegacyCooperativeClosure();
      case 3:
        return ClosureReason_CounterpartyInitiatedCooperativeClosure();
      case 4:
        return ClosureReason_LocallyInitiatedCooperativeClosure();
      case 5:
        return ClosureReason_CommitmentTxConfirmed();
      case 6:
        return ClosureReason_FundingTimedOut();
      case 7:
        return ClosureReason_ProcessingError(
          err: dco_decode_String(raw[1]),
        );
      case 8:
        return ClosureReason_DisconnectedPeer();
      case 9:
        return ClosureReason_OutdatedChannelManager();
      case 10:
        return ClosureReason_CounterpartyCoopClosedUnfundedChannel();
      case 11:
        return ClosureReason_FundingBatchClosure();
      case 12:
        return ClosureReason_HTLCsTimedOut();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Config dco_decode_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return Config(
      storageDirPath: dco_decode_String(arr[0]),
      logDirPath: dco_decode_opt_String(arr[1]),
      network: dco_decode_network(arr[2]),
      listeningAddresses: dco_decode_opt_list_socket_address(arr[3]),
      defaultCltvExpiryDelta: dco_decode_u_32(arr[4]),
      onchainWalletSyncIntervalSecs: dco_decode_u_64(arr[5]),
      walletSyncIntervalSecs: dco_decode_u_64(arr[6]),
      feeRateCacheUpdateIntervalSecs: dco_decode_u_64(arr[7]),
      trustedPeers0Conf: dco_decode_list_public_key(arr[8]),
      probingLiquidityLimitMultiplier: dco_decode_u_64(arr[9]),
      logLevel: dco_decode_log_level(arr[10]),
    );
  }

  @protected
  EntropySourceConfig dco_decode_entropy_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return EntropySourceConfig_SeedFile(
          dco_decode_String(raw[1]),
        );
      case 1:
        return EntropySourceConfig_SeedBytes(
          dco_decode_u_8_array_64(raw[1]),
        );
      case 2:
        return EntropySourceConfig_Bip39Mnemonic(
          mnemonic: dco_decode_box_autoadd_ldk_mnemonic(raw[1]),
          passphrase: dco_decode_opt_String(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Event dco_decode_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Event_PaymentSuccessful(
          paymentId: dco_decode_opt_box_autoadd_payment_id(raw[1]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[2]),
          feePaidMsat: dco_decode_opt_box_autoadd_u_64(raw[3]),
        );
      case 1:
        return Event_PaymentFailed(
          paymentId: dco_decode_opt_box_autoadd_payment_id(raw[1]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[2]),
          reason: dco_decode_opt_box_autoadd_payment_failure_reason(raw[3]),
        );
      case 2:
        return Event_PaymentReceived(
          paymentId: dco_decode_opt_box_autoadd_payment_id(raw[1]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[2]),
          amountMsat: dco_decode_u_64(raw[3]),
        );
      case 3:
        return Event_ChannelPending(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          userChannelId: dco_decode_box_autoadd_user_channel_id(raw[2]),
          formerTemporaryChannelId: dco_decode_box_autoadd_channel_id(raw[3]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[4]),
          fundingTxo: dco_decode_box_autoadd_out_point(raw[5]),
        );
      case 4:
        return Event_ChannelReady(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          userChannelId: dco_decode_box_autoadd_user_channel_id(raw[2]),
          counterpartyNodeId: dco_decode_opt_box_autoadd_public_key(raw[3]),
        );
      case 5:
        return Event_ChannelClosed(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          userChannelId: dco_decode_box_autoadd_user_channel_id(raw[2]),
          counterpartyNodeId: dco_decode_opt_box_autoadd_public_key(raw[3]),
          reason: dco_decode_opt_box_autoadd_closure_reason(raw[4]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  GossipSourceConfig dco_decode_gossip_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return GossipSourceConfig_P2PNetwork();
      case 1:
        return GossipSourceConfig_RapidGossipSync(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  LdkBolt11Payment dco_decode_ldk_bolt_11_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LdkBolt11Payment(
      ptr: dco_decode_RustOpaque_ldk_nodepaymentBolt11Payment(arr[0]),
    );
  }

  @protected
  LdkMnemonic dco_decode_ldk_mnemonic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LdkMnemonic(
      seedPhrase: dco_decode_String(arr[0]),
    );
  }

  @protected
  LdkNode dco_decode_ldk_node(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LdkNode(
      ptr: dco_decode_RustOpaque_Node(arr[0]),
    );
  }

  @protected
  LdkOnChainPayment dco_decode_ldk_on_chain_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LdkOnChainPayment(
      ptr: dco_decode_RustOpaque_ldk_nodepaymentOnchainPayment(arr[0]),
    );
  }

  @protected
  LdkSpontaneousPayment dco_decode_ldk_spontaneous_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LdkSpontaneousPayment(
      ptr: dco_decode_RustOpaque_ldk_nodepaymentSpontaneousPayment(arr[0]),
    );
  }

  @protected
  LightningBalance dco_decode_lightning_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LightningBalance_ClaimableOnChannelClose(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
        );
      case 1:
        return LightningBalance_ClaimableAwaitingConfirmations(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
          confirmationHeight: dco_decode_u_32(raw[4]),
        );
      case 2:
        return LightningBalance_ContentiousClaimable(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
          timeoutHeight: dco_decode_u_32(raw[4]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[5]),
          paymentPreimage: dco_decode_box_autoadd_payment_preimage(raw[6]),
        );
      case 3:
        return LightningBalance_MaybeTimeoutClaimableHTLC(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
          claimableHeight: dco_decode_u_32(raw[4]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[5]),
        );
      case 4:
        return LightningBalance_MaybePreimageClaimableHTLC(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
          expiryHeight: dco_decode_u_32(raw[4]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[5]),
        );
      case 5:
        return LightningBalance_CounterpartyRevokedOutputClaimable(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LiquiditySourceConfig dco_decode_liquidity_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LiquiditySourceConfig(
      lsps2Service:
          dco_decode_record_socket_address_public_key_opt_string(arr[0]),
    );
  }

  @protected
  List<ChannelDetails> dco_decode_list_channel_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_channel_details).toList();
  }

  @protected
  List<LightningBalance> dco_decode_list_lightning_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_lightning_balance).toList();
  }

  @protected
  List<PaymentDetails> dco_decode_list_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_payment_details).toList();
  }

  @protected
  List<PeerDetails> dco_decode_list_peer_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_peer_details).toList();
  }

  @protected
  List<PendingSweepBalance> dco_decode_list_pending_sweep_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_pending_sweep_balance)
        .toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<PublicKey> dco_decode_list_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_public_key).toList();
  }

  @protected
  List<SocketAddress> dco_decode_list_socket_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_socket_address).toList();
  }

  @protected
  LogLevel dco_decode_log_level(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return LogLevel.values[raw as int];
  }

  @protected
  LSPFeeLimits dco_decode_lsp_fee_limits(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LSPFeeLimits(
      maxTotalOpeningFeeMsat: dco_decode_opt_box_autoadd_u_64(arr[0]),
      maxProportionalOpeningFeePpmMsat: dco_decode_opt_box_autoadd_u_64(arr[1]),
    );
  }

  @protected
  MaxDustHTLCExposure dco_decode_max_dust_htlc_exposure(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return MaxDustHTLCExposure_FixedLimitMsat(
          dco_decode_u_64(raw[1]),
        );
      case 1:
        return MaxDustHTLCExposure_FeeRateMultiplier(
          dco_decode_u_64(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  NodeException dco_decode_node_exception(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NodeException.values[raw as int];
  }

  @protected
  NodeStatus dco_decode_node_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return NodeStatus(
      isRunning: dco_decode_bool(arr[0]),
      isListening: dco_decode_bool(arr[1]),
      currentBestBlock: dco_decode_best_block(arr[2]),
      latestWalletSyncTimestamp: dco_decode_opt_box_autoadd_u_64(arr[3]),
      latestOnchainWalletSyncTimestamp: dco_decode_opt_box_autoadd_u_64(arr[4]),
      latestFeeRateCacheUpdateTimestamp:
          dco_decode_opt_box_autoadd_u_64(arr[5]),
      latestRgsSnapshotTimestamp: dco_decode_opt_box_autoadd_u_64(arr[6]),
      latestNodeAnnouncementBroadcastTimestamp:
          dco_decode_opt_box_autoadd_u_64(arr[7]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  ChainDataSourceConfig? dco_decode_opt_box_autoadd_chain_data_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_chain_data_source_config(raw);
  }

  @protected
  ChannelConfig? dco_decode_opt_box_autoadd_channel_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_channel_config(raw);
  }

  @protected
  ChannelId? dco_decode_opt_box_autoadd_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_channel_id(raw);
  }

  @protected
  ClosureReason? dco_decode_opt_box_autoadd_closure_reason(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_closure_reason(raw);
  }

  @protected
  EntropySourceConfig? dco_decode_opt_box_autoadd_entropy_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_entropy_source_config(raw);
  }

  @protected
  Event? dco_decode_opt_box_autoadd_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_event(raw);
  }

  @protected
  GossipSourceConfig? dco_decode_opt_box_autoadd_gossip_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_gossip_source_config(raw);
  }

  @protected
  LiquiditySourceConfig? dco_decode_opt_box_autoadd_liquidity_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_liquidity_source_config(raw);
  }

  @protected
  MaxDustHTLCExposure? dco_decode_opt_box_autoadd_max_dust_htlc_exposure(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_max_dust_htlc_exposure(raw);
  }

  @protected
  OutPoint? dco_decode_opt_box_autoadd_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_out_point(raw);
  }

  @protected
  PaymentDetails? dco_decode_opt_box_autoadd_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_details(raw);
  }

  @protected
  PaymentFailureReason? dco_decode_opt_box_autoadd_payment_failure_reason(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_payment_failure_reason(raw);
  }

  @protected
  PaymentId? dco_decode_opt_box_autoadd_payment_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_id(raw);
  }

  @protected
  PaymentPreimage? dco_decode_opt_box_autoadd_payment_preimage(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_preimage(raw);
  }

  @protected
  PaymentSecret? dco_decode_opt_box_autoadd_payment_secret(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_secret(raw);
  }

  @protected
  PublicKey? dco_decode_opt_box_autoadd_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_public_key(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_16(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  List<SocketAddress>? dco_decode_opt_list_socket_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_socket_address(raw);
  }

  @protected
  OutPoint dco_decode_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OutPoint(
      txid: dco_decode_txid(arr[0]),
      vout: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  PaymentDetails dco_decode_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return PaymentDetails(
      id: dco_decode_payment_id(arr[0]),
      kind: dco_decode_payment_kind(arr[1]),
      amountMsat: dco_decode_opt_box_autoadd_u_64(arr[2]),
      direction: dco_decode_payment_direction(arr[3]),
      status: dco_decode_payment_status(arr[4]),
    );
  }

  @protected
  PaymentDirection dco_decode_payment_direction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentDirection.values[raw as int];
  }

  @protected
  PaymentFailureReason dco_decode_payment_failure_reason(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentFailureReason.values[raw as int];
  }

  @protected
  PaymentHash dco_decode_payment_hash(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PaymentHash(
      data: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  PaymentId dco_decode_payment_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PaymentId(
      field0: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  PaymentKind dco_decode_payment_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PaymentKind_Onchain();
      case 1:
        return PaymentKind_Bolt11(
          hash: dco_decode_box_autoadd_payment_hash(raw[1]),
          preimage: dco_decode_opt_box_autoadd_payment_preimage(raw[2]),
          secret: dco_decode_opt_box_autoadd_payment_secret(raw[3]),
        );
      case 2:
        return PaymentKind_Bolt11Jit(
          hash: dco_decode_box_autoadd_payment_hash(raw[1]),
          preimage: dco_decode_opt_box_autoadd_payment_preimage(raw[2]),
          secret: dco_decode_opt_box_autoadd_payment_secret(raw[3]),
          lspFeeLimits: dco_decode_box_autoadd_lsp_fee_limits(raw[4]),
        );
      case 3:
        return PaymentKind_Spontaneous(
          hash: dco_decode_box_autoadd_payment_hash(raw[1]),
          preimage: dco_decode_opt_box_autoadd_payment_preimage(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PaymentPreimage dco_decode_payment_preimage(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PaymentPreimage(
      data: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  PaymentSecret dco_decode_payment_secret(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PaymentSecret(
      data: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  PaymentStatus dco_decode_payment_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentStatus.values[raw as int];
  }

  @protected
  PeerDetails dco_decode_peer_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PeerDetails(
      nodeId: dco_decode_public_key(arr[0]),
      address: dco_decode_socket_address(arr[1]),
      isConnected: dco_decode_bool(arr[2]),
    );
  }

  @protected
  PendingSweepBalance dco_decode_pending_sweep_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PendingSweepBalance_PendingBroadcast(
          channelId: dco_decode_opt_box_autoadd_channel_id(raw[1]),
          amountSatoshis: dco_decode_u_64(raw[2]),
        );
      case 1:
        return PendingSweepBalance_BroadcastAwaitingConfirmation(
          channelId: dco_decode_opt_box_autoadd_channel_id(raw[1]),
          latestBroadcastHeight: dco_decode_u_32(raw[2]),
          latestSpendingTxid: dco_decode_box_autoadd_txid(raw[3]),
          amountSatoshis: dco_decode_u_64(raw[4]),
        );
      case 2:
        return PendingSweepBalance_AwaitingThresholdConfirmations(
          channelId: dco_decode_opt_box_autoadd_channel_id(raw[1]),
          latestSpendingTxid: dco_decode_box_autoadd_txid(raw[2]),
          confirmationHash: dco_decode_String(raw[3]),
          confirmationHeight: dco_decode_u_32(raw[4]),
          amountSatoshis: dco_decode_u_64(raw[5]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PublicKey dco_decode_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PublicKey(
      hex: dco_decode_String(arr[0]),
    );
  }

  @protected
  (SocketAddress, PublicKey, String?)
      dco_decode_record_socket_address_public_key_opt_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) {
      throw Exception('Expected 3 elements, got ${arr.length}');
    }
    return (
      dco_decode_socket_address(arr[0]),
      dco_decode_public_key(arr[1]),
      dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  SocketAddress dco_decode_socket_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SocketAddress_TcpIpV4(
          addr: dco_decode_u_8_array_4(raw[1]),
          port: dco_decode_u_16(raw[2]),
        );
      case 1:
        return SocketAddress_TcpIpV6(
          addr: dco_decode_u_8_array_16(raw[1]),
          port: dco_decode_u_16(raw[2]),
        );
      case 2:
        return SocketAddress_OnionV2(
          dco_decode_u_8_array_12(raw[1]),
        );
      case 3:
        return SocketAddress_OnionV3(
          ed25519Pubkey: dco_decode_u_8_array_32(raw[1]),
          checksum: dco_decode_u_16(raw[2]),
          version: dco_decode_u_8(raw[3]),
          port: dco_decode_u_16(raw[4]),
        );
      case 4:
        return SocketAddress_Hostname(
          addr: dco_decode_String(raw[1]),
          port: dco_decode_u_16(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Txid dco_decode_txid(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Txid(
      hash: dco_decode_String(arr[0]),
    );
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  U8Array12 dco_decode_u_8_array_12(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array12(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  U8Array16 dco_decode_u_8_array_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array16(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  U8Array32 dco_decode_u_8_array_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array32(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  U8Array4 dco_decode_u_8_array_4(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array4(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  U8Array64 dco_decode_u_8_array_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array64(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  UserChannelId dco_decode_user_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return UserChannelId(
      data: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  int dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  NodeBuilder
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockNodeBuilder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NodeBuilder.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Node sse_decode_RustOpaque_Node(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Node.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  NodeBuilder
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockNodeBuilder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NodeBuilder.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  LdkNodePaymentBolt11Payment
      sse_decode_RustOpaque_ldk_nodepaymentBolt11Payment(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return LdkNodePaymentBolt11Payment.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  LdkNodePaymentOnchainPayment
      sse_decode_RustOpaque_ldk_nodepaymentOnchainPayment(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return LdkNodePaymentOnchainPayment.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  LdkNodePaymentSpontaneousPayment
      sse_decode_RustOpaque_ldk_nodepaymentSpontaneousPayment(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return LdkNodePaymentSpontaneousPayment.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  Address sse_decode_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_s = sse_decode_String(deserializer);
    return Address(s: var_s);
  }

  @protected
  BalanceDetails sse_decode_balance_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_totalOnchainBalanceSats = sse_decode_u_64(deserializer);
    var var_spendableOnchainBalanceSats = sse_decode_u_64(deserializer);
    var var_totalLightningBalanceSats = sse_decode_u_64(deserializer);
    var var_lightningBalances = sse_decode_list_lightning_balance(deserializer);
    var var_pendingBalancesFromChannelClosures =
        sse_decode_list_pending_sweep_balance(deserializer);
    return BalanceDetails(
        totalOnchainBalanceSats: var_totalOnchainBalanceSats,
        spendableOnchainBalanceSats: var_spendableOnchainBalanceSats,
        totalLightningBalanceSats: var_totalLightningBalanceSats,
        lightningBalances: var_lightningBalances,
        pendingBalancesFromChannelClosures:
            var_pendingBalancesFromChannelClosures);
  }

  @protected
  BestBlock sse_decode_best_block(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_blockHash = sse_decode_String(deserializer);
    var var_height = sse_decode_u_32(deserializer);
    return BestBlock(blockHash: var_blockHash, height: var_height);
  }

  @protected
  Bolt11Invoice sse_decode_bolt_11_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_signedRawInvoice = sse_decode_String(deserializer);
    return Bolt11Invoice(signedRawInvoice: var_signedRawInvoice);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  Address sse_decode_box_autoadd_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_address(deserializer));
  }

  @protected
  Bolt11Invoice sse_decode_box_autoadd_bolt_11_invoice(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bolt_11_invoice(deserializer));
  }

  @protected
  ChainDataSourceConfig sse_decode_box_autoadd_chain_data_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_chain_data_source_config(deserializer));
  }

  @protected
  ChannelConfig sse_decode_box_autoadd_channel_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_channel_config(deserializer));
  }

  @protected
  ChannelId sse_decode_box_autoadd_channel_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_channel_id(deserializer));
  }

  @protected
  ClosureReason sse_decode_box_autoadd_closure_reason(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_closure_reason(deserializer));
  }

  @protected
  Config sse_decode_box_autoadd_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_config(deserializer));
  }

  @protected
  EntropySourceConfig sse_decode_box_autoadd_entropy_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_entropy_source_config(deserializer));
  }

  @protected
  Event sse_decode_box_autoadd_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_event(deserializer));
  }

  @protected
  GossipSourceConfig sse_decode_box_autoadd_gossip_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_gossip_source_config(deserializer));
  }

  @protected
  LdkBolt11Payment sse_decode_box_autoadd_ldk_bolt_11_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ldk_bolt_11_payment(deserializer));
  }

  @protected
  LdkMnemonic sse_decode_box_autoadd_ldk_mnemonic(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ldk_mnemonic(deserializer));
  }

  @protected
  LdkNode sse_decode_box_autoadd_ldk_node(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ldk_node(deserializer));
  }

  @protected
  LdkOnChainPayment sse_decode_box_autoadd_ldk_on_chain_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ldk_on_chain_payment(deserializer));
  }

  @protected
  LdkSpontaneousPayment sse_decode_box_autoadd_ldk_spontaneous_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ldk_spontaneous_payment(deserializer));
  }

  @protected
  LiquiditySourceConfig sse_decode_box_autoadd_liquidity_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_liquidity_source_config(deserializer));
  }

  @protected
  LSPFeeLimits sse_decode_box_autoadd_lsp_fee_limits(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_lsp_fee_limits(deserializer));
  }

  @protected
  MaxDustHTLCExposure sse_decode_box_autoadd_max_dust_htlc_exposure(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_max_dust_htlc_exposure(deserializer));
  }

  @protected
  OutPoint sse_decode_box_autoadd_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_out_point(deserializer));
  }

  @protected
  PaymentDetails sse_decode_box_autoadd_payment_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_details(deserializer));
  }

  @protected
  PaymentFailureReason sse_decode_box_autoadd_payment_failure_reason(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_failure_reason(deserializer));
  }

  @protected
  PaymentHash sse_decode_box_autoadd_payment_hash(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_hash(deserializer));
  }

  @protected
  PaymentId sse_decode_box_autoadd_payment_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_id(deserializer));
  }

  @protected
  PaymentPreimage sse_decode_box_autoadd_payment_preimage(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_preimage(deserializer));
  }

  @protected
  PaymentSecret sse_decode_box_autoadd_payment_secret(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_secret(deserializer));
  }

  @protected
  PublicKey sse_decode_box_autoadd_public_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_public_key(deserializer));
  }

  @protected
  SocketAddress sse_decode_box_autoadd_socket_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_socket_address(deserializer));
  }

  @protected
  Txid sse_decode_box_autoadd_txid(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_txid(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_16(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  UserChannelId sse_decode_box_autoadd_user_channel_id(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_user_channel_id(deserializer));
  }

  @protected
  BuilderException sse_decode_builder_exception(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return BuilderException.values[inner];
  }

  @protected
  ChainDataSourceConfig sse_decode_chain_data_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return ChainDataSourceConfig_Esplora(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ChannelConfig sse_decode_channel_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_forwardingFeeProportionalMillionths = sse_decode_u_32(deserializer);
    var var_forwardingFeeBaseMsat = sse_decode_u_32(deserializer);
    var var_cltvExpiryDelta = sse_decode_u_16(deserializer);
    var var_maxDustHtlcExposure =
        sse_decode_opt_box_autoadd_max_dust_htlc_exposure(deserializer);
    var var_forceCloseAvoidanceMaxFeeSatoshis = sse_decode_u_64(deserializer);
    var var_acceptUnderpayingHtlcs = sse_decode_bool(deserializer);
    return ChannelConfig(
        forwardingFeeProportionalMillionths:
            var_forwardingFeeProportionalMillionths,
        forwardingFeeBaseMsat: var_forwardingFeeBaseMsat,
        cltvExpiryDelta: var_cltvExpiryDelta,
        maxDustHtlcExposure: var_maxDustHtlcExposure,
        forceCloseAvoidanceMaxFeeSatoshis:
            var_forceCloseAvoidanceMaxFeeSatoshis,
        acceptUnderpayingHtlcs: var_acceptUnderpayingHtlcs);
  }

  @protected
  ChannelDetails sse_decode_channel_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_channelId = sse_decode_channel_id(deserializer);
    var var_counterpartyNodeId = sse_decode_public_key(deserializer);
    var var_fundingTxo = sse_decode_opt_box_autoadd_out_point(deserializer);
    var var_channelValueSats = sse_decode_u_64(deserializer);
    var var_unspendablePunishmentReserve =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_userChannelId = sse_decode_user_channel_id(deserializer);
    var var_feerateSatPer1000Weight = sse_decode_u_32(deserializer);
    var var_outboundCapacityMsat = sse_decode_u_64(deserializer);
    var var_inboundCapacityMsat = sse_decode_u_64(deserializer);
    var var_confirmationsRequired =
        sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_confirmations = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_isOutbound = sse_decode_bool(deserializer);
    var var_isChannelReady = sse_decode_bool(deserializer);
    var var_isUsable = sse_decode_bool(deserializer);
    var var_isPublic = sse_decode_bool(deserializer);
    var var_cltvExpiryDelta = sse_decode_opt_box_autoadd_u_16(deserializer);
    var var_counterpartyUnspendablePunishmentReserve =
        sse_decode_u_64(deserializer);
    var var_counterpartyOutboundHtlcMinimumMsat =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_counterpartyOutboundHtlcMaximumMsat =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_counterpartyForwardingInfoFeeBaseMsat =
        sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_counterpartyForwardingInfoFeeProportionalMillionths =
        sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_counterpartyForwardingInfoCltvExpiryDelta =
        sse_decode_opt_box_autoadd_u_16(deserializer);
    var var_nextOutboundHtlcLimitMsat = sse_decode_u_64(deserializer);
    var var_nextOutboundHtlcMinimumMsat = sse_decode_u_64(deserializer);
    var var_forceCloseSpendDelay =
        sse_decode_opt_box_autoadd_u_16(deserializer);
    var var_inboundHtlcMinimumMsat = sse_decode_u_64(deserializer);
    var var_inboundHtlcMaximumMsat =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_config = sse_decode_channel_config(deserializer);
    return ChannelDetails(
        channelId: var_channelId,
        counterpartyNodeId: var_counterpartyNodeId,
        fundingTxo: var_fundingTxo,
        channelValueSats: var_channelValueSats,
        unspendablePunishmentReserve: var_unspendablePunishmentReserve,
        userChannelId: var_userChannelId,
        feerateSatPer1000Weight: var_feerateSatPer1000Weight,
        outboundCapacityMsat: var_outboundCapacityMsat,
        inboundCapacityMsat: var_inboundCapacityMsat,
        confirmationsRequired: var_confirmationsRequired,
        confirmations: var_confirmations,
        isOutbound: var_isOutbound,
        isChannelReady: var_isChannelReady,
        isUsable: var_isUsable,
        isPublic: var_isPublic,
        cltvExpiryDelta: var_cltvExpiryDelta,
        counterpartyUnspendablePunishmentReserve:
            var_counterpartyUnspendablePunishmentReserve,
        counterpartyOutboundHtlcMinimumMsat:
            var_counterpartyOutboundHtlcMinimumMsat,
        counterpartyOutboundHtlcMaximumMsat:
            var_counterpartyOutboundHtlcMaximumMsat,
        counterpartyForwardingInfoFeeBaseMsat:
            var_counterpartyForwardingInfoFeeBaseMsat,
        counterpartyForwardingInfoFeeProportionalMillionths:
            var_counterpartyForwardingInfoFeeProportionalMillionths,
        counterpartyForwardingInfoCltvExpiryDelta:
            var_counterpartyForwardingInfoCltvExpiryDelta,
        nextOutboundHtlcLimitMsat: var_nextOutboundHtlcLimitMsat,
        nextOutboundHtlcMinimumMsat: var_nextOutboundHtlcMinimumMsat,
        forceCloseSpendDelay: var_forceCloseSpendDelay,
        inboundHtlcMinimumMsat: var_inboundHtlcMinimumMsat,
        inboundHtlcMaximumMsat: var_inboundHtlcMaximumMsat,
        config: var_config);
  }

  @protected
  ChannelId sse_decode_channel_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_8_array_32(deserializer);
    return ChannelId(data: var_data);
  }

  @protected
  ClosureReason sse_decode_closure_reason(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_peerMsg = sse_decode_String(deserializer);
        return ClosureReason_CounterpartyForceClosed(peerMsg: var_peerMsg);
      case 1:
        return ClosureReason_HolderForceClosed();
      case 2:
        return ClosureReason_LegacyCooperativeClosure();
      case 3:
        return ClosureReason_CounterpartyInitiatedCooperativeClosure();
      case 4:
        return ClosureReason_LocallyInitiatedCooperativeClosure();
      case 5:
        return ClosureReason_CommitmentTxConfirmed();
      case 6:
        return ClosureReason_FundingTimedOut();
      case 7:
        var var_err = sse_decode_String(deserializer);
        return ClosureReason_ProcessingError(err: var_err);
      case 8:
        return ClosureReason_DisconnectedPeer();
      case 9:
        return ClosureReason_OutdatedChannelManager();
      case 10:
        return ClosureReason_CounterpartyCoopClosedUnfundedChannel();
      case 11:
        return ClosureReason_FundingBatchClosure();
      case 12:
        return ClosureReason_HTLCsTimedOut();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Config sse_decode_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_storageDirPath = sse_decode_String(deserializer);
    var var_logDirPath = sse_decode_opt_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_listeningAddresses =
        sse_decode_opt_list_socket_address(deserializer);
    var var_defaultCltvExpiryDelta = sse_decode_u_32(deserializer);
    var var_onchainWalletSyncIntervalSecs = sse_decode_u_64(deserializer);
    var var_walletSyncIntervalSecs = sse_decode_u_64(deserializer);
    var var_feeRateCacheUpdateIntervalSecs = sse_decode_u_64(deserializer);
    var var_trustedPeers0Conf = sse_decode_list_public_key(deserializer);
    var var_probingLiquidityLimitMultiplier = sse_decode_u_64(deserializer);
    var var_logLevel = sse_decode_log_level(deserializer);
    return Config(
        storageDirPath: var_storageDirPath,
        logDirPath: var_logDirPath,
        network: var_network,
        listeningAddresses: var_listeningAddresses,
        defaultCltvExpiryDelta: var_defaultCltvExpiryDelta,
        onchainWalletSyncIntervalSecs: var_onchainWalletSyncIntervalSecs,
        walletSyncIntervalSecs: var_walletSyncIntervalSecs,
        feeRateCacheUpdateIntervalSecs: var_feeRateCacheUpdateIntervalSecs,
        trustedPeers0Conf: var_trustedPeers0Conf,
        probingLiquidityLimitMultiplier: var_probingLiquidityLimitMultiplier,
        logLevel: var_logLevel);
  }

  @protected
  EntropySourceConfig sse_decode_entropy_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return EntropySourceConfig_SeedFile(var_field0);
      case 1:
        var var_field0 = sse_decode_u_8_array_64(deserializer);
        return EntropySourceConfig_SeedBytes(var_field0);
      case 2:
        var var_mnemonic = sse_decode_box_autoadd_ldk_mnemonic(deserializer);
        var var_passphrase = sse_decode_opt_String(deserializer);
        return EntropySourceConfig_Bip39Mnemonic(
            mnemonic: var_mnemonic, passphrase: var_passphrase);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Event sse_decode_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_paymentId = sse_decode_opt_box_autoadd_payment_id(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_feePaidMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
        return Event_PaymentSuccessful(
            paymentId: var_paymentId,
            paymentHash: var_paymentHash,
            feePaidMsat: var_feePaidMsat);
      case 1:
        var var_paymentId = sse_decode_opt_box_autoadd_payment_id(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_reason =
            sse_decode_opt_box_autoadd_payment_failure_reason(deserializer);
        return Event_PaymentFailed(
            paymentId: var_paymentId,
            paymentHash: var_paymentHash,
            reason: var_reason);
      case 2:
        var var_paymentId = sse_decode_opt_box_autoadd_payment_id(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_amountMsat = sse_decode_u_64(deserializer);
        return Event_PaymentReceived(
            paymentId: var_paymentId,
            paymentHash: var_paymentHash,
            amountMsat: var_amountMsat);
      case 3:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_userChannelId =
            sse_decode_box_autoadd_user_channel_id(deserializer);
        var var_formerTemporaryChannelId =
            sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_fundingTxo = sse_decode_box_autoadd_out_point(deserializer);
        return Event_ChannelPending(
            channelId: var_channelId,
            userChannelId: var_userChannelId,
            formerTemporaryChannelId: var_formerTemporaryChannelId,
            counterpartyNodeId: var_counterpartyNodeId,
            fundingTxo: var_fundingTxo);
      case 4:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_userChannelId =
            sse_decode_box_autoadd_user_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_opt_box_autoadd_public_key(deserializer);
        return Event_ChannelReady(
            channelId: var_channelId,
            userChannelId: var_userChannelId,
            counterpartyNodeId: var_counterpartyNodeId);
      case 5:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_userChannelId =
            sse_decode_box_autoadd_user_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_opt_box_autoadd_public_key(deserializer);
        var var_reason =
            sse_decode_opt_box_autoadd_closure_reason(deserializer);
        return Event_ChannelClosed(
            channelId: var_channelId,
            userChannelId: var_userChannelId,
            counterpartyNodeId: var_counterpartyNodeId,
            reason: var_reason);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  GossipSourceConfig sse_decode_gossip_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return GossipSourceConfig_P2PNetwork();
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return GossipSourceConfig_RapidGossipSync(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  LdkBolt11Payment sse_decode_ldk_bolt_11_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr =
        sse_decode_RustOpaque_ldk_nodepaymentBolt11Payment(deserializer);
    return LdkBolt11Payment(ptr: var_ptr);
  }

  @protected
  LdkMnemonic sse_decode_ldk_mnemonic(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seedPhrase = sse_decode_String(deserializer);
    return LdkMnemonic(seedPhrase: var_seedPhrase);
  }

  @protected
  LdkNode sse_decode_ldk_node(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_Node(deserializer);
    return LdkNode(ptr: var_ptr);
  }

  @protected
  LdkOnChainPayment sse_decode_ldk_on_chain_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr =
        sse_decode_RustOpaque_ldk_nodepaymentOnchainPayment(deserializer);
    return LdkOnChainPayment(ptr: var_ptr);
  }

  @protected
  LdkSpontaneousPayment sse_decode_ldk_spontaneous_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr =
        sse_decode_RustOpaque_ldk_nodepaymentSpontaneousPayment(deserializer);
    return LdkSpontaneousPayment(ptr: var_ptr);
  }

  @protected
  LightningBalance sse_decode_lightning_balance(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        return LightningBalance_ClaimableOnChannelClose(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis);
      case 1:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        var var_confirmationHeight = sse_decode_u_32(deserializer);
        return LightningBalance_ClaimableAwaitingConfirmations(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis,
            confirmationHeight: var_confirmationHeight);
      case 2:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        var var_timeoutHeight = sse_decode_u_32(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_paymentPreimage =
            sse_decode_box_autoadd_payment_preimage(deserializer);
        return LightningBalance_ContentiousClaimable(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis,
            timeoutHeight: var_timeoutHeight,
            paymentHash: var_paymentHash,
            paymentPreimage: var_paymentPreimage);
      case 3:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        var var_claimableHeight = sse_decode_u_32(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        return LightningBalance_MaybeTimeoutClaimableHTLC(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis,
            claimableHeight: var_claimableHeight,
            paymentHash: var_paymentHash);
      case 4:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        var var_expiryHeight = sse_decode_u_32(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        return LightningBalance_MaybePreimageClaimableHTLC(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis,
            expiryHeight: var_expiryHeight,
            paymentHash: var_paymentHash);
      case 5:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        return LightningBalance_CounterpartyRevokedOutputClaimable(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LiquiditySourceConfig sse_decode_liquidity_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_lsps2Service =
        sse_decode_record_socket_address_public_key_opt_string(deserializer);
    return LiquiditySourceConfig(lsps2Service: var_lsps2Service);
  }

  @protected
  List<ChannelDetails> sse_decode_list_channel_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ChannelDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_channel_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<LightningBalance> sse_decode_list_lightning_balance(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LightningBalance>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_lightning_balance(deserializer));
    }
    return ans_;
  }

  @protected
  List<PaymentDetails> sse_decode_list_payment_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PaymentDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_payment_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<PeerDetails> sse_decode_list_peer_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PeerDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_peer_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<PendingSweepBalance> sse_decode_list_pending_sweep_balance(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PendingSweepBalance>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_pending_sweep_balance(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<PublicKey> sse_decode_list_public_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PublicKey>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_public_key(deserializer));
    }
    return ans_;
  }

  @protected
  List<SocketAddress> sse_decode_list_socket_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SocketAddress>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_socket_address(deserializer));
    }
    return ans_;
  }

  @protected
  LogLevel sse_decode_log_level(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return LogLevel.values[inner];
  }

  @protected
  LSPFeeLimits sse_decode_lsp_fee_limits(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_maxTotalOpeningFeeMsat =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_maxProportionalOpeningFeePpmMsat =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    return LSPFeeLimits(
        maxTotalOpeningFeeMsat: var_maxTotalOpeningFeeMsat,
        maxProportionalOpeningFeePpmMsat: var_maxProportionalOpeningFeePpmMsat);
  }

  @protected
  MaxDustHTLCExposure sse_decode_max_dust_htlc_exposure(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_u_64(deserializer);
        return MaxDustHTLCExposure_FixedLimitMsat(var_field0);
      case 1:
        var var_field0 = sse_decode_u_64(deserializer);
        return MaxDustHTLCExposure_FeeRateMultiplier(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  NodeException sse_decode_node_exception(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return NodeException.values[inner];
  }

  @protected
  NodeStatus sse_decode_node_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_isRunning = sse_decode_bool(deserializer);
    var var_isListening = sse_decode_bool(deserializer);
    var var_currentBestBlock = sse_decode_best_block(deserializer);
    var var_latestWalletSyncTimestamp =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_latestOnchainWalletSyncTimestamp =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_latestFeeRateCacheUpdateTimestamp =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_latestRgsSnapshotTimestamp =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_latestNodeAnnouncementBroadcastTimestamp =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    return NodeStatus(
        isRunning: var_isRunning,
        isListening: var_isListening,
        currentBestBlock: var_currentBestBlock,
        latestWalletSyncTimestamp: var_latestWalletSyncTimestamp,
        latestOnchainWalletSyncTimestamp: var_latestOnchainWalletSyncTimestamp,
        latestFeeRateCacheUpdateTimestamp:
            var_latestFeeRateCacheUpdateTimestamp,
        latestRgsSnapshotTimestamp: var_latestRgsSnapshotTimestamp,
        latestNodeAnnouncementBroadcastTimestamp:
            var_latestNodeAnnouncementBroadcastTimestamp);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ChainDataSourceConfig? sse_decode_opt_box_autoadd_chain_data_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_chain_data_source_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ChannelConfig? sse_decode_opt_box_autoadd_channel_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_channel_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ChannelId? sse_decode_opt_box_autoadd_channel_id(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_channel_id(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ClosureReason? sse_decode_opt_box_autoadd_closure_reason(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_closure_reason(deserializer));
    } else {
      return null;
    }
  }

  @protected
  EntropySourceConfig? sse_decode_opt_box_autoadd_entropy_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_entropy_source_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Event? sse_decode_opt_box_autoadd_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_event(deserializer));
    } else {
      return null;
    }
  }

  @protected
  GossipSourceConfig? sse_decode_opt_box_autoadd_gossip_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_gossip_source_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  LiquiditySourceConfig? sse_decode_opt_box_autoadd_liquidity_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_liquidity_source_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  MaxDustHTLCExposure? sse_decode_opt_box_autoadd_max_dust_htlc_exposure(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_max_dust_htlc_exposure(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OutPoint? sse_decode_opt_box_autoadd_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_out_point(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentDetails? sse_decode_opt_box_autoadd_payment_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_details(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentFailureReason? sse_decode_opt_box_autoadd_payment_failure_reason(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_failure_reason(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentId? sse_decode_opt_box_autoadd_payment_id(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_id(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentPreimage? sse_decode_opt_box_autoadd_payment_preimage(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_preimage(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentSecret? sse_decode_opt_box_autoadd_payment_secret(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_secret(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PublicKey? sse_decode_opt_box_autoadd_public_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_public_key(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_16(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<SocketAddress>? sse_decode_opt_list_socket_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_socket_address(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OutPoint sse_decode_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_txid(deserializer);
    var var_vout = sse_decode_u_32(deserializer);
    return OutPoint(txid: var_txid, vout: var_vout);
  }

  @protected
  PaymentDetails sse_decode_payment_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_payment_id(deserializer);
    var var_kind = sse_decode_payment_kind(deserializer);
    var var_amountMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_direction = sse_decode_payment_direction(deserializer);
    var var_status = sse_decode_payment_status(deserializer);
    return PaymentDetails(
        id: var_id,
        kind: var_kind,
        amountMsat: var_amountMsat,
        direction: var_direction,
        status: var_status);
  }

  @protected
  PaymentDirection sse_decode_payment_direction(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentDirection.values[inner];
  }

  @protected
  PaymentFailureReason sse_decode_payment_failure_reason(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentFailureReason.values[inner];
  }

  @protected
  PaymentHash sse_decode_payment_hash(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_8_array_32(deserializer);
    return PaymentHash(data: var_data);
  }

  @protected
  PaymentId sse_decode_payment_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_8_array_32(deserializer);
    return PaymentId(field0: var_field0);
  }

  @protected
  PaymentKind sse_decode_payment_kind(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return PaymentKind_Onchain();
      case 1:
        var var_hash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_preimage =
            sse_decode_opt_box_autoadd_payment_preimage(deserializer);
        var var_secret =
            sse_decode_opt_box_autoadd_payment_secret(deserializer);
        return PaymentKind_Bolt11(
            hash: var_hash, preimage: var_preimage, secret: var_secret);
      case 2:
        var var_hash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_preimage =
            sse_decode_opt_box_autoadd_payment_preimage(deserializer);
        var var_secret =
            sse_decode_opt_box_autoadd_payment_secret(deserializer);
        var var_lspFeeLimits =
            sse_decode_box_autoadd_lsp_fee_limits(deserializer);
        return PaymentKind_Bolt11Jit(
            hash: var_hash,
            preimage: var_preimage,
            secret: var_secret,
            lspFeeLimits: var_lspFeeLimits);
      case 3:
        var var_hash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_preimage =
            sse_decode_opt_box_autoadd_payment_preimage(deserializer);
        return PaymentKind_Spontaneous(hash: var_hash, preimage: var_preimage);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PaymentPreimage sse_decode_payment_preimage(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_8_array_32(deserializer);
    return PaymentPreimage(data: var_data);
  }

  @protected
  PaymentSecret sse_decode_payment_secret(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_8_array_32(deserializer);
    return PaymentSecret(data: var_data);
  }

  @protected
  PaymentStatus sse_decode_payment_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentStatus.values[inner];
  }

  @protected
  PeerDetails sse_decode_peer_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_nodeId = sse_decode_public_key(deserializer);
    var var_address = sse_decode_socket_address(deserializer);
    var var_isConnected = sse_decode_bool(deserializer);
    return PeerDetails(
        nodeId: var_nodeId, address: var_address, isConnected: var_isConnected);
  }

  @protected
  PendingSweepBalance sse_decode_pending_sweep_balance(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_channelId = sse_decode_opt_box_autoadd_channel_id(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        return PendingSweepBalance_PendingBroadcast(
            channelId: var_channelId, amountSatoshis: var_amountSatoshis);
      case 1:
        var var_channelId = sse_decode_opt_box_autoadd_channel_id(deserializer);
        var var_latestBroadcastHeight = sse_decode_u_32(deserializer);
        var var_latestSpendingTxid = sse_decode_box_autoadd_txid(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        return PendingSweepBalance_BroadcastAwaitingConfirmation(
            channelId: var_channelId,
            latestBroadcastHeight: var_latestBroadcastHeight,
            latestSpendingTxid: var_latestSpendingTxid,
            amountSatoshis: var_amountSatoshis);
      case 2:
        var var_channelId = sse_decode_opt_box_autoadd_channel_id(deserializer);
        var var_latestSpendingTxid = sse_decode_box_autoadd_txid(deserializer);
        var var_confirmationHash = sse_decode_String(deserializer);
        var var_confirmationHeight = sse_decode_u_32(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        return PendingSweepBalance_AwaitingThresholdConfirmations(
            channelId: var_channelId,
            latestSpendingTxid: var_latestSpendingTxid,
            confirmationHash: var_confirmationHash,
            confirmationHeight: var_confirmationHeight,
            amountSatoshis: var_amountSatoshis);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PublicKey sse_decode_public_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hex = sse_decode_String(deserializer);
    return PublicKey(hex: var_hex);
  }

  @protected
  (SocketAddress, PublicKey, String?)
      sse_decode_record_socket_address_public_key_opt_string(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_socket_address(deserializer);
    var var_field1 = sse_decode_public_key(deserializer);
    var var_field2 = sse_decode_opt_String(deserializer);
    return (var_field0, var_field1, var_field2);
  }

  @protected
  SocketAddress sse_decode_socket_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_addr = sse_decode_u_8_array_4(deserializer);
        var var_port = sse_decode_u_16(deserializer);
        return SocketAddress_TcpIpV4(addr: var_addr, port: var_port);
      case 1:
        var var_addr = sse_decode_u_8_array_16(deserializer);
        var var_port = sse_decode_u_16(deserializer);
        return SocketAddress_TcpIpV6(addr: var_addr, port: var_port);
      case 2:
        var var_field0 = sse_decode_u_8_array_12(deserializer);
        return SocketAddress_OnionV2(var_field0);
      case 3:
        var var_ed25519Pubkey = sse_decode_u_8_array_32(deserializer);
        var var_checksum = sse_decode_u_16(deserializer);
        var var_version = sse_decode_u_8(deserializer);
        var var_port = sse_decode_u_16(deserializer);
        return SocketAddress_OnionV3(
            ed25519Pubkey: var_ed25519Pubkey,
            checksum: var_checksum,
            version: var_version,
            port: var_port);
      case 4:
        var var_addr = sse_decode_String(deserializer);
        var var_port = sse_decode_u_16(deserializer);
        return SocketAddress_Hostname(addr: var_addr, port: var_port);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Txid sse_decode_txid(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hash = sse_decode_String(deserializer);
    return Txid(hash: var_hash);
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  U8Array12 sse_decode_u_8_array_12(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array12(inner);
  }

  @protected
  U8Array16 sse_decode_u_8_array_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array16(inner);
  }

  @protected
  U8Array32 sse_decode_u_8_array_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array32(inner);
  }

  @protected
  U8Array4 sse_decode_u_8_array_4(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array4(inner);
  }

  @protected
  U8Array64 sse_decode_u_8_array_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array64(inner);
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  UserChannelId sse_decode_user_channel_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_list_prim_u_8_strict(deserializer);
    return UserChannelId(data: var_data);
  }

  @protected
  int sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint64();
  }

  @protected
  int cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockNodeBuilder(
      NodeBuilder raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode(move: true);
  }

  @protected
  int cst_encode_RustOpaque_Node(Node raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  int cst_encode_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockNodeBuilder(
      NodeBuilder raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ldk_nodepaymentBolt11Payment(
      LdkNodePaymentBolt11Payment raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ldk_nodepaymentOnchainPayment(
      LdkNodePaymentOnchainPayment raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ldk_nodepaymentSpontaneousPayment(
      LdkNodePaymentSpontaneousPayment raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_builder_exception(BuilderException raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_log_level(LogLevel raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_network(Network raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_node_exception(NodeException raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_direction(PaymentDirection raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_failure_reason(PaymentFailureReason raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_status(PaymentStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_16(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_usize(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockNodeBuilder(
          NodeBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void sse_encode_RustOpaque_Node(Node self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockNodeBuilder(
          NodeBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_ldk_nodepaymentBolt11Payment(
      LdkNodePaymentBolt11Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_ldk_nodepaymentOnchainPayment(
      LdkNodePaymentOnchainPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_ldk_nodepaymentSpontaneousPayment(
      LdkNodePaymentSpontaneousPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_address(Address self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.s, serializer);
  }

  @protected
  void sse_encode_balance_details(
      BalanceDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.totalOnchainBalanceSats, serializer);
    sse_encode_u_64(self.spendableOnchainBalanceSats, serializer);
    sse_encode_u_64(self.totalLightningBalanceSats, serializer);
    sse_encode_list_lightning_balance(self.lightningBalances, serializer);
    sse_encode_list_pending_sweep_balance(
        self.pendingBalancesFromChannelClosures, serializer);
  }

  @protected
  void sse_encode_best_block(BestBlock self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.blockHash, serializer);
    sse_encode_u_32(self.height, serializer);
  }

  @protected
  void sse_encode_bolt_11_invoice(
      Bolt11Invoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.signedRawInvoice, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_address(Address self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_address(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bolt_11_invoice(
      Bolt11Invoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bolt_11_invoice(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_chain_data_source_config(
      ChainDataSourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_chain_data_source_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_channel_config(
      ChannelConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_channel_id(
      ChannelId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_id(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_closure_reason(
      ClosureReason self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_closure_reason(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_config(Config self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_entropy_source_config(
      EntropySourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_entropy_source_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_event(Event self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_event(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_gossip_source_config(
      GossipSourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_gossip_source_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ldk_bolt_11_payment(
      LdkBolt11Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ldk_bolt_11_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ldk_mnemonic(
      LdkMnemonic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ldk_mnemonic(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ldk_node(LdkNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ldk_node(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ldk_on_chain_payment(
      LdkOnChainPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ldk_on_chain_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ldk_spontaneous_payment(
      LdkSpontaneousPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ldk_spontaneous_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_liquidity_source_config(
      LiquiditySourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_liquidity_source_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_lsp_fee_limits(
      LSPFeeLimits self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_lsp_fee_limits(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_max_dust_htlc_exposure(
      MaxDustHTLCExposure self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_max_dust_htlc_exposure(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_out_point(
      OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_details(
      PaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_details(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_failure_reason(
      PaymentFailureReason self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_failure_reason(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_hash(
      PaymentHash self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_hash(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_id(
      PaymentId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_id(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_preimage(
      PaymentPreimage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_preimage(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_secret(
      PaymentSecret self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_secret(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_public_key(
      PublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_public_key(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_socket_address(
      SocketAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_socket_address(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_txid(Txid self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_txid(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_user_channel_id(
      UserChannelId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_user_channel_id(self, serializer);
  }

  @protected
  void sse_encode_builder_exception(
      BuilderException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_chain_data_source_config(
      ChainDataSourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ChainDataSourceConfig_Esplora(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_channel_config(ChannelConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.forwardingFeeProportionalMillionths, serializer);
    sse_encode_u_32(self.forwardingFeeBaseMsat, serializer);
    sse_encode_u_16(self.cltvExpiryDelta, serializer);
    sse_encode_opt_box_autoadd_max_dust_htlc_exposure(
        self.maxDustHtlcExposure, serializer);
    sse_encode_u_64(self.forceCloseAvoidanceMaxFeeSatoshis, serializer);
    sse_encode_bool(self.acceptUnderpayingHtlcs, serializer);
  }

  @protected
  void sse_encode_channel_details(
      ChannelDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_id(self.channelId, serializer);
    sse_encode_public_key(self.counterpartyNodeId, serializer);
    sse_encode_opt_box_autoadd_out_point(self.fundingTxo, serializer);
    sse_encode_u_64(self.channelValueSats, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.unspendablePunishmentReserve, serializer);
    sse_encode_user_channel_id(self.userChannelId, serializer);
    sse_encode_u_32(self.feerateSatPer1000Weight, serializer);
    sse_encode_u_64(self.outboundCapacityMsat, serializer);
    sse_encode_u_64(self.inboundCapacityMsat, serializer);
    sse_encode_opt_box_autoadd_u_32(self.confirmationsRequired, serializer);
    sse_encode_opt_box_autoadd_u_32(self.confirmations, serializer);
    sse_encode_bool(self.isOutbound, serializer);
    sse_encode_bool(self.isChannelReady, serializer);
    sse_encode_bool(self.isUsable, serializer);
    sse_encode_bool(self.isPublic, serializer);
    sse_encode_opt_box_autoadd_u_16(self.cltvExpiryDelta, serializer);
    sse_encode_u_64(self.counterpartyUnspendablePunishmentReserve, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.counterpartyOutboundHtlcMinimumMsat, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.counterpartyOutboundHtlcMaximumMsat, serializer);
    sse_encode_opt_box_autoadd_u_32(
        self.counterpartyForwardingInfoFeeBaseMsat, serializer);
    sse_encode_opt_box_autoadd_u_32(
        self.counterpartyForwardingInfoFeeProportionalMillionths, serializer);
    sse_encode_opt_box_autoadd_u_16(
        self.counterpartyForwardingInfoCltvExpiryDelta, serializer);
    sse_encode_u_64(self.nextOutboundHtlcLimitMsat, serializer);
    sse_encode_u_64(self.nextOutboundHtlcMinimumMsat, serializer);
    sse_encode_opt_box_autoadd_u_16(self.forceCloseSpendDelay, serializer);
    sse_encode_u_64(self.inboundHtlcMinimumMsat, serializer);
    sse_encode_opt_box_autoadd_u_64(self.inboundHtlcMaximumMsat, serializer);
    sse_encode_channel_config(self.config, serializer);
  }

  @protected
  void sse_encode_channel_id(ChannelId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.data, serializer);
  }

  @protected
  void sse_encode_closure_reason(ClosureReason self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ClosureReason_CounterpartyForceClosed(peerMsg: final peerMsg):
        sse_encode_i_32(0, serializer);
        sse_encode_String(peerMsg, serializer);
      case ClosureReason_HolderForceClosed():
        sse_encode_i_32(1, serializer);
      case ClosureReason_LegacyCooperativeClosure():
        sse_encode_i_32(2, serializer);
      case ClosureReason_CounterpartyInitiatedCooperativeClosure():
        sse_encode_i_32(3, serializer);
      case ClosureReason_LocallyInitiatedCooperativeClosure():
        sse_encode_i_32(4, serializer);
      case ClosureReason_CommitmentTxConfirmed():
        sse_encode_i_32(5, serializer);
      case ClosureReason_FundingTimedOut():
        sse_encode_i_32(6, serializer);
      case ClosureReason_ProcessingError(err: final err):
        sse_encode_i_32(7, serializer);
        sse_encode_String(err, serializer);
      case ClosureReason_DisconnectedPeer():
        sse_encode_i_32(8, serializer);
      case ClosureReason_OutdatedChannelManager():
        sse_encode_i_32(9, serializer);
      case ClosureReason_CounterpartyCoopClosedUnfundedChannel():
        sse_encode_i_32(10, serializer);
      case ClosureReason_FundingBatchClosure():
        sse_encode_i_32(11, serializer);
      case ClosureReason_HTLCsTimedOut():
        sse_encode_i_32(12, serializer);
    }
  }

  @protected
  void sse_encode_config(Config self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.storageDirPath, serializer);
    sse_encode_opt_String(self.logDirPath, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_opt_list_socket_address(self.listeningAddresses, serializer);
    sse_encode_u_32(self.defaultCltvExpiryDelta, serializer);
    sse_encode_u_64(self.onchainWalletSyncIntervalSecs, serializer);
    sse_encode_u_64(self.walletSyncIntervalSecs, serializer);
    sse_encode_u_64(self.feeRateCacheUpdateIntervalSecs, serializer);
    sse_encode_list_public_key(self.trustedPeers0Conf, serializer);
    sse_encode_u_64(self.probingLiquidityLimitMultiplier, serializer);
    sse_encode_log_level(self.logLevel, serializer);
  }

  @protected
  void sse_encode_entropy_source_config(
      EntropySourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case EntropySourceConfig_SeedFile(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case EntropySourceConfig_SeedBytes(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_8_array_64(field0, serializer);
      case EntropySourceConfig_Bip39Mnemonic(
          mnemonic: final mnemonic,
          passphrase: final passphrase
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_ldk_mnemonic(mnemonic, serializer);
        sse_encode_opt_String(passphrase, serializer);
    }
  }

  @protected
  void sse_encode_event(Event self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Event_PaymentSuccessful(
          paymentId: final paymentId,
          paymentHash: final paymentHash,
          feePaidMsat: final feePaidMsat
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_box_autoadd_payment_id(paymentId, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
        sse_encode_opt_box_autoadd_u_64(feePaidMsat, serializer);
      case Event_PaymentFailed(
          paymentId: final paymentId,
          paymentHash: final paymentHash,
          reason: final reason
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_opt_box_autoadd_payment_id(paymentId, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
        sse_encode_opt_box_autoadd_payment_failure_reason(reason, serializer);
      case Event_PaymentReceived(
          paymentId: final paymentId,
          paymentHash: final paymentHash,
          amountMsat: final amountMsat
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_opt_box_autoadd_payment_id(paymentId, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
        sse_encode_u_64(amountMsat, serializer);
      case Event_ChannelPending(
          channelId: final channelId,
          userChannelId: final userChannelId,
          formerTemporaryChannelId: final formerTemporaryChannelId,
          counterpartyNodeId: final counterpartyNodeId,
          fundingTxo: final fundingTxo
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_user_channel_id(userChannelId, serializer);
        sse_encode_box_autoadd_channel_id(formerTemporaryChannelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_box_autoadd_out_point(fundingTxo, serializer);
      case Event_ChannelReady(
          channelId: final channelId,
          userChannelId: final userChannelId,
          counterpartyNodeId: final counterpartyNodeId
        ):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_user_channel_id(userChannelId, serializer);
        sse_encode_opt_box_autoadd_public_key(counterpartyNodeId, serializer);
      case Event_ChannelClosed(
          channelId: final channelId,
          userChannelId: final userChannelId,
          counterpartyNodeId: final counterpartyNodeId,
          reason: final reason
        ):
        sse_encode_i_32(5, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_user_channel_id(userChannelId, serializer);
        sse_encode_opt_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_opt_box_autoadd_closure_reason(reason, serializer);
    }
  }

  @protected
  void sse_encode_gossip_source_config(
      GossipSourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case GossipSourceConfig_P2PNetwork():
        sse_encode_i_32(0, serializer);
      case GossipSourceConfig_RapidGossipSync(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_ldk_bolt_11_payment(
      LdkBolt11Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ldk_nodepaymentBolt11Payment(self.ptr, serializer);
  }

  @protected
  void sse_encode_ldk_mnemonic(LdkMnemonic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.seedPhrase, serializer);
  }

  @protected
  void sse_encode_ldk_node(LdkNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_Node(self.ptr, serializer);
  }

  @protected
  void sse_encode_ldk_on_chain_payment(
      LdkOnChainPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ldk_nodepaymentOnchainPayment(self.ptr, serializer);
  }

  @protected
  void sse_encode_ldk_spontaneous_payment(
      LdkSpontaneousPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ldk_nodepaymentSpontaneousPayment(
        self.ptr, serializer);
  }

  @protected
  void sse_encode_lightning_balance(
      LightningBalance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LightningBalance_ClaimableOnChannelClose(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
      case LightningBalance_ClaimableAwaitingConfirmations(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis,
          confirmationHeight: final confirmationHeight
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
        sse_encode_u_32(confirmationHeight, serializer);
      case LightningBalance_ContentiousClaimable(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis,
          timeoutHeight: final timeoutHeight,
          paymentHash: final paymentHash,
          paymentPreimage: final paymentPreimage
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
        sse_encode_u_32(timeoutHeight, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
        sse_encode_box_autoadd_payment_preimage(paymentPreimage, serializer);
      case LightningBalance_MaybeTimeoutClaimableHTLC(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis,
          claimableHeight: final claimableHeight,
          paymentHash: final paymentHash
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
        sse_encode_u_32(claimableHeight, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
      case LightningBalance_MaybePreimageClaimableHTLC(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis,
          expiryHeight: final expiryHeight,
          paymentHash: final paymentHash
        ):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
        sse_encode_u_32(expiryHeight, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
      case LightningBalance_CounterpartyRevokedOutputClaimable(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis
        ):
        sse_encode_i_32(5, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
    }
  }

  @protected
  void sse_encode_liquidity_source_config(
      LiquiditySourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_record_socket_address_public_key_opt_string(
        self.lsps2Service, serializer);
  }

  @protected
  void sse_encode_list_channel_details(
      List<ChannelDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_channel_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_lightning_balance(
      List<LightningBalance> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_lightning_balance(item, serializer);
    }
  }

  @protected
  void sse_encode_list_payment_details(
      List<PaymentDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_payment_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_peer_details(
      List<PeerDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_peer_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_pending_sweep_balance(
      List<PendingSweepBalance> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_pending_sweep_balance(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_public_key(
      List<PublicKey> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_public_key(item, serializer);
    }
  }

  @protected
  void sse_encode_list_socket_address(
      List<SocketAddress> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_socket_address(item, serializer);
    }
  }

  @protected
  void sse_encode_log_level(LogLevel self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_lsp_fee_limits(LSPFeeLimits self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_64(self.maxTotalOpeningFeeMsat, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.maxProportionalOpeningFeePpmMsat, serializer);
  }

  @protected
  void sse_encode_max_dust_htlc_exposure(
      MaxDustHTLCExposure self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case MaxDustHTLCExposure_FixedLimitMsat(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_u_64(field0, serializer);
      case MaxDustHTLCExposure_FeeRateMultiplier(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_64(field0, serializer);
    }
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_node_exception(NodeException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_node_status(NodeStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.isRunning, serializer);
    sse_encode_bool(self.isListening, serializer);
    sse_encode_best_block(self.currentBestBlock, serializer);
    sse_encode_opt_box_autoadd_u_64(self.latestWalletSyncTimestamp, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.latestOnchainWalletSyncTimestamp, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.latestFeeRateCacheUpdateTimestamp, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.latestRgsSnapshotTimestamp, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.latestNodeAnnouncementBroadcastTimestamp, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_chain_data_source_config(
      ChainDataSourceConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_chain_data_source_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_channel_config(
      ChannelConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_channel_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_channel_id(
      ChannelId? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_channel_id(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_closure_reason(
      ClosureReason? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_closure_reason(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_entropy_source_config(
      EntropySourceConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_entropy_source_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_event(Event? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_event(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_gossip_source_config(
      GossipSourceConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_gossip_source_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_liquidity_source_config(
      LiquiditySourceConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_liquidity_source_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_max_dust_htlc_exposure(
      MaxDustHTLCExposure? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_max_dust_htlc_exposure(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_out_point(
      OutPoint? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_out_point(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_details(
      PaymentDetails? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_details(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_failure_reason(
      PaymentFailureReason? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_failure_reason(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_id(
      PaymentId? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_id(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_preimage(
      PaymentPreimage? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_preimage(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_secret(
      PaymentSecret? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_secret(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_public_key(
      PublicKey? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_public_key(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_16(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_16(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_socket_address(
      List<SocketAddress>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_socket_address(self, serializer);
    }
  }

  @protected
  void sse_encode_out_point(OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_txid(self.txid, serializer);
    sse_encode_u_32(self.vout, serializer);
  }

  @protected
  void sse_encode_payment_details(
      PaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_id(self.id, serializer);
    sse_encode_payment_kind(self.kind, serializer);
    sse_encode_opt_box_autoadd_u_64(self.amountMsat, serializer);
    sse_encode_payment_direction(self.direction, serializer);
    sse_encode_payment_status(self.status, serializer);
  }

  @protected
  void sse_encode_payment_direction(
      PaymentDirection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_payment_failure_reason(
      PaymentFailureReason self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_payment_hash(PaymentHash self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.data, serializer);
  }

  @protected
  void sse_encode_payment_id(PaymentId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.field0, serializer);
  }

  @protected
  void sse_encode_payment_kind(PaymentKind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PaymentKind_Onchain():
        sse_encode_i_32(0, serializer);
      case PaymentKind_Bolt11(
          hash: final hash,
          preimage: final preimage,
          secret: final secret
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_payment_hash(hash, serializer);
        sse_encode_opt_box_autoadd_payment_preimage(preimage, serializer);
        sse_encode_opt_box_autoadd_payment_secret(secret, serializer);
      case PaymentKind_Bolt11Jit(
          hash: final hash,
          preimage: final preimage,
          secret: final secret,
          lspFeeLimits: final lspFeeLimits
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_payment_hash(hash, serializer);
        sse_encode_opt_box_autoadd_payment_preimage(preimage, serializer);
        sse_encode_opt_box_autoadd_payment_secret(secret, serializer);
        sse_encode_box_autoadd_lsp_fee_limits(lspFeeLimits, serializer);
      case PaymentKind_Spontaneous(hash: final hash, preimage: final preimage):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_payment_hash(hash, serializer);
        sse_encode_opt_box_autoadd_payment_preimage(preimage, serializer);
    }
  }

  @protected
  void sse_encode_payment_preimage(
      PaymentPreimage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.data, serializer);
  }

  @protected
  void sse_encode_payment_secret(PaymentSecret self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.data, serializer);
  }

  @protected
  void sse_encode_payment_status(PaymentStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_peer_details(PeerDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_public_key(self.nodeId, serializer);
    sse_encode_socket_address(self.address, serializer);
    sse_encode_bool(self.isConnected, serializer);
  }

  @protected
  void sse_encode_pending_sweep_balance(
      PendingSweepBalance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PendingSweepBalance_PendingBroadcast(
          channelId: final channelId,
          amountSatoshis: final amountSatoshis
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_box_autoadd_channel_id(channelId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
      case PendingSweepBalance_BroadcastAwaitingConfirmation(
          channelId: final channelId,
          latestBroadcastHeight: final latestBroadcastHeight,
          latestSpendingTxid: final latestSpendingTxid,
          amountSatoshis: final amountSatoshis
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_opt_box_autoadd_channel_id(channelId, serializer);
        sse_encode_u_32(latestBroadcastHeight, serializer);
        sse_encode_box_autoadd_txid(latestSpendingTxid, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
      case PendingSweepBalance_AwaitingThresholdConfirmations(
          channelId: final channelId,
          latestSpendingTxid: final latestSpendingTxid,
          confirmationHash: final confirmationHash,
          confirmationHeight: final confirmationHeight,
          amountSatoshis: final amountSatoshis
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_opt_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_txid(latestSpendingTxid, serializer);
        sse_encode_String(confirmationHash, serializer);
        sse_encode_u_32(confirmationHeight, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
    }
  }

  @protected
  void sse_encode_public_key(PublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.hex, serializer);
  }

  @protected
  void sse_encode_record_socket_address_public_key_opt_string(
      (SocketAddress, PublicKey, String?) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_socket_address(self.$1, serializer);
    sse_encode_public_key(self.$2, serializer);
    sse_encode_opt_String(self.$3, serializer);
  }

  @protected
  void sse_encode_socket_address(SocketAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SocketAddress_TcpIpV4(addr: final addr, port: final port):
        sse_encode_i_32(0, serializer);
        sse_encode_u_8_array_4(addr, serializer);
        sse_encode_u_16(port, serializer);
      case SocketAddress_TcpIpV6(addr: final addr, port: final port):
        sse_encode_i_32(1, serializer);
        sse_encode_u_8_array_16(addr, serializer);
        sse_encode_u_16(port, serializer);
      case SocketAddress_OnionV2(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_u_8_array_12(field0, serializer);
      case SocketAddress_OnionV3(
          ed25519Pubkey: final ed25519Pubkey,
          checksum: final checksum,
          version: final version,
          port: final port
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_u_8_array_32(ed25519Pubkey, serializer);
        sse_encode_u_16(checksum, serializer);
        sse_encode_u_8(version, serializer);
        sse_encode_u_16(port, serializer);
      case SocketAddress_Hostname(addr: final addr, port: final port):
        sse_encode_i_32(4, serializer);
        sse_encode_String(addr, serializer);
        sse_encode_u_16(port, serializer);
    }
  }

  @protected
  void sse_encode_txid(Txid self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.hash, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_u_8_array_12(U8Array12 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_8_array_16(U8Array16 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_8_array_32(U8Array32 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_8_array_4(U8Array4 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_8_array_64(U8Array64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_user_channel_id(
      UserChannelId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.data, serializer);
  }

  @protected
  void sse_encode_usize(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint64(self);
  }
}
