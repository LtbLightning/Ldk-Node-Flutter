// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/bolt11.dart';
import 'api/bolt12.dart';
import 'api/builder.dart';
import 'api/graph.dart';
import 'api/node.dart';
import 'api/on_chain.dart';
import 'api/spontaneous.dart';
import 'api/types.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'utils/error.dart';

/// Main entrypoint of the Rust API
class core extends BaseEntrypoint<coreApi, coreApiImpl, coreWire> {
  @internal
  static final instance = core._();

  core._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    coreApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<coreApiImpl, coreWire> get apiImplConstructor =>
      coreApiImpl.new;

  @override
  WireConstructor<coreWire> get wireConstructor => coreWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.0.0';

  @override
  int get rustContentHash => 1761952349;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'ldk_node',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class coreApi extends BaseApi {
  Future<void> crateApiBolt11LdkBolt11PaymentClaimForHash(
      {required LdkBolt11Payment that,
      required PaymentHash paymentHash,
      required BigInt claimableAmountMsat,
      required PaymentPreimage preimage});

  Future<void> crateApiBolt11LdkBolt11PaymentFailForHash(
      {required LdkBolt11Payment that, required PaymentHash paymentHash});

  Future<Bolt11Invoice> crateApiBolt11LdkBolt11PaymentReceive(
      {required LdkBolt11Payment that,
      required BigInt amountMsat,
      required String description,
      required int expirySecs});

  Future<Bolt11Invoice> crateApiBolt11LdkBolt11PaymentReceiveForHash(
      {required LdkBolt11Payment that,
      required PaymentHash paymentHash,
      required BigInt amountMsat,
      required String description,
      required int expirySecs});

  Future<Bolt11Invoice> crateApiBolt11LdkBolt11PaymentReceiveVariableAmount(
      {required LdkBolt11Payment that,
      required String description,
      required int expirySecs});

  Future<Bolt11Invoice>
      crateApiBolt11LdkBolt11PaymentReceiveVariableAmountForHash(
          {required LdkBolt11Payment that,
          required String description,
          required int expirySecs,
          required PaymentHash paymentHash});

  Future<Bolt11Invoice>
      crateApiBolt11LdkBolt11PaymentReceiveVariableAmountViaJitChannel(
          {required LdkBolt11Payment that,
          required String description,
          required int expirySecs,
          BigInt? maxProportionalLspFeeLimitPpmMsat});

  Future<Bolt11Invoice> crateApiBolt11LdkBolt11PaymentReceiveViaJitChannel(
      {required LdkBolt11Payment that,
      required BigInt amountMsat,
      required String description,
      required int expirySecs,
      BigInt? maxTotalLspFeeLimitMsat});

  Future<PaymentId> crateApiBolt11LdkBolt11PaymentSend(
      {required LdkBolt11Payment that, required Bolt11Invoice invoice});

  Future<void> crateApiBolt11LdkBolt11PaymentSendProbes(
      {required LdkBolt11Payment that, required Bolt11Invoice invoice});

  Future<void> crateApiBolt11LdkBolt11PaymentSendProbesUsingAmount(
      {required LdkBolt11Payment that,
      required Bolt11Invoice invoice,
      required BigInt amountMsat});

  Future<PaymentId> crateApiBolt11LdkBolt11PaymentSendUsingAmount(
      {required LdkBolt11Payment that,
      required Bolt11Invoice invoice,
      required BigInt amountMsat});

  Future<Refund> crateApiBolt12LdkBolt12PaymentInitiateRefund(
      {required LdkBolt12Payment that,
      required BigInt amountMsat,
      required int expirySecs});

  Future<Offer> crateApiBolt12LdkBolt12PaymentReceive(
      {required LdkBolt12Payment that,
      required BigInt amountMsat,
      required String description});

  Future<Offer> crateApiBolt12LdkBolt12PaymentReceiveVariableAmount(
      {required LdkBolt12Payment that, required String description});

  Future<Bolt12Invoice> crateApiBolt12LdkBolt12PaymentRequestRefundPayment(
      {required LdkBolt12Payment that, required Refund refund});

  Future<PaymentId> crateApiBolt12LdkBolt12PaymentSend(
      {required LdkBolt12Payment that,
      required Offer offer,
      String? payerNote});

  Future<PaymentId> crateApiBolt12LdkBolt12PaymentSendUsingAmount(
      {required LdkBolt12Payment that,
      required Offer offer,
      String? payerNote,
      required BigInt amountMsat});

  Builder crateApiBuilderNodeBuilderAutoAccessorGetBuilder(
      {required NodeBuilder that});

  void crateApiBuilderNodeBuilderAutoAccessorSetBuilder(
      {required NodeBuilder that, required Builder builder});

  Future<LdkNode> crateApiBuilderNodeBuilderBuild({required NodeBuilder that});

  Future<LdkNode> crateApiBuilderNodeBuilderBuildWithFsStore(
      {required NodeBuilder that});

  Future<NodeBuilder> crateApiBuilderNodeBuilderCreateBuilder(
      {required Config config,
      ChainDataSourceConfig? chainDataSourceConfig,
      EntropySourceConfig? entropySourceConfig,
      GossipSourceConfig? gossipSourceConfig,
      LiquiditySourceConfig? liquiditySourceConfig});

  Future<LdkMnemonic> crateApiBuilderLdkMnemonicGenerate();

  Future<ChannelInfo?> crateApiGraphLdkNetworkGraphChannel(
      {required LdkNetworkGraph that, required BigInt shortChannelId});

  Future<Uint64List> crateApiGraphLdkNetworkGraphListChannels(
      {required LdkNetworkGraph that});

  Future<List<NodeId>> crateApiGraphLdkNetworkGraphListNodes(
      {required LdkNetworkGraph that});

  Future<NodeInfo?> crateApiGraphLdkNetworkGraphNode(
      {required LdkNetworkGraph that, required NodeId nodeId});

  Future<LdkBolt11Payment> crateApiNodeLdkNodeBolt11Payment(
      {required LdkNode ptr});

  Future<LdkBolt12Payment> crateApiNodeLdkNodeBolt12Payment(
      {required LdkNode ptr});

  Future<void> crateApiNodeLdkNodeCloseChannel(
      {required LdkNode that,
      required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId});

  Future<Config> crateApiNodeLdkNodeConfig({required LdkNode that});

  Future<void> crateApiNodeLdkNodeConnect(
      {required LdkNode that,
      required PublicKey nodeId,
      required SocketAddress address,
      required bool persist});

  Future<UserChannelId> crateApiNodeLdkNodeConnectOpenChannel(
      {required LdkNode that,
      required SocketAddress socketAddress,
      required PublicKey nodeId,
      required BigInt channelAmountSats,
      BigInt? pushToCounterpartyMsat,
      required bool announceChannel,
      ChannelConfig? channelConfig});

  Future<void> crateApiNodeLdkNodeDisconnect(
      {required LdkNode that, required PublicKey counterpartyNodeId});

  Future<void> crateApiNodeLdkNodeEventHandled({required LdkNode that});

  Future<void> crateApiNodeLdkNodeForceCloseChannel(
      {required LdkNode that,
      required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId});

  Future<BalanceDetails> crateApiNodeLdkNodeListBalances(
      {required LdkNode that});

  Future<List<ChannelDetails>> crateApiNodeLdkNodeListChannels(
      {required LdkNode that});

  Future<List<PaymentDetails>> crateApiNodeLdkNodeListPayments(
      {required LdkNode that});

  Future<List<PaymentDetails>> crateApiNodeLdkNodeListPaymentsWithFilter(
      {required LdkNode that, required PaymentDirection paymentDirection});

  Future<List<PeerDetails>> crateApiNodeLdkNodeListPeers(
      {required LdkNode that});

  Future<List<SocketAddress>?> crateApiNodeLdkNodeListeningAddresses(
      {required LdkNode that});

  Future<LdkNetworkGraph> crateApiNodeLdkNodeNetworkGraph(
      {required LdkNode ptr});

  Future<Event?> crateApiNodeLdkNodeNextEvent({required LdkNode that});

  Future<Event> crateApiNodeLdkNodeNextEventAsync({required LdkNode that});

  Future<PublicKey> crateApiNodeLdkNodeNodeId({required LdkNode that});

  Future<LdkOnChainPayment> crateApiNodeLdkNodeOnChainPayment(
      {required LdkNode ptr});

  Future<PaymentDetails?> crateApiNodeLdkNodePayment(
      {required LdkNode that, required PaymentId paymentId});

  Future<void> crateApiNodeLdkNodeRemovePayment(
      {required LdkNode that, required PaymentId paymentId});

  Future<String> crateApiNodeLdkNodeSignMessage(
      {required LdkNode that, required List<int> msg});

  Future<LdkSpontaneousPayment> crateApiNodeLdkNodeSpontaneousPayment(
      {required LdkNode ptr});

  Future<void> crateApiNodeLdkNodeStart({required LdkNode that});

  Future<NodeStatus> crateApiNodeLdkNodeStatus({required LdkNode that});

  Future<void> crateApiNodeLdkNodeStop({required LdkNode that});

  Future<void> crateApiNodeLdkNodeSyncWallets({required LdkNode that});

  Future<void> crateApiNodeLdkNodeUpdateChannelConfig(
      {required LdkNode that,
      required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId,
      required ChannelConfig channelConfig});

  Future<bool> crateApiNodeLdkNodeVerifySignature(
      {required LdkNode that,
      required List<int> msg,
      required String sig,
      required PublicKey publicKey});

  Future<Event> crateApiNodeLdkNodeWaitNextEvent({required LdkNode that});

  Future<Address> crateApiOnChainLdkOnChainPaymentNewAddress(
      {required LdkOnChainPayment that});

  Future<Txid> crateApiOnChainLdkOnChainPaymentSendAllToAddress(
      {required LdkOnChainPayment that, required Address address});

  Future<Txid> crateApiOnChainLdkOnChainPaymentSendToAddress(
      {required LdkOnChainPayment that,
      required Address address,
      required BigInt amountSats});

  Future<PaymentId> crateApiSpontaneousLdkSpontaneousPaymentSend(
      {required LdkSpontaneousPayment that,
      required BigInt amountMsat,
      required PublicKey nodeId});

  Future<void> crateApiSpontaneousLdkSpontaneousPaymentSendProbes(
      {required LdkSpontaneousPayment that,
      required BigInt amountMsat,
      required PublicKey nodeId});

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcBolt12Payment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcBolt12Payment;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ArcBolt12PaymentPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Node;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Node;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_NodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_NodeBuilder;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_NodeBuilder;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_NodeBuilderPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Builder;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Builder;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_BuilderPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_NetworkGraph;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_NetworkGraph;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_NetworkGraphPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Bolt11Payment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Bolt11Payment;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_Bolt11PaymentPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_OnchainPayment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_OnchainPayment;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_OnchainPaymentPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SpontaneousPayment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SpontaneousPayment;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_SpontaneousPaymentPtr;
}

class coreApiImpl extends coreApiImplPlatform implements coreApi {
  coreApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiBolt11LdkBolt11PaymentClaimForHash(
      {required LdkBolt11Payment that,
      required PaymentHash paymentHash,
      required BigInt claimableAmountMsat,
      required PaymentPreimage preimage}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_payment_hash(paymentHash);
        var arg2 = cst_encode_u_64(claimableAmountMsat);
        var arg3 = cst_encode_box_autoadd_payment_preimage(preimage);
        return wire
            .wire__crate__api__bolt11__ldk_bolt_11_payment_claim_for_hash(
                port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiBolt11LdkBolt11PaymentClaimForHashConstMeta,
      argValues: [that, paymentHash, claimableAmountMsat, preimage],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt11LdkBolt11PaymentClaimForHashConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_bolt_11_payment_claim_for_hash",
        argNames: ["that", "paymentHash", "claimableAmountMsat", "preimage"],
      );

  @override
  Future<void> crateApiBolt11LdkBolt11PaymentFailForHash(
      {required LdkBolt11Payment that, required PaymentHash paymentHash}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_payment_hash(paymentHash);
        return wire.wire__crate__api__bolt11__ldk_bolt_11_payment_fail_for_hash(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiBolt11LdkBolt11PaymentFailForHashConstMeta,
      argValues: [that, paymentHash],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt11LdkBolt11PaymentFailForHashConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_bolt_11_payment_fail_for_hash",
        argNames: ["that", "paymentHash"],
      );

  @override
  Future<Bolt11Invoice> crateApiBolt11LdkBolt11PaymentReceive(
      {required LdkBolt11Payment that,
      required BigInt amountMsat,
      required String description,
      required int expirySecs}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_String(description);
        var arg3 = cst_encode_u_32(expirySecs);
        return wire.wire__crate__api__bolt11__ldk_bolt_11_payment_receive(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiBolt11LdkBolt11PaymentReceiveConstMeta,
      argValues: [that, amountMsat, description, expirySecs],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt11LdkBolt11PaymentReceiveConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_bolt_11_payment_receive",
        argNames: ["that", "amountMsat", "description", "expirySecs"],
      );

  @override
  Future<Bolt11Invoice> crateApiBolt11LdkBolt11PaymentReceiveForHash(
      {required LdkBolt11Payment that,
      required PaymentHash paymentHash,
      required BigInt amountMsat,
      required String description,
      required int expirySecs}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_payment_hash(paymentHash);
        var arg2 = cst_encode_u_64(amountMsat);
        var arg3 = cst_encode_String(description);
        var arg4 = cst_encode_u_32(expirySecs);
        return wire
            .wire__crate__api__bolt11__ldk_bolt_11_payment_receive_for_hash(
                port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiBolt11LdkBolt11PaymentReceiveForHashConstMeta,
      argValues: [that, paymentHash, amountMsat, description, expirySecs],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt11LdkBolt11PaymentReceiveForHashConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_bolt_11_payment_receive_for_hash",
        argNames: [
          "that",
          "paymentHash",
          "amountMsat",
          "description",
          "expirySecs"
        ],
      );

  @override
  Future<Bolt11Invoice> crateApiBolt11LdkBolt11PaymentReceiveVariableAmount(
      {required LdkBolt11Payment that,
      required String description,
      required int expirySecs}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_String(description);
        var arg2 = cst_encode_u_32(expirySecs);
        return wire
            .wire__crate__api__bolt11__ldk_bolt_11_payment_receive_variable_amount(
                port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiBolt11LdkBolt11PaymentReceiveVariableAmountConstMeta,
      argValues: [that, description, expirySecs],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBolt11LdkBolt11PaymentReceiveVariableAmountConstMeta =>
          const TaskConstMeta(
            debugName: "ldk_bolt_11_payment_receive_variable_amount",
            argNames: ["that", "description", "expirySecs"],
          );

  @override
  Future<Bolt11Invoice>
      crateApiBolt11LdkBolt11PaymentReceiveVariableAmountForHash(
          {required LdkBolt11Payment that,
          required String description,
          required int expirySecs,
          required PaymentHash paymentHash}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_String(description);
        var arg2 = cst_encode_u_32(expirySecs);
        var arg3 = cst_encode_box_autoadd_payment_hash(paymentHash);
        return wire
            .wire__crate__api__bolt11__ldk_bolt_11_payment_receive_variable_amount_for_hash(
                port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta:
          kCrateApiBolt11LdkBolt11PaymentReceiveVariableAmountForHashConstMeta,
      argValues: [that, description, expirySecs, paymentHash],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBolt11LdkBolt11PaymentReceiveVariableAmountForHashConstMeta =>
          const TaskConstMeta(
            debugName: "ldk_bolt_11_payment_receive_variable_amount_for_hash",
            argNames: ["that", "description", "expirySecs", "paymentHash"],
          );

  @override
  Future<Bolt11Invoice>
      crateApiBolt11LdkBolt11PaymentReceiveVariableAmountViaJitChannel(
          {required LdkBolt11Payment that,
          required String description,
          required int expirySecs,
          BigInt? maxProportionalLspFeeLimitPpmMsat}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_String(description);
        var arg2 = cst_encode_u_32(expirySecs);
        var arg3 =
            cst_encode_opt_box_autoadd_u_64(maxProportionalLspFeeLimitPpmMsat);
        return wire
            .wire__crate__api__bolt11__ldk_bolt_11_payment_receive_variable_amount_via_jit_channel(
                port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta:
          kCrateApiBolt11LdkBolt11PaymentReceiveVariableAmountViaJitChannelConstMeta,
      argValues: [
        that,
        description,
        expirySecs,
        maxProportionalLspFeeLimitPpmMsat
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBolt11LdkBolt11PaymentReceiveVariableAmountViaJitChannelConstMeta =>
          const TaskConstMeta(
            debugName:
                "ldk_bolt_11_payment_receive_variable_amount_via_jit_channel",
            argNames: [
              "that",
              "description",
              "expirySecs",
              "maxProportionalLspFeeLimitPpmMsat"
            ],
          );

  @override
  Future<Bolt11Invoice> crateApiBolt11LdkBolt11PaymentReceiveViaJitChannel(
      {required LdkBolt11Payment that,
      required BigInt amountMsat,
      required String description,
      required int expirySecs,
      BigInt? maxTotalLspFeeLimitMsat}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_String(description);
        var arg3 = cst_encode_u_32(expirySecs);
        var arg4 = cst_encode_opt_box_autoadd_u_64(maxTotalLspFeeLimitMsat);
        return wire
            .wire__crate__api__bolt11__ldk_bolt_11_payment_receive_via_jit_channel(
                port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiBolt11LdkBolt11PaymentReceiveViaJitChannelConstMeta,
      argValues: [
        that,
        amountMsat,
        description,
        expirySecs,
        maxTotalLspFeeLimitMsat
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBolt11LdkBolt11PaymentReceiveViaJitChannelConstMeta =>
          const TaskConstMeta(
            debugName: "ldk_bolt_11_payment_receive_via_jit_channel",
            argNames: [
              "that",
              "amountMsat",
              "description",
              "expirySecs",
              "maxTotalLspFeeLimitMsat"
            ],
          );

  @override
  Future<PaymentId> crateApiBolt11LdkBolt11PaymentSend(
      {required LdkBolt11Payment that, required Bolt11Invoice invoice}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_bolt_11_invoice(invoice);
        return wire.wire__crate__api__bolt11__ldk_bolt_11_payment_send(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payment_id,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiBolt11LdkBolt11PaymentSendConstMeta,
      argValues: [that, invoice],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt11LdkBolt11PaymentSendConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_bolt_11_payment_send",
        argNames: ["that", "invoice"],
      );

  @override
  Future<void> crateApiBolt11LdkBolt11PaymentSendProbes(
      {required LdkBolt11Payment that, required Bolt11Invoice invoice}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_bolt_11_invoice(invoice);
        return wire.wire__crate__api__bolt11__ldk_bolt_11_payment_send_probes(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiBolt11LdkBolt11PaymentSendProbesConstMeta,
      argValues: [that, invoice],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt11LdkBolt11PaymentSendProbesConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_bolt_11_payment_send_probes",
        argNames: ["that", "invoice"],
      );

  @override
  Future<void> crateApiBolt11LdkBolt11PaymentSendProbesUsingAmount(
      {required LdkBolt11Payment that,
      required Bolt11Invoice invoice,
      required BigInt amountMsat}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_bolt_11_invoice(invoice);
        var arg2 = cst_encode_u_64(amountMsat);
        return wire
            .wire__crate__api__bolt11__ldk_bolt_11_payment_send_probes_using_amount(
                port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiBolt11LdkBolt11PaymentSendProbesUsingAmountConstMeta,
      argValues: [that, invoice, amountMsat],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBolt11LdkBolt11PaymentSendProbesUsingAmountConstMeta =>
          const TaskConstMeta(
            debugName: "ldk_bolt_11_payment_send_probes_using_amount",
            argNames: ["that", "invoice", "amountMsat"],
          );

  @override
  Future<PaymentId> crateApiBolt11LdkBolt11PaymentSendUsingAmount(
      {required LdkBolt11Payment that,
      required Bolt11Invoice invoice,
      required BigInt amountMsat}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_bolt_11_invoice(invoice);
        var arg2 = cst_encode_u_64(amountMsat);
        return wire
            .wire__crate__api__bolt11__ldk_bolt_11_payment_send_using_amount(
                port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payment_id,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiBolt11LdkBolt11PaymentSendUsingAmountConstMeta,
      argValues: [that, invoice, amountMsat],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt11LdkBolt11PaymentSendUsingAmountConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_bolt_11_payment_send_using_amount",
        argNames: ["that", "invoice", "amountMsat"],
      );

  @override
  Future<Refund> crateApiBolt12LdkBolt12PaymentInitiateRefund(
      {required LdkBolt12Payment that,
      required BigInt amountMsat,
      required int expirySecs}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_12_payment(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_u_32(expirySecs);
        return wire
            .wire__crate__api__bolt12__ldk_bolt_12_payment_initiate_refund(
                port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_refund,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiBolt12LdkBolt12PaymentInitiateRefundConstMeta,
      argValues: [that, amountMsat, expirySecs],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt12LdkBolt12PaymentInitiateRefundConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_bolt_12_payment_initiate_refund",
        argNames: ["that", "amountMsat", "expirySecs"],
      );

  @override
  Future<Offer> crateApiBolt12LdkBolt12PaymentReceive(
      {required LdkBolt12Payment that,
      required BigInt amountMsat,
      required String description}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_12_payment(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_String(description);
        return wire.wire__crate__api__bolt12__ldk_bolt_12_payment_receive(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_offer,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiBolt12LdkBolt12PaymentReceiveConstMeta,
      argValues: [that, amountMsat, description],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt12LdkBolt12PaymentReceiveConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_bolt_12_payment_receive",
        argNames: ["that", "amountMsat", "description"],
      );

  @override
  Future<Offer> crateApiBolt12LdkBolt12PaymentReceiveVariableAmount(
      {required LdkBolt12Payment that, required String description}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_12_payment(that);
        var arg1 = cst_encode_String(description);
        return wire
            .wire__crate__api__bolt12__ldk_bolt_12_payment_receive_variable_amount(
                port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_offer,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiBolt12LdkBolt12PaymentReceiveVariableAmountConstMeta,
      argValues: [that, description],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBolt12LdkBolt12PaymentReceiveVariableAmountConstMeta =>
          const TaskConstMeta(
            debugName: "ldk_bolt_12_payment_receive_variable_amount",
            argNames: ["that", "description"],
          );

  @override
  Future<Bolt12Invoice> crateApiBolt12LdkBolt12PaymentRequestRefundPayment(
      {required LdkBolt12Payment that, required Refund refund}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_12_payment(that);
        var arg1 = cst_encode_box_autoadd_refund(refund);
        return wire
            .wire__crate__api__bolt12__ldk_bolt_12_payment_request_refund_payment(
                port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_12_invoice,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiBolt12LdkBolt12PaymentRequestRefundPaymentConstMeta,
      argValues: [that, refund],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBolt12LdkBolt12PaymentRequestRefundPaymentConstMeta =>
          const TaskConstMeta(
            debugName: "ldk_bolt_12_payment_request_refund_payment",
            argNames: ["that", "refund"],
          );

  @override
  Future<PaymentId> crateApiBolt12LdkBolt12PaymentSend(
      {required LdkBolt12Payment that,
      required Offer offer,
      String? payerNote}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_12_payment(that);
        var arg1 = cst_encode_box_autoadd_offer(offer);
        var arg2 = cst_encode_opt_String(payerNote);
        return wire.wire__crate__api__bolt12__ldk_bolt_12_payment_send(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payment_id,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiBolt12LdkBolt12PaymentSendConstMeta,
      argValues: [that, offer, payerNote],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt12LdkBolt12PaymentSendConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_bolt_12_payment_send",
        argNames: ["that", "offer", "payerNote"],
      );

  @override
  Future<PaymentId> crateApiBolt12LdkBolt12PaymentSendUsingAmount(
      {required LdkBolt12Payment that,
      required Offer offer,
      String? payerNote,
      required BigInt amountMsat}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_bolt_12_payment(that);
        var arg1 = cst_encode_box_autoadd_offer(offer);
        var arg2 = cst_encode_opt_String(payerNote);
        var arg3 = cst_encode_u_64(amountMsat);
        return wire
            .wire__crate__api__bolt12__ldk_bolt_12_payment_send_using_amount(
                port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payment_id,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiBolt12LdkBolt12PaymentSendUsingAmountConstMeta,
      argValues: [that, offer, payerNote, amountMsat],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt12LdkBolt12PaymentSendUsingAmountConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_bolt_12_payment_send_using_amount",
        argNames: ["that", "offer", "payerNote", "amountMsat"],
      );

  @override
  Builder crateApiBuilderNodeBuilderAutoAccessorGetBuilder(
      {required NodeBuilder that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
                that);
        return wire
            .wire__crate__api__builder__NodeBuilder_auto_accessor_get_builder(
                arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_RustOpaque_ldk_nodeBuilder,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBuilderNodeBuilderAutoAccessorGetBuilderConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBuilderNodeBuilderAutoAccessorGetBuilderConstMeta =>
          const TaskConstMeta(
            debugName: "NodeBuilder_auto_accessor_get_builder",
            argNames: ["that"],
          );

  @override
  void crateApiBuilderNodeBuilderAutoAccessorSetBuilder(
      {required NodeBuilder that, required Builder builder}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
                that);
        var arg1 = cst_encode_RustOpaque_ldk_nodeBuilder(builder);
        return wire
            .wire__crate__api__builder__NodeBuilder_auto_accessor_set_builder(
                arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBuilderNodeBuilderAutoAccessorSetBuilderConstMeta,
      argValues: [that, builder],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBuilderNodeBuilderAutoAccessorSetBuilderConstMeta =>
          const TaskConstMeta(
            debugName: "NodeBuilder_auto_accessor_set_builder",
            argNames: ["that", "builder"],
          );

  @override
  Future<LdkNode> crateApiBuilderNodeBuilderBuild({required NodeBuilder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
                that);
        return wire.wire__crate__api__builder__NodeBuilder_build(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ldk_node,
        decodeErrorData: dco_decode_ldk_builder_error,
      ),
      constMeta: kCrateApiBuilderNodeBuilderBuildConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBuilderNodeBuilderBuildConstMeta =>
      const TaskConstMeta(
        debugName: "NodeBuilder_build",
        argNames: ["that"],
      );

  @override
  Future<LdkNode> crateApiBuilderNodeBuilderBuildWithFsStore(
      {required NodeBuilder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
                that);
        return wire.wire__crate__api__builder__NodeBuilder_build_with_fs_store(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ldk_node,
        decodeErrorData: dco_decode_ldk_builder_error,
      ),
      constMeta: kCrateApiBuilderNodeBuilderBuildWithFsStoreConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBuilderNodeBuilderBuildWithFsStoreConstMeta =>
      const TaskConstMeta(
        debugName: "NodeBuilder_build_with_fs_store",
        argNames: ["that"],
      );

  @override
  Future<NodeBuilder> crateApiBuilderNodeBuilderCreateBuilder(
      {required Config config,
      ChainDataSourceConfig? chainDataSourceConfig,
      EntropySourceConfig? entropySourceConfig,
      GossipSourceConfig? gossipSourceConfig,
      LiquiditySourceConfig? liquiditySourceConfig}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_config(config);
        var arg1 = cst_encode_opt_box_autoadd_chain_data_source_config(
            chainDataSourceConfig);
        var arg2 = cst_encode_opt_box_autoadd_entropy_source_config(
            entropySourceConfig);
        var arg3 =
            cst_encode_opt_box_autoadd_gossip_source_config(gossipSourceConfig);
        var arg4 = cst_encode_opt_box_autoadd_liquidity_source_config(
            liquiditySourceConfig);
        return wire.wire__crate__api__builder__NodeBuilder_create_builder(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder,
        decodeErrorData: dco_decode_ldk_builder_error,
      ),
      constMeta: kCrateApiBuilderNodeBuilderCreateBuilderConstMeta,
      argValues: [
        config,
        chainDataSourceConfig,
        entropySourceConfig,
        gossipSourceConfig,
        liquiditySourceConfig
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBuilderNodeBuilderCreateBuilderConstMeta =>
      const TaskConstMeta(
        debugName: "NodeBuilder_create_builder",
        argNames: [
          "config",
          "chainDataSourceConfig",
          "entropySourceConfig",
          "gossipSourceConfig",
          "liquiditySourceConfig"
        ],
      );

  @override
  Future<LdkMnemonic> crateApiBuilderLdkMnemonicGenerate() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__builder__ldk_mnemonic_generate(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ldk_mnemonic,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBuilderLdkMnemonicGenerateConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBuilderLdkMnemonicGenerateConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_mnemonic_generate",
        argNames: [],
      );

  @override
  Future<ChannelInfo?> crateApiGraphLdkNetworkGraphChannel(
      {required LdkNetworkGraph that, required BigInt shortChannelId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_network_graph(that);
        var arg1 = cst_encode_u_64(shortChannelId);
        return wire.wire__crate__api__graph__ldk_network_graph_channel(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_channel_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGraphLdkNetworkGraphChannelConstMeta,
      argValues: [that, shortChannelId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGraphLdkNetworkGraphChannelConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_network_graph_channel",
        argNames: ["that", "shortChannelId"],
      );

  @override
  Future<Uint64List> crateApiGraphLdkNetworkGraphListChannels(
      {required LdkNetworkGraph that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_network_graph(that);
        return wire.wire__crate__api__graph__ldk_network_graph_list_channels(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_64_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGraphLdkNetworkGraphListChannelsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGraphLdkNetworkGraphListChannelsConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_network_graph_list_channels",
        argNames: ["that"],
      );

  @override
  Future<List<NodeId>> crateApiGraphLdkNetworkGraphListNodes(
      {required LdkNetworkGraph that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_network_graph(that);
        return wire.wire__crate__api__graph__ldk_network_graph_list_nodes(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_node_id,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGraphLdkNetworkGraphListNodesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGraphLdkNetworkGraphListNodesConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_network_graph_list_nodes",
        argNames: ["that"],
      );

  @override
  Future<NodeInfo?> crateApiGraphLdkNetworkGraphNode(
      {required LdkNetworkGraph that, required NodeId nodeId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_network_graph(that);
        var arg1 = cst_encode_box_autoadd_node_id(nodeId);
        return wire.wire__crate__api__graph__ldk_network_graph_node(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_node_info,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiGraphLdkNetworkGraphNodeConstMeta,
      argValues: [that, nodeId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGraphLdkNetworkGraphNodeConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_network_graph_node",
        argNames: ["that", "nodeId"],
      );

  @override
  Future<LdkBolt11Payment> crateApiNodeLdkNodeBolt11Payment(
      {required LdkNode ptr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(ptr);
        return wire.wire__crate__api__node__ldk_node_bolt11_payment(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ldk_bolt_11_payment,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeBolt11PaymentConstMeta,
      argValues: [ptr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeBolt11PaymentConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_bolt11_payment",
        argNames: ["ptr"],
      );

  @override
  Future<LdkBolt12Payment> crateApiNodeLdkNodeBolt12Payment(
      {required LdkNode ptr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(ptr);
        return wire.wire__crate__api__node__ldk_node_bolt12_payment(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ldk_bolt_12_payment,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeBolt12PaymentConstMeta,
      argValues: [ptr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeBolt12PaymentConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_bolt12_payment",
        argNames: ["ptr"],
      );

  @override
  Future<void> crateApiNodeLdkNodeCloseChannel(
      {required LdkNode that,
      required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_box_autoadd_user_channel_id(userChannelId);
        var arg2 = cst_encode_box_autoadd_public_key(counterpartyNodeId);
        return wire.wire__crate__api__node__ldk_node_close_channel(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiNodeLdkNodeCloseChannelConstMeta,
      argValues: [that, userChannelId, counterpartyNodeId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeCloseChannelConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_close_channel",
        argNames: ["that", "userChannelId", "counterpartyNodeId"],
      );

  @override
  Future<Config> crateApiNodeLdkNodeConfig({required LdkNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire__crate__api__node__ldk_node_config(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_config,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeConfigConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeConfigConstMeta => const TaskConstMeta(
        debugName: "ldk_node_config",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiNodeLdkNodeConnect(
      {required LdkNode that,
      required PublicKey nodeId,
      required SocketAddress address,
      required bool persist}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_box_autoadd_public_key(nodeId);
        var arg2 = cst_encode_box_autoadd_socket_address(address);
        var arg3 = cst_encode_bool(persist);
        return wire.wire__crate__api__node__ldk_node_connect(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiNodeLdkNodeConnectConstMeta,
      argValues: [that, nodeId, address, persist],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeConnectConstMeta => const TaskConstMeta(
        debugName: "ldk_node_connect",
        argNames: ["that", "nodeId", "address", "persist"],
      );

  @override
  Future<UserChannelId> crateApiNodeLdkNodeConnectOpenChannel(
      {required LdkNode that,
      required SocketAddress socketAddress,
      required PublicKey nodeId,
      required BigInt channelAmountSats,
      BigInt? pushToCounterpartyMsat,
      required bool announceChannel,
      ChannelConfig? channelConfig}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_box_autoadd_socket_address(socketAddress);
        var arg2 = cst_encode_box_autoadd_public_key(nodeId);
        var arg3 = cst_encode_u_64(channelAmountSats);
        var arg4 = cst_encode_opt_box_autoadd_u_64(pushToCounterpartyMsat);
        var arg5 = cst_encode_bool(announceChannel);
        var arg6 = cst_encode_opt_box_autoadd_channel_config(channelConfig);
        return wire.wire__crate__api__node__ldk_node_connect_open_channel(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_user_channel_id,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiNodeLdkNodeConnectOpenChannelConstMeta,
      argValues: [
        that,
        socketAddress,
        nodeId,
        channelAmountSats,
        pushToCounterpartyMsat,
        announceChannel,
        channelConfig
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeConnectOpenChannelConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_connect_open_channel",
        argNames: [
          "that",
          "socketAddress",
          "nodeId",
          "channelAmountSats",
          "pushToCounterpartyMsat",
          "announceChannel",
          "channelConfig"
        ],
      );

  @override
  Future<void> crateApiNodeLdkNodeDisconnect(
      {required LdkNode that, required PublicKey counterpartyNodeId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_box_autoadd_public_key(counterpartyNodeId);
        return wire.wire__crate__api__node__ldk_node_disconnect(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiNodeLdkNodeDisconnectConstMeta,
      argValues: [that, counterpartyNodeId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeDisconnectConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_disconnect",
        argNames: ["that", "counterpartyNodeId"],
      );

  @override
  Future<void> crateApiNodeLdkNodeEventHandled({required LdkNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire__crate__api__node__ldk_node_event_handled(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeEventHandledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeEventHandledConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_event_handled",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiNodeLdkNodeForceCloseChannel(
      {required LdkNode that,
      required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_box_autoadd_user_channel_id(userChannelId);
        var arg2 = cst_encode_box_autoadd_public_key(counterpartyNodeId);
        return wire.wire__crate__api__node__ldk_node_force_close_channel(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiNodeLdkNodeForceCloseChannelConstMeta,
      argValues: [that, userChannelId, counterpartyNodeId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeForceCloseChannelConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_force_close_channel",
        argNames: ["that", "userChannelId", "counterpartyNodeId"],
      );

  @override
  Future<BalanceDetails> crateApiNodeLdkNodeListBalances(
      {required LdkNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire__crate__api__node__ldk_node_list_balances(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_balance_details,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiNodeLdkNodeListBalancesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeListBalancesConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_list_balances",
        argNames: ["that"],
      );

  @override
  Future<List<ChannelDetails>> crateApiNodeLdkNodeListChannels(
      {required LdkNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire__crate__api__node__ldk_node_list_channels(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_channel_details,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeListChannelsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeListChannelsConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_list_channels",
        argNames: ["that"],
      );

  @override
  Future<List<PaymentDetails>> crateApiNodeLdkNodeListPayments(
      {required LdkNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire__crate__api__node__ldk_node_list_payments(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_payment_details,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeListPaymentsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeListPaymentsConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_list_payments",
        argNames: ["that"],
      );

  @override
  Future<List<PaymentDetails>> crateApiNodeLdkNodeListPaymentsWithFilter(
      {required LdkNode that, required PaymentDirection paymentDirection}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_payment_direction(paymentDirection);
        return wire.wire__crate__api__node__ldk_node_list_payments_with_filter(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_payment_details,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeListPaymentsWithFilterConstMeta,
      argValues: [that, paymentDirection],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeListPaymentsWithFilterConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_list_payments_with_filter",
        argNames: ["that", "paymentDirection"],
      );

  @override
  Future<List<PeerDetails>> crateApiNodeLdkNodeListPeers(
      {required LdkNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire__crate__api__node__ldk_node_list_peers(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_peer_details,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeListPeersConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeListPeersConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_list_peers",
        argNames: ["that"],
      );

  @override
  Future<List<SocketAddress>?> crateApiNodeLdkNodeListeningAddresses(
      {required LdkNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire__crate__api__node__ldk_node_listening_addresses(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_list_socket_address,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeListeningAddressesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeListeningAddressesConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_listening_addresses",
        argNames: ["that"],
      );

  @override
  Future<LdkNetworkGraph> crateApiNodeLdkNodeNetworkGraph(
      {required LdkNode ptr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(ptr);
        return wire.wire__crate__api__node__ldk_node_network_graph(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ldk_network_graph,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeNetworkGraphConstMeta,
      argValues: [ptr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeNetworkGraphConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_network_graph",
        argNames: ["ptr"],
      );

  @override
  Future<Event?> crateApiNodeLdkNodeNextEvent({required LdkNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire__crate__api__node__ldk_node_next_event(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_event,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeNextEventConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeNextEventConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_next_event",
        argNames: ["that"],
      );

  @override
  Future<Event> crateApiNodeLdkNodeNextEventAsync({required LdkNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire__crate__api__node__ldk_node_next_event_async(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_event,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeNextEventAsyncConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeNextEventAsyncConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_next_event_async",
        argNames: ["that"],
      );

  @override
  Future<PublicKey> crateApiNodeLdkNodeNodeId({required LdkNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire__crate__api__node__ldk_node_node_id(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_public_key,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeNodeIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeNodeIdConstMeta => const TaskConstMeta(
        debugName: "ldk_node_node_id",
        argNames: ["that"],
      );

  @override
  Future<LdkOnChainPayment> crateApiNodeLdkNodeOnChainPayment(
      {required LdkNode ptr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(ptr);
        return wire.wire__crate__api__node__ldk_node_on_chain_payment(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ldk_on_chain_payment,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeOnChainPaymentConstMeta,
      argValues: [ptr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeOnChainPaymentConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_on_chain_payment",
        argNames: ["ptr"],
      );

  @override
  Future<PaymentDetails?> crateApiNodeLdkNodePayment(
      {required LdkNode that, required PaymentId paymentId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_box_autoadd_payment_id(paymentId);
        return wire.wire__crate__api__node__ldk_node_payment(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_payment_details,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodePaymentConstMeta,
      argValues: [that, paymentId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodePaymentConstMeta => const TaskConstMeta(
        debugName: "ldk_node_payment",
        argNames: ["that", "paymentId"],
      );

  @override
  Future<void> crateApiNodeLdkNodeRemovePayment(
      {required LdkNode that, required PaymentId paymentId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_box_autoadd_payment_id(paymentId);
        return wire.wire__crate__api__node__ldk_node_remove_payment(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiNodeLdkNodeRemovePaymentConstMeta,
      argValues: [that, paymentId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeRemovePaymentConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_remove_payment",
        argNames: ["that", "paymentId"],
      );

  @override
  Future<String> crateApiNodeLdkNodeSignMessage(
      {required LdkNode that, required List<int> msg}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_list_prim_u_8_loose(msg);
        return wire.wire__crate__api__node__ldk_node_sign_message(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiNodeLdkNodeSignMessageConstMeta,
      argValues: [that, msg],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeSignMessageConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_sign_message",
        argNames: ["that", "msg"],
      );

  @override
  Future<LdkSpontaneousPayment> crateApiNodeLdkNodeSpontaneousPayment(
      {required LdkNode ptr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(ptr);
        return wire.wire__crate__api__node__ldk_node_spontaneous_payment(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ldk_spontaneous_payment,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeSpontaneousPaymentConstMeta,
      argValues: [ptr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeSpontaneousPaymentConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_spontaneous_payment",
        argNames: ["ptr"],
      );

  @override
  Future<void> crateApiNodeLdkNodeStart({required LdkNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire__crate__api__node__ldk_node_start(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiNodeLdkNodeStartConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeStartConstMeta => const TaskConstMeta(
        debugName: "ldk_node_start",
        argNames: ["that"],
      );

  @override
  Future<NodeStatus> crateApiNodeLdkNodeStatus({required LdkNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire__crate__api__node__ldk_node_status(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_node_status,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeStatusConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeStatusConstMeta => const TaskConstMeta(
        debugName: "ldk_node_status",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiNodeLdkNodeStop({required LdkNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire__crate__api__node__ldk_node_stop(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiNodeLdkNodeStopConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeStopConstMeta => const TaskConstMeta(
        debugName: "ldk_node_stop",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiNodeLdkNodeSyncWallets({required LdkNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire__crate__api__node__ldk_node_sync_wallets(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiNodeLdkNodeSyncWalletsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeSyncWalletsConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_sync_wallets",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiNodeLdkNodeUpdateChannelConfig(
      {required LdkNode that,
      required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId,
      required ChannelConfig channelConfig}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_box_autoadd_user_channel_id(userChannelId);
        var arg2 = cst_encode_box_autoadd_public_key(counterpartyNodeId);
        var arg3 = cst_encode_box_autoadd_channel_config(channelConfig);
        return wire.wire__crate__api__node__ldk_node_update_channel_config(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiNodeLdkNodeUpdateChannelConfigConstMeta,
      argValues: [that, userChannelId, counterpartyNodeId, channelConfig],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeUpdateChannelConfigConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_update_channel_config",
        argNames: [
          "that",
          "userChannelId",
          "counterpartyNodeId",
          "channelConfig"
        ],
      );

  @override
  Future<bool> crateApiNodeLdkNodeVerifySignature(
      {required LdkNode that,
      required List<int> msg,
      required String sig,
      required PublicKey publicKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        var arg1 = cst_encode_list_prim_u_8_loose(msg);
        var arg2 = cst_encode_String(sig);
        var arg3 = cst_encode_box_autoadd_public_key(publicKey);
        return wire.wire__crate__api__node__ldk_node_verify_signature(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiNodeLdkNodeVerifySignatureConstMeta,
      argValues: [that, msg, sig, publicKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeVerifySignatureConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_verify_signature",
        argNames: ["that", "msg", "sig", "publicKey"],
      );

  @override
  Future<Event> crateApiNodeLdkNodeWaitNextEvent({required LdkNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_node(that);
        return wire.wire__crate__api__node__ldk_node_wait_next_event(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_event,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeLdkNodeWaitNextEventConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeLdkNodeWaitNextEventConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_node_wait_next_event",
        argNames: ["that"],
      );

  @override
  Future<Address> crateApiOnChainLdkOnChainPaymentNewAddress(
      {required LdkOnChainPayment that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_on_chain_payment(that);
        return wire
            .wire__crate__api__on_chain__ldk_on_chain_payment_new_address(
                port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_address,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiOnChainLdkOnChainPaymentNewAddressConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiOnChainLdkOnChainPaymentNewAddressConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_on_chain_payment_new_address",
        argNames: ["that"],
      );

  @override
  Future<Txid> crateApiOnChainLdkOnChainPaymentSendAllToAddress(
      {required LdkOnChainPayment that, required Address address}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_on_chain_payment(that);
        var arg1 = cst_encode_box_autoadd_address(address);
        return wire
            .wire__crate__api__on_chain__ldk_on_chain_payment_send_all_to_address(
                port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_txid,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiOnChainLdkOnChainPaymentSendAllToAddressConstMeta,
      argValues: [that, address],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiOnChainLdkOnChainPaymentSendAllToAddressConstMeta =>
          const TaskConstMeta(
            debugName: "ldk_on_chain_payment_send_all_to_address",
            argNames: ["that", "address"],
          );

  @override
  Future<Txid> crateApiOnChainLdkOnChainPaymentSendToAddress(
      {required LdkOnChainPayment that,
      required Address address,
      required BigInt amountSats}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_on_chain_payment(that);
        var arg1 = cst_encode_box_autoadd_address(address);
        var arg2 = cst_encode_u_64(amountSats);
        return wire
            .wire__crate__api__on_chain__ldk_on_chain_payment_send_to_address(
                port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_txid,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiOnChainLdkOnChainPaymentSendToAddressConstMeta,
      argValues: [that, address, amountSats],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiOnChainLdkOnChainPaymentSendToAddressConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_on_chain_payment_send_to_address",
        argNames: ["that", "address", "amountSats"],
      );

  @override
  Future<PaymentId> crateApiSpontaneousLdkSpontaneousPaymentSend(
      {required LdkSpontaneousPayment that,
      required BigInt amountMsat,
      required PublicKey nodeId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_spontaneous_payment(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_box_autoadd_public_key(nodeId);
        return wire.wire__crate__api__spontaneous__ldk_spontaneous_payment_send(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payment_id,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiSpontaneousLdkSpontaneousPaymentSendConstMeta,
      argValues: [that, amountMsat, nodeId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSpontaneousLdkSpontaneousPaymentSendConstMeta =>
      const TaskConstMeta(
        debugName: "ldk_spontaneous_payment_send",
        argNames: ["that", "amountMsat", "nodeId"],
      );

  @override
  Future<void> crateApiSpontaneousLdkSpontaneousPaymentSendProbes(
      {required LdkSpontaneousPayment that,
      required BigInt amountMsat,
      required PublicKey nodeId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ldk_spontaneous_payment(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_box_autoadd_public_key(nodeId);
        return wire
            .wire__crate__api__spontaneous__ldk_spontaneous_payment_send_probes(
                port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ldk_node_error,
      ),
      constMeta: kCrateApiSpontaneousLdkSpontaneousPaymentSendProbesConstMeta,
      argValues: [that, amountMsat, nodeId],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiSpontaneousLdkSpontaneousPaymentSendProbesConstMeta =>
          const TaskConstMeta(
            debugName: "ldk_spontaneous_payment_send_probes",
            argNames: ["that", "amountMsat", "nodeId"],
          );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcBolt12Payment => wire
          .rust_arc_increment_strong_count_RustOpaque_Arcldk_nodepaymentBolt12Payment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcBolt12Payment => wire
          .rust_arc_decrement_strong_count_RustOpaque_Arcldk_nodepaymentBolt12Payment;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Node =>
      wire.rust_arc_increment_strong_count_RustOpaque_Node;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Node =>
      wire.rust_arc_decrement_strong_count_RustOpaque_Node;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_NodeBuilder => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_NodeBuilder => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Builder =>
          wire.rust_arc_increment_strong_count_RustOpaque_ldk_nodeBuilder;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Builder =>
          wire.rust_arc_decrement_strong_count_RustOpaque_ldk_nodeBuilder;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_NetworkGraph => wire
          .rust_arc_increment_strong_count_RustOpaque_ldk_nodegraphNetworkGraph;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_NetworkGraph => wire
          .rust_arc_decrement_strong_count_RustOpaque_ldk_nodegraphNetworkGraph;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Bolt11Payment => wire
          .rust_arc_increment_strong_count_RustOpaque_ldk_nodepaymentBolt11Payment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Bolt11Payment => wire
          .rust_arc_decrement_strong_count_RustOpaque_ldk_nodepaymentBolt11Payment;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_OnchainPayment => wire
          .rust_arc_increment_strong_count_RustOpaque_ldk_nodepaymentOnchainPayment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_OnchainPayment => wire
          .rust_arc_decrement_strong_count_RustOpaque_ldk_nodepaymentOnchainPayment;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SpontaneousPayment => wire
          .rust_arc_increment_strong_count_RustOpaque_ldk_nodepaymentSpontaneousPayment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SpontaneousPayment => wire
          .rust_arc_decrement_strong_count_RustOpaque_ldk_nodepaymentSpontaneousPayment;

  @protected
  NodeBuilder
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NodeBuilderImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  NodeBuilder
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NodeBuilderImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  NodeBuilder
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NodeBuilderImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ArcBolt12Payment dco_decode_RustOpaque_Arcldk_nodepaymentBolt12Payment(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcBolt12PaymentImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Node dco_decode_RustOpaque_Node(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NodeImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  NodeBuilder
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NodeBuilderImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Builder dco_decode_RustOpaque_ldk_nodeBuilder(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BuilderImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  NetworkGraph dco_decode_RustOpaque_ldk_nodegraphNetworkGraph(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NetworkGraphImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Bolt11Payment dco_decode_RustOpaque_ldk_nodepaymentBolt11Payment(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Bolt11PaymentImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  OnchainPayment dco_decode_RustOpaque_ldk_nodepaymentOnchainPayment(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OnchainPaymentImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SpontaneousPayment dco_decode_RustOpaque_ldk_nodepaymentSpontaneousPayment(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SpontaneousPaymentImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  Address dco_decode_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Address(
      s: dco_decode_String(arr[0]),
    );
  }

  @protected
  AnchorChannelsConfig dco_decode_anchor_channels_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AnchorChannelsConfig(
      trustedPeersNoReserve: dco_decode_list_public_key(arr[0]),
      perChannelReserveSats: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  BalanceDetails dco_decode_balance_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return BalanceDetails(
      totalOnchainBalanceSats: dco_decode_u_64(arr[0]),
      spendableOnchainBalanceSats: dco_decode_u_64(arr[1]),
      totalLightningBalanceSats: dco_decode_u_64(arr[2]),
      lightningBalances: dco_decode_list_lightning_balance(arr[3]),
      pendingBalancesFromChannelClosures:
          dco_decode_list_pending_sweep_balance(arr[4]),
    );
  }

  @protected
  BestBlock dco_decode_best_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BestBlock(
      blockHash: dco_decode_String(arr[0]),
      height: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  Bolt11Invoice dco_decode_bolt_11_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Bolt11Invoice(
      signedRawInvoice: dco_decode_String(arr[0]),
    );
  }

  @protected
  Bolt12Invoice dco_decode_bolt_12_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Bolt12Invoice(
      data: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  Bolt12ParseError dco_decode_bolt_12_parse_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Bolt12ParseError_InvalidContinuation();
      case 1:
        return Bolt12ParseError_InvalidBech32Hrp();
      case 2:
        return Bolt12ParseError_Bech32(
          dco_decode_String(raw[1]),
        );
      case 3:
        return Bolt12ParseError_Decode(
          dco_decode_box_autoadd_decode_error(raw[1]),
        );
      case 4:
        return Bolt12ParseError_InvalidSemantics(
          dco_decode_String(raw[1]),
        );
      case 5:
        return Bolt12ParseError_InvalidSignature(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  Address dco_decode_box_autoadd_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_address(raw);
  }

  @protected
  AnchorChannelsConfig dco_decode_box_autoadd_anchor_channels_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_anchor_channels_config(raw);
  }

  @protected
  Bolt11Invoice dco_decode_box_autoadd_bolt_11_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bolt_11_invoice(raw);
  }

  @protected
  Bolt12ParseError dco_decode_box_autoadd_bolt_12_parse_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bolt_12_parse_error(raw);
  }

  @protected
  ChainDataSourceConfig dco_decode_box_autoadd_chain_data_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_chain_data_source_config(raw);
  }

  @protected
  ChannelConfig dco_decode_box_autoadd_channel_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_channel_config(raw);
  }

  @protected
  ChannelId dco_decode_box_autoadd_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_channel_id(raw);
  }

  @protected
  ChannelInfo dco_decode_box_autoadd_channel_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_channel_info(raw);
  }

  @protected
  ChannelUpdateInfo dco_decode_box_autoadd_channel_update_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_channel_update_info(raw);
  }

  @protected
  ClosureReason dco_decode_box_autoadd_closure_reason(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_closure_reason(raw);
  }

  @protected
  Config dco_decode_box_autoadd_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_config(raw);
  }

  @protected
  DecodeError dco_decode_box_autoadd_decode_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_decode_error(raw);
  }

  @protected
  EntropySourceConfig dco_decode_box_autoadd_entropy_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_entropy_source_config(raw);
  }

  @protected
  Event dco_decode_box_autoadd_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_event(raw);
  }

  @protected
  GossipSourceConfig dco_decode_box_autoadd_gossip_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_gossip_source_config(raw);
  }

  @protected
  LdkBolt11Payment dco_decode_box_autoadd_ldk_bolt_11_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ldk_bolt_11_payment(raw);
  }

  @protected
  LdkBolt12Payment dco_decode_box_autoadd_ldk_bolt_12_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ldk_bolt_12_payment(raw);
  }

  @protected
  LdkMnemonic dco_decode_box_autoadd_ldk_mnemonic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ldk_mnemonic(raw);
  }

  @protected
  LdkNetworkGraph dco_decode_box_autoadd_ldk_network_graph(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ldk_network_graph(raw);
  }

  @protected
  LdkNode dco_decode_box_autoadd_ldk_node(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ldk_node(raw);
  }

  @protected
  LdkOnChainPayment dco_decode_box_autoadd_ldk_on_chain_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ldk_on_chain_payment(raw);
  }

  @protected
  LdkSpontaneousPayment dco_decode_box_autoadd_ldk_spontaneous_payment(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ldk_spontaneous_payment(raw);
  }

  @protected
  LiquiditySourceConfig dco_decode_box_autoadd_liquidity_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_liquidity_source_config(raw);
  }

  @protected
  LSPFeeLimits dco_decode_box_autoadd_lsp_fee_limits(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_lsp_fee_limits(raw);
  }

  @protected
  MaxDustHTLCExposure dco_decode_box_autoadd_max_dust_htlc_exposure(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_max_dust_htlc_exposure(raw);
  }

  @protected
  NodeAnnouncementInfo dco_decode_box_autoadd_node_announcement_info(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_node_announcement_info(raw);
  }

  @protected
  NodeId dco_decode_box_autoadd_node_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_node_id(raw);
  }

  @protected
  NodeInfo dco_decode_box_autoadd_node_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_node_info(raw);
  }

  @protected
  Offer dco_decode_box_autoadd_offer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_offer(raw);
  }

  @protected
  OfferId dco_decode_box_autoadd_offer_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_offer_id(raw);
  }

  @protected
  OutPoint dco_decode_box_autoadd_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_out_point(raw);
  }

  @protected
  PaymentDetails dco_decode_box_autoadd_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_details(raw);
  }

  @protected
  PaymentFailureReason dco_decode_box_autoadd_payment_failure_reason(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_failure_reason(raw);
  }

  @protected
  PaymentHash dco_decode_box_autoadd_payment_hash(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_hash(raw);
  }

  @protected
  PaymentId dco_decode_box_autoadd_payment_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_id(raw);
  }

  @protected
  PaymentPreimage dco_decode_box_autoadd_payment_preimage(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_preimage(raw);
  }

  @protected
  PaymentSecret dco_decode_box_autoadd_payment_secret(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_secret(raw);
  }

  @protected
  PublicKey dco_decode_box_autoadd_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_public_key(raw);
  }

  @protected
  Refund dco_decode_box_autoadd_refund(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_refund(raw);
  }

  @protected
  SocketAddress dco_decode_box_autoadd_socket_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_socket_address(raw);
  }

  @protected
  Txid dco_decode_box_autoadd_txid(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_txid(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  UserChannelId dco_decode_box_autoadd_user_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_user_channel_id(raw);
  }

  @protected
  ChainDataSourceConfig dco_decode_chain_data_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ChainDataSourceConfig_Esplora(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ChannelConfig dco_decode_channel_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ChannelConfig(
      forwardingFeeProportionalMillionths: dco_decode_u_32(arr[0]),
      forwardingFeeBaseMsat: dco_decode_u_32(arr[1]),
      cltvExpiryDelta: dco_decode_u_16(arr[2]),
      maxDustHtlcExposure:
          dco_decode_opt_box_autoadd_max_dust_htlc_exposure(arr[3]),
      forceCloseAvoidanceMaxFeeSatoshis: dco_decode_u_64(arr[4]),
      acceptUnderpayingHtlcs: dco_decode_bool(arr[5]),
    );
  }

  @protected
  ChannelDetails dco_decode_channel_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 28)
      throw Exception('unexpected arr length: expect 28 but see ${arr.length}');
    return ChannelDetails(
      channelId: dco_decode_channel_id(arr[0]),
      counterpartyNodeId: dco_decode_public_key(arr[1]),
      fundingTxo: dco_decode_opt_box_autoadd_out_point(arr[2]),
      channelValueSats: dco_decode_u_64(arr[3]),
      unspendablePunishmentReserve: dco_decode_opt_box_autoadd_u_64(arr[4]),
      userChannelId: dco_decode_user_channel_id(arr[5]),
      feerateSatPer1000Weight: dco_decode_u_32(arr[6]),
      outboundCapacityMsat: dco_decode_u_64(arr[7]),
      inboundCapacityMsat: dco_decode_u_64(arr[8]),
      confirmationsRequired: dco_decode_opt_box_autoadd_u_32(arr[9]),
      confirmations: dco_decode_opt_box_autoadd_u_32(arr[10]),
      isOutbound: dco_decode_bool(arr[11]),
      isChannelReady: dco_decode_bool(arr[12]),
      isUsable: dco_decode_bool(arr[13]),
      isPublic: dco_decode_bool(arr[14]),
      cltvExpiryDelta: dco_decode_opt_box_autoadd_u_16(arr[15]),
      counterpartyUnspendablePunishmentReserve: dco_decode_u_64(arr[16]),
      counterpartyOutboundHtlcMinimumMsat:
          dco_decode_opt_box_autoadd_u_64(arr[17]),
      counterpartyOutboundHtlcMaximumMsat:
          dco_decode_opt_box_autoadd_u_64(arr[18]),
      counterpartyForwardingInfoFeeBaseMsat:
          dco_decode_opt_box_autoadd_u_32(arr[19]),
      counterpartyForwardingInfoFeeProportionalMillionths:
          dco_decode_opt_box_autoadd_u_32(arr[20]),
      counterpartyForwardingInfoCltvExpiryDelta:
          dco_decode_opt_box_autoadd_u_16(arr[21]),
      nextOutboundHtlcLimitMsat: dco_decode_u_64(arr[22]),
      nextOutboundHtlcMinimumMsat: dco_decode_u_64(arr[23]),
      forceCloseSpendDelay: dco_decode_opt_box_autoadd_u_16(arr[24]),
      inboundHtlcMinimumMsat: dco_decode_u_64(arr[25]),
      inboundHtlcMaximumMsat: dco_decode_opt_box_autoadd_u_64(arr[26]),
      config: dco_decode_channel_config(arr[27]),
    );
  }

  @protected
  ChannelId dco_decode_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return ChannelId(
      data: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  ChannelInfo dco_decode_channel_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return ChannelInfo(
      nodeOne: dco_decode_node_id(arr[0]),
      oneToTwo: dco_decode_opt_box_autoadd_channel_update_info(arr[1]),
      nodeTwo: dco_decode_node_id(arr[2]),
      twoToOne: dco_decode_opt_box_autoadd_channel_update_info(arr[3]),
      capacitySats: dco_decode_opt_box_autoadd_u_64(arr[4]),
    );
  }

  @protected
  ChannelUpdateInfo dco_decode_channel_update_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ChannelUpdateInfo(
      lastUpdate: dco_decode_u_32(arr[0]),
      enabled: dco_decode_bool(arr[1]),
      cltvExpiryDelta: dco_decode_u_16(arr[2]),
      htlcMinimumMsat: dco_decode_u_64(arr[3]),
      htlcMaximumMsat: dco_decode_u_64(arr[4]),
      fees: dco_decode_routing_fees(arr[5]),
    );
  }

  @protected
  ClosureReason dco_decode_closure_reason(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ClosureReason_CounterpartyForceClosed(
          peerMsg: dco_decode_String(raw[1]),
        );
      case 1:
        return ClosureReason_HolderForceClosed();
      case 2:
        return ClosureReason_LegacyCooperativeClosure();
      case 3:
        return ClosureReason_CounterpartyInitiatedCooperativeClosure();
      case 4:
        return ClosureReason_LocallyInitiatedCooperativeClosure();
      case 5:
        return ClosureReason_CommitmentTxConfirmed();
      case 6:
        return ClosureReason_FundingTimedOut();
      case 7:
        return ClosureReason_ProcessingError(
          err: dco_decode_String(raw[1]),
        );
      case 8:
        return ClosureReason_DisconnectedPeer();
      case 9:
        return ClosureReason_OutdatedChannelManager();
      case 10:
        return ClosureReason_CounterpartyCoopClosedUnfundedChannel();
      case 11:
        return ClosureReason_FundingBatchClosure();
      case 12:
        return ClosureReason_HTLCsTimedOut();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Config dco_decode_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return Config(
      storageDirPath: dco_decode_String(arr[0]),
      logDirPath: dco_decode_opt_String(arr[1]),
      network: dco_decode_network(arr[2]),
      listeningAddresses: dco_decode_opt_list_socket_address(arr[3]),
      defaultCltvExpiryDelta: dco_decode_u_32(arr[4]),
      onchainWalletSyncIntervalSecs: dco_decode_u_64(arr[5]),
      walletSyncIntervalSecs: dco_decode_u_64(arr[6]),
      feeRateCacheUpdateIntervalSecs: dco_decode_u_64(arr[7]),
      trustedPeers0Conf: dco_decode_list_public_key(arr[8]),
      probingLiquidityLimitMultiplier: dco_decode_u_64(arr[9]),
      logLevel: dco_decode_log_level(arr[10]),
      anchorChannelsConfig:
          dco_decode_opt_box_autoadd_anchor_channels_config(arr[11]),
    );
  }

  @protected
  DecodeError dco_decode_decode_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return DecodeError_UnknownVersion();
      case 1:
        return DecodeError_UnknownRequiredFeature();
      case 2:
        return DecodeError_InvalidValue();
      case 3:
        return DecodeError_ShortRead();
      case 4:
        return DecodeError_BadLengthDescriptor();
      case 5:
        return DecodeError_Io(
          dco_decode_String(raw[1]),
        );
      case 6:
        return DecodeError_UnsupportedCompression();
      case 7:
        return DecodeError_DangerousValue();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  EntropySourceConfig dco_decode_entropy_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return EntropySourceConfig_SeedFile(
          dco_decode_String(raw[1]),
        );
      case 1:
        return EntropySourceConfig_SeedBytes(
          dco_decode_u_8_array_64(raw[1]),
        );
      case 2:
        return EntropySourceConfig_Bip39Mnemonic(
          mnemonic: dco_decode_box_autoadd_ldk_mnemonic(raw[1]),
          passphrase: dco_decode_opt_String(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Event dco_decode_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Event_PaymentClaimable(
          paymentId: dco_decode_box_autoadd_payment_id(raw[1]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[2]),
          claimableAmountMsat: dco_decode_u_64(raw[3]),
          claimDeadline: dco_decode_opt_box_autoadd_u_32(raw[4]),
        );
      case 1:
        return Event_PaymentSuccessful(
          paymentId: dco_decode_opt_box_autoadd_payment_id(raw[1]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[2]),
          feePaidMsat: dco_decode_opt_box_autoadd_u_64(raw[3]),
        );
      case 2:
        return Event_PaymentFailed(
          paymentId: dco_decode_opt_box_autoadd_payment_id(raw[1]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[2]),
          reason: dco_decode_opt_box_autoadd_payment_failure_reason(raw[3]),
        );
      case 3:
        return Event_PaymentReceived(
          paymentId: dco_decode_opt_box_autoadd_payment_id(raw[1]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[2]),
          amountMsat: dco_decode_u_64(raw[3]),
        );
      case 4:
        return Event_ChannelPending(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          userChannelId: dco_decode_box_autoadd_user_channel_id(raw[2]),
          formerTemporaryChannelId: dco_decode_box_autoadd_channel_id(raw[3]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[4]),
          fundingTxo: dco_decode_box_autoadd_out_point(raw[5]),
        );
      case 5:
        return Event_ChannelReady(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          userChannelId: dco_decode_box_autoadd_user_channel_id(raw[2]),
          counterpartyNodeId: dco_decode_opt_box_autoadd_public_key(raw[3]),
        );
      case 6:
        return Event_ChannelClosed(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          userChannelId: dco_decode_box_autoadd_user_channel_id(raw[2]),
          counterpartyNodeId: dco_decode_opt_box_autoadd_public_key(raw[3]),
          reason: dco_decode_opt_box_autoadd_closure_reason(raw[4]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  GossipSourceConfig dco_decode_gossip_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return GossipSourceConfig_P2PNetwork();
      case 1:
        return GossipSourceConfig_RapidGossipSync(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  LdkBolt11Payment dco_decode_ldk_bolt_11_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LdkBolt11Payment(
      ptr: dco_decode_RustOpaque_ldk_nodepaymentBolt11Payment(arr[0]),
    );
  }

  @protected
  LdkBolt12Payment dco_decode_ldk_bolt_12_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LdkBolt12Payment(
      ptr: dco_decode_RustOpaque_Arcldk_nodepaymentBolt12Payment(arr[0]),
    );
  }

  @protected
  LdkBuilderError dco_decode_ldk_builder_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return LdkBuilderError.values[raw as int];
  }

  @protected
  LdkMnemonic dco_decode_ldk_mnemonic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LdkMnemonic(
      seedPhrase: dco_decode_String(arr[0]),
    );
  }

  @protected
  LdkNetworkGraph dco_decode_ldk_network_graph(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LdkNetworkGraph(
      ptr: dco_decode_RustOpaque_ldk_nodegraphNetworkGraph(arr[0]),
    );
  }

  @protected
  LdkNode dco_decode_ldk_node(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LdkNode(
      ptr: dco_decode_RustOpaque_Node(arr[0]),
    );
  }

  @protected
  LdkNodeError dco_decode_ldk_node_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LdkNodeError_InvalidTxid();
      case 1:
        return LdkNodeError_AlreadyRunning();
      case 2:
        return LdkNodeError_NotRunning();
      case 3:
        return LdkNodeError_OnchainTxCreationFailed();
      case 4:
        return LdkNodeError_ConnectionFailed();
      case 5:
        return LdkNodeError_InvoiceCreationFailed();
      case 6:
        return LdkNodeError_PaymentSendingFailed();
      case 7:
        return LdkNodeError_ProbeSendingFailed();
      case 8:
        return LdkNodeError_ChannelCreationFailed();
      case 9:
        return LdkNodeError_ChannelClosingFailed();
      case 10:
        return LdkNodeError_ChannelConfigUpdateFailed();
      case 11:
        return LdkNodeError_PersistenceFailed();
      case 12:
        return LdkNodeError_WalletOperationFailed();
      case 13:
        return LdkNodeError_OnchainTxSigningFailed();
      case 14:
        return LdkNodeError_MessageSigningFailed();
      case 15:
        return LdkNodeError_TxSyncFailed();
      case 16:
        return LdkNodeError_GossipUpdateFailed();
      case 17:
        return LdkNodeError_InvalidAddress();
      case 18:
        return LdkNodeError_InvalidSocketAddress();
      case 19:
        return LdkNodeError_InvalidPublicKey();
      case 20:
        return LdkNodeError_InvalidSecretKey();
      case 21:
        return LdkNodeError_InvalidPaymentHash();
      case 22:
        return LdkNodeError_InvalidPaymentPreimage();
      case 23:
        return LdkNodeError_InvalidPaymentSecret();
      case 24:
        return LdkNodeError_InvalidAmount();
      case 25:
        return LdkNodeError_InvalidInvoice();
      case 26:
        return LdkNodeError_InvalidChannelId();
      case 27:
        return LdkNodeError_InvalidNetwork();
      case 28:
        return LdkNodeError_DuplicatePayment();
      case 29:
        return LdkNodeError_InsufficientFunds();
      case 30:
        return LdkNodeError_FeerateEstimationUpdateFailed();
      case 31:
        return LdkNodeError_LiquidityRequestFailed();
      case 32:
        return LdkNodeError_LiquiditySourceUnavailable();
      case 33:
        return LdkNodeError_LiquidityFeeTooHigh();
      case 34:
        return LdkNodeError_InvalidPaymentId();
      case 35:
        return LdkNodeError_Decode(
          dco_decode_box_autoadd_decode_error(raw[1]),
        );
      case 36:
        return LdkNodeError_Bolt12Parse(
          dco_decode_box_autoadd_bolt_12_parse_error(raw[1]),
        );
      case 37:
        return LdkNodeError_InvoiceRequestCreationFailed();
      case 38:
        return LdkNodeError_OfferCreationFailed();
      case 39:
        return LdkNodeError_RefundCreationFailed();
      case 40:
        return LdkNodeError_FeerateEstimationUpdateTimeout();
      case 41:
        return LdkNodeError_WalletOperationTimeout();
      case 42:
        return LdkNodeError_TxSyncTimeout();
      case 43:
        return LdkNodeError_GossipUpdateTimeout();
      case 44:
        return LdkNodeError_InvalidOfferId();
      case 45:
        return LdkNodeError_InvalidNodeId();
      case 46:
        return LdkNodeError_InvalidOffer();
      case 47:
        return LdkNodeError_InvalidRefund();
      case 48:
        return LdkNodeError_UnsupportedCurrency();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LdkOnChainPayment dco_decode_ldk_on_chain_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LdkOnChainPayment(
      ptr: dco_decode_RustOpaque_ldk_nodepaymentOnchainPayment(arr[0]),
    );
  }

  @protected
  LdkSpontaneousPayment dco_decode_ldk_spontaneous_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LdkSpontaneousPayment(
      ptr: dco_decode_RustOpaque_ldk_nodepaymentSpontaneousPayment(arr[0]),
    );
  }

  @protected
  LightningBalance dco_decode_lightning_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LightningBalance_ClaimableOnChannelClose(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
        );
      case 1:
        return LightningBalance_ClaimableAwaitingConfirmations(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
          confirmationHeight: dco_decode_u_32(raw[4]),
        );
      case 2:
        return LightningBalance_ContentiousClaimable(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
          timeoutHeight: dco_decode_u_32(raw[4]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[5]),
          paymentPreimage: dco_decode_box_autoadd_payment_preimage(raw[6]),
        );
      case 3:
        return LightningBalance_MaybeTimeoutClaimableHTLC(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
          claimableHeight: dco_decode_u_32(raw[4]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[5]),
        );
      case 4:
        return LightningBalance_MaybePreimageClaimableHTLC(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
          expiryHeight: dco_decode_u_32(raw[4]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[5]),
        );
      case 5:
        return LightningBalance_CounterpartyRevokedOutputClaimable(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LiquiditySourceConfig dco_decode_liquidity_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LiquiditySourceConfig(
      lsps2Service:
          dco_decode_record_socket_address_public_key_opt_string(arr[0]),
    );
  }

  @protected
  List<ChannelDetails> dco_decode_list_channel_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_channel_details).toList();
  }

  @protected
  List<LightningBalance> dco_decode_list_lightning_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_lightning_balance).toList();
  }

  @protected
  List<NodeId> dco_decode_list_node_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_node_id).toList();
  }

  @protected
  List<PaymentDetails> dco_decode_list_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_payment_details).toList();
  }

  @protected
  List<PeerDetails> dco_decode_list_peer_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_peer_details).toList();
  }

  @protected
  List<PendingSweepBalance> dco_decode_list_pending_sweep_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_pending_sweep_balance)
        .toList();
  }

  @protected
  Uint64List dco_decode_list_prim_u_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeUint64List(raw);
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<PublicKey> dco_decode_list_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_public_key).toList();
  }

  @protected
  List<SocketAddress> dco_decode_list_socket_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_socket_address).toList();
  }

  @protected
  LogLevel dco_decode_log_level(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return LogLevel.values[raw as int];
  }

  @protected
  LSPFeeLimits dco_decode_lsp_fee_limits(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LSPFeeLimits(
      maxTotalOpeningFeeMsat: dco_decode_opt_box_autoadd_u_64(arr[0]),
      maxProportionalOpeningFeePpmMsat: dco_decode_opt_box_autoadd_u_64(arr[1]),
    );
  }

  @protected
  MaxDustHTLCExposure dco_decode_max_dust_htlc_exposure(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return MaxDustHTLCExposure_FixedLimitMsat(
          dco_decode_u_64(raw[1]),
        );
      case 1:
        return MaxDustHTLCExposure_FeeRateMultiplier(
          dco_decode_u_64(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  NodeAnnouncementInfo dco_decode_node_announcement_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return NodeAnnouncementInfo(
      lastUpdate: dco_decode_u_32(arr[0]),
      alias: dco_decode_String(arr[1]),
      addresses: dco_decode_list_socket_address(arr[2]),
    );
  }

  @protected
  NodeId dco_decode_node_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return NodeId(
      compressed: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  NodeInfo dco_decode_node_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return NodeInfo(
      channels: dco_decode_list_prim_u_64_strict(arr[0]),
      announcementInfo:
          dco_decode_opt_box_autoadd_node_announcement_info(arr[1]),
    );
  }

  @protected
  NodeStatus dco_decode_node_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return NodeStatus(
      isRunning: dco_decode_bool(arr[0]),
      isListening: dco_decode_bool(arr[1]),
      currentBestBlock: dco_decode_best_block(arr[2]),
      latestWalletSyncTimestamp: dco_decode_opt_box_autoadd_u_64(arr[3]),
      latestOnchainWalletSyncTimestamp: dco_decode_opt_box_autoadd_u_64(arr[4]),
      latestFeeRateCacheUpdateTimestamp:
          dco_decode_opt_box_autoadd_u_64(arr[5]),
      latestRgsSnapshotTimestamp: dco_decode_opt_box_autoadd_u_64(arr[6]),
      latestNodeAnnouncementBroadcastTimestamp:
          dco_decode_opt_box_autoadd_u_64(arr[7]),
    );
  }

  @protected
  Offer dco_decode_offer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Offer(
      s: dco_decode_String(arr[0]),
    );
  }

  @protected
  OfferId dco_decode_offer_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return OfferId(
      field0: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  AnchorChannelsConfig? dco_decode_opt_box_autoadd_anchor_channels_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_anchor_channels_config(raw);
  }

  @protected
  ChainDataSourceConfig? dco_decode_opt_box_autoadd_chain_data_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_chain_data_source_config(raw);
  }

  @protected
  ChannelConfig? dco_decode_opt_box_autoadd_channel_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_channel_config(raw);
  }

  @protected
  ChannelId? dco_decode_opt_box_autoadd_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_channel_id(raw);
  }

  @protected
  ChannelInfo? dco_decode_opt_box_autoadd_channel_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_channel_info(raw);
  }

  @protected
  ChannelUpdateInfo? dco_decode_opt_box_autoadd_channel_update_info(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_channel_update_info(raw);
  }

  @protected
  ClosureReason? dco_decode_opt_box_autoadd_closure_reason(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_closure_reason(raw);
  }

  @protected
  EntropySourceConfig? dco_decode_opt_box_autoadd_entropy_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_entropy_source_config(raw);
  }

  @protected
  Event? dco_decode_opt_box_autoadd_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_event(raw);
  }

  @protected
  GossipSourceConfig? dco_decode_opt_box_autoadd_gossip_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_gossip_source_config(raw);
  }

  @protected
  LiquiditySourceConfig? dco_decode_opt_box_autoadd_liquidity_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_liquidity_source_config(raw);
  }

  @protected
  MaxDustHTLCExposure? dco_decode_opt_box_autoadd_max_dust_htlc_exposure(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_max_dust_htlc_exposure(raw);
  }

  @protected
  NodeAnnouncementInfo? dco_decode_opt_box_autoadd_node_announcement_info(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_node_announcement_info(raw);
  }

  @protected
  NodeInfo? dco_decode_opt_box_autoadd_node_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_node_info(raw);
  }

  @protected
  OutPoint? dco_decode_opt_box_autoadd_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_out_point(raw);
  }

  @protected
  PaymentDetails? dco_decode_opt_box_autoadd_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_details(raw);
  }

  @protected
  PaymentFailureReason? dco_decode_opt_box_autoadd_payment_failure_reason(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_payment_failure_reason(raw);
  }

  @protected
  PaymentHash? dco_decode_opt_box_autoadd_payment_hash(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_hash(raw);
  }

  @protected
  PaymentId? dco_decode_opt_box_autoadd_payment_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_id(raw);
  }

  @protected
  PaymentPreimage? dco_decode_opt_box_autoadd_payment_preimage(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_preimage(raw);
  }

  @protected
  PaymentSecret? dco_decode_opt_box_autoadd_payment_secret(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_secret(raw);
  }

  @protected
  PublicKey? dco_decode_opt_box_autoadd_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_public_key(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_16(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  List<SocketAddress>? dco_decode_opt_list_socket_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_socket_address(raw);
  }

  @protected
  OutPoint dco_decode_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OutPoint(
      txid: dco_decode_txid(arr[0]),
      vout: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  PaymentDetails dco_decode_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return PaymentDetails(
      id: dco_decode_payment_id(arr[0]),
      kind: dco_decode_payment_kind(arr[1]),
      amountMsat: dco_decode_opt_box_autoadd_u_64(arr[2]),
      direction: dco_decode_payment_direction(arr[3]),
      status: dco_decode_payment_status(arr[4]),
      latestUpdateTimestamp: dco_decode_u_64(arr[5]),
    );
  }

  @protected
  PaymentDirection dco_decode_payment_direction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentDirection.values[raw as int];
  }

  @protected
  PaymentFailureReason dco_decode_payment_failure_reason(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentFailureReason.values[raw as int];
  }

  @protected
  PaymentHash dco_decode_payment_hash(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PaymentHash(
      data: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  PaymentId dco_decode_payment_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PaymentId(
      field0: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  PaymentKind dco_decode_payment_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PaymentKind_Onchain();
      case 1:
        return PaymentKind_Bolt11(
          hash: dco_decode_box_autoadd_payment_hash(raw[1]),
          preimage: dco_decode_opt_box_autoadd_payment_preimage(raw[2]),
          secret: dco_decode_opt_box_autoadd_payment_secret(raw[3]),
        );
      case 2:
        return PaymentKind_Bolt11Jit(
          hash: dco_decode_box_autoadd_payment_hash(raw[1]),
          preimage: dco_decode_opt_box_autoadd_payment_preimage(raw[2]),
          secret: dco_decode_opt_box_autoadd_payment_secret(raw[3]),
          lspFeeLimits: dco_decode_box_autoadd_lsp_fee_limits(raw[4]),
        );
      case 3:
        return PaymentKind_Spontaneous(
          hash: dco_decode_box_autoadd_payment_hash(raw[1]),
          preimage: dco_decode_opt_box_autoadd_payment_preimage(raw[2]),
        );
      case 4:
        return PaymentKind_Bolt12Offer(
          hash: dco_decode_opt_box_autoadd_payment_hash(raw[1]),
          preimage: dco_decode_opt_box_autoadd_payment_preimage(raw[2]),
          secret: dco_decode_opt_box_autoadd_payment_secret(raw[3]),
          offerId: dco_decode_box_autoadd_offer_id(raw[4]),
        );
      case 5:
        return PaymentKind_Bolt12Refund(
          hash: dco_decode_opt_box_autoadd_payment_hash(raw[1]),
          preimage: dco_decode_opt_box_autoadd_payment_preimage(raw[2]),
          secret: dco_decode_opt_box_autoadd_payment_secret(raw[3]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PaymentPreimage dco_decode_payment_preimage(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PaymentPreimage(
      data: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  PaymentSecret dco_decode_payment_secret(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PaymentSecret(
      data: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  PaymentStatus dco_decode_payment_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentStatus.values[raw as int];
  }

  @protected
  PeerDetails dco_decode_peer_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PeerDetails(
      nodeId: dco_decode_public_key(arr[0]),
      address: dco_decode_socket_address(arr[1]),
      isConnected: dco_decode_bool(arr[2]),
    );
  }

  @protected
  PendingSweepBalance dco_decode_pending_sweep_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PendingSweepBalance_PendingBroadcast(
          channelId: dco_decode_opt_box_autoadd_channel_id(raw[1]),
          amountSatoshis: dco_decode_u_64(raw[2]),
        );
      case 1:
        return PendingSweepBalance_BroadcastAwaitingConfirmation(
          channelId: dco_decode_opt_box_autoadd_channel_id(raw[1]),
          latestBroadcastHeight: dco_decode_u_32(raw[2]),
          latestSpendingTxid: dco_decode_box_autoadd_txid(raw[3]),
          amountSatoshis: dco_decode_u_64(raw[4]),
        );
      case 2:
        return PendingSweepBalance_AwaitingThresholdConfirmations(
          channelId: dco_decode_opt_box_autoadd_channel_id(raw[1]),
          latestSpendingTxid: dco_decode_box_autoadd_txid(raw[2]),
          confirmationHash: dco_decode_String(raw[3]),
          confirmationHeight: dco_decode_u_32(raw[4]),
          amountSatoshis: dco_decode_u_64(raw[5]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PublicKey dco_decode_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PublicKey(
      hex: dco_decode_String(arr[0]),
    );
  }

  @protected
  (SocketAddress, PublicKey, String?)
      dco_decode_record_socket_address_public_key_opt_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) {
      throw Exception('Expected 3 elements, got ${arr.length}');
    }
    return (
      dco_decode_socket_address(arr[0]),
      dco_decode_public_key(arr[1]),
      dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  Refund dco_decode_refund(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Refund(
      s: dco_decode_String(arr[0]),
    );
  }

  @protected
  RoutingFees dco_decode_routing_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RoutingFees(
      baseMsat: dco_decode_u_32(arr[0]),
      proportionalMillionths: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  SocketAddress dco_decode_socket_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SocketAddress_TcpIpV4(
          addr: dco_decode_u_8_array_4(raw[1]),
          port: dco_decode_u_16(raw[2]),
        );
      case 1:
        return SocketAddress_TcpIpV6(
          addr: dco_decode_u_8_array_16(raw[1]),
          port: dco_decode_u_16(raw[2]),
        );
      case 2:
        return SocketAddress_OnionV2(
          dco_decode_u_8_array_12(raw[1]),
        );
      case 3:
        return SocketAddress_OnionV3(
          ed25519Pubkey: dco_decode_u_8_array_32(raw[1]),
          checksum: dco_decode_u_16(raw[2]),
          version: dco_decode_u_8(raw[3]),
          port: dco_decode_u_16(raw[4]),
        );
      case 4:
        return SocketAddress_Hostname(
          addr: dco_decode_String(raw[1]),
          port: dco_decode_u_16(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Txid dco_decode_txid(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Txid(
      hash: dco_decode_String(arr[0]),
    );
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  U8Array12 dco_decode_u_8_array_12(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array12(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  U8Array16 dco_decode_u_8_array_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array16(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  U8Array32 dco_decode_u_8_array_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array32(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  U8Array4 dco_decode_u_8_array_4(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array4(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  U8Array64 dco_decode_u_8_array_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array64(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  UserChannelId dco_decode_user_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return UserChannelId(
      data: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  NodeBuilder
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NodeBuilderImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  NodeBuilder
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NodeBuilderImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  NodeBuilder
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NodeBuilderImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ArcBolt12Payment sse_decode_RustOpaque_Arcldk_nodepaymentBolt12Payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcBolt12PaymentImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Node sse_decode_RustOpaque_Node(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NodeImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  NodeBuilder
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NodeBuilderImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Builder sse_decode_RustOpaque_ldk_nodeBuilder(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BuilderImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  NetworkGraph sse_decode_RustOpaque_ldk_nodegraphNetworkGraph(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NetworkGraphImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Bolt11Payment sse_decode_RustOpaque_ldk_nodepaymentBolt11Payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Bolt11PaymentImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OnchainPayment sse_decode_RustOpaque_ldk_nodepaymentOnchainPayment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OnchainPaymentImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SpontaneousPayment sse_decode_RustOpaque_ldk_nodepaymentSpontaneousPayment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SpontaneousPaymentImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  Address sse_decode_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_s = sse_decode_String(deserializer);
    return Address(s: var_s);
  }

  @protected
  AnchorChannelsConfig sse_decode_anchor_channels_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_trustedPeersNoReserve = sse_decode_list_public_key(deserializer);
    var var_perChannelReserveSats = sse_decode_u_64(deserializer);
    return AnchorChannelsConfig(
        trustedPeersNoReserve: var_trustedPeersNoReserve,
        perChannelReserveSats: var_perChannelReserveSats);
  }

  @protected
  BalanceDetails sse_decode_balance_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_totalOnchainBalanceSats = sse_decode_u_64(deserializer);
    var var_spendableOnchainBalanceSats = sse_decode_u_64(deserializer);
    var var_totalLightningBalanceSats = sse_decode_u_64(deserializer);
    var var_lightningBalances = sse_decode_list_lightning_balance(deserializer);
    var var_pendingBalancesFromChannelClosures =
        sse_decode_list_pending_sweep_balance(deserializer);
    return BalanceDetails(
        totalOnchainBalanceSats: var_totalOnchainBalanceSats,
        spendableOnchainBalanceSats: var_spendableOnchainBalanceSats,
        totalLightningBalanceSats: var_totalLightningBalanceSats,
        lightningBalances: var_lightningBalances,
        pendingBalancesFromChannelClosures:
            var_pendingBalancesFromChannelClosures);
  }

  @protected
  BestBlock sse_decode_best_block(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_blockHash = sse_decode_String(deserializer);
    var var_height = sse_decode_u_32(deserializer);
    return BestBlock(blockHash: var_blockHash, height: var_height);
  }

  @protected
  Bolt11Invoice sse_decode_bolt_11_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_signedRawInvoice = sse_decode_String(deserializer);
    return Bolt11Invoice(signedRawInvoice: var_signedRawInvoice);
  }

  @protected
  Bolt12Invoice sse_decode_bolt_12_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_list_prim_u_8_strict(deserializer);
    return Bolt12Invoice(data: var_data);
  }

  @protected
  Bolt12ParseError sse_decode_bolt_12_parse_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return Bolt12ParseError_InvalidContinuation();
      case 1:
        return Bolt12ParseError_InvalidBech32Hrp();
      case 2:
        var var_field0 = sse_decode_String(deserializer);
        return Bolt12ParseError_Bech32(var_field0);
      case 3:
        var var_field0 = sse_decode_box_autoadd_decode_error(deserializer);
        return Bolt12ParseError_Decode(var_field0);
      case 4:
        var var_field0 = sse_decode_String(deserializer);
        return Bolt12ParseError_InvalidSemantics(var_field0);
      case 5:
        var var_field0 = sse_decode_String(deserializer);
        return Bolt12ParseError_InvalidSignature(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  Address sse_decode_box_autoadd_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_address(deserializer));
  }

  @protected
  AnchorChannelsConfig sse_decode_box_autoadd_anchor_channels_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_anchor_channels_config(deserializer));
  }

  @protected
  Bolt11Invoice sse_decode_box_autoadd_bolt_11_invoice(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bolt_11_invoice(deserializer));
  }

  @protected
  Bolt12ParseError sse_decode_box_autoadd_bolt_12_parse_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bolt_12_parse_error(deserializer));
  }

  @protected
  ChainDataSourceConfig sse_decode_box_autoadd_chain_data_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_chain_data_source_config(deserializer));
  }

  @protected
  ChannelConfig sse_decode_box_autoadd_channel_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_channel_config(deserializer));
  }

  @protected
  ChannelId sse_decode_box_autoadd_channel_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_channel_id(deserializer));
  }

  @protected
  ChannelInfo sse_decode_box_autoadd_channel_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_channel_info(deserializer));
  }

  @protected
  ChannelUpdateInfo sse_decode_box_autoadd_channel_update_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_channel_update_info(deserializer));
  }

  @protected
  ClosureReason sse_decode_box_autoadd_closure_reason(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_closure_reason(deserializer));
  }

  @protected
  Config sse_decode_box_autoadd_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_config(deserializer));
  }

  @protected
  DecodeError sse_decode_box_autoadd_decode_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_decode_error(deserializer));
  }

  @protected
  EntropySourceConfig sse_decode_box_autoadd_entropy_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_entropy_source_config(deserializer));
  }

  @protected
  Event sse_decode_box_autoadd_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_event(deserializer));
  }

  @protected
  GossipSourceConfig sse_decode_box_autoadd_gossip_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_gossip_source_config(deserializer));
  }

  @protected
  LdkBolt11Payment sse_decode_box_autoadd_ldk_bolt_11_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ldk_bolt_11_payment(deserializer));
  }

  @protected
  LdkBolt12Payment sse_decode_box_autoadd_ldk_bolt_12_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ldk_bolt_12_payment(deserializer));
  }

  @protected
  LdkMnemonic sse_decode_box_autoadd_ldk_mnemonic(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ldk_mnemonic(deserializer));
  }

  @protected
  LdkNetworkGraph sse_decode_box_autoadd_ldk_network_graph(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ldk_network_graph(deserializer));
  }

  @protected
  LdkNode sse_decode_box_autoadd_ldk_node(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ldk_node(deserializer));
  }

  @protected
  LdkOnChainPayment sse_decode_box_autoadd_ldk_on_chain_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ldk_on_chain_payment(deserializer));
  }

  @protected
  LdkSpontaneousPayment sse_decode_box_autoadd_ldk_spontaneous_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ldk_spontaneous_payment(deserializer));
  }

  @protected
  LiquiditySourceConfig sse_decode_box_autoadd_liquidity_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_liquidity_source_config(deserializer));
  }

  @protected
  LSPFeeLimits sse_decode_box_autoadd_lsp_fee_limits(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_lsp_fee_limits(deserializer));
  }

  @protected
  MaxDustHTLCExposure sse_decode_box_autoadd_max_dust_htlc_exposure(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_max_dust_htlc_exposure(deserializer));
  }

  @protected
  NodeAnnouncementInfo sse_decode_box_autoadd_node_announcement_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_node_announcement_info(deserializer));
  }

  @protected
  NodeId sse_decode_box_autoadd_node_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_node_id(deserializer));
  }

  @protected
  NodeInfo sse_decode_box_autoadd_node_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_node_info(deserializer));
  }

  @protected
  Offer sse_decode_box_autoadd_offer(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_offer(deserializer));
  }

  @protected
  OfferId sse_decode_box_autoadd_offer_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_offer_id(deserializer));
  }

  @protected
  OutPoint sse_decode_box_autoadd_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_out_point(deserializer));
  }

  @protected
  PaymentDetails sse_decode_box_autoadd_payment_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_details(deserializer));
  }

  @protected
  PaymentFailureReason sse_decode_box_autoadd_payment_failure_reason(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_failure_reason(deserializer));
  }

  @protected
  PaymentHash sse_decode_box_autoadd_payment_hash(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_hash(deserializer));
  }

  @protected
  PaymentId sse_decode_box_autoadd_payment_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_id(deserializer));
  }

  @protected
  PaymentPreimage sse_decode_box_autoadd_payment_preimage(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_preimage(deserializer));
  }

  @protected
  PaymentSecret sse_decode_box_autoadd_payment_secret(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_secret(deserializer));
  }

  @protected
  PublicKey sse_decode_box_autoadd_public_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_public_key(deserializer));
  }

  @protected
  Refund sse_decode_box_autoadd_refund(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_refund(deserializer));
  }

  @protected
  SocketAddress sse_decode_box_autoadd_socket_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_socket_address(deserializer));
  }

  @protected
  Txid sse_decode_box_autoadd_txid(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_txid(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_16(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  UserChannelId sse_decode_box_autoadd_user_channel_id(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_user_channel_id(deserializer));
  }

  @protected
  ChainDataSourceConfig sse_decode_chain_data_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return ChainDataSourceConfig_Esplora(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ChannelConfig sse_decode_channel_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_forwardingFeeProportionalMillionths = sse_decode_u_32(deserializer);
    var var_forwardingFeeBaseMsat = sse_decode_u_32(deserializer);
    var var_cltvExpiryDelta = sse_decode_u_16(deserializer);
    var var_maxDustHtlcExposure =
        sse_decode_opt_box_autoadd_max_dust_htlc_exposure(deserializer);
    var var_forceCloseAvoidanceMaxFeeSatoshis = sse_decode_u_64(deserializer);
    var var_acceptUnderpayingHtlcs = sse_decode_bool(deserializer);
    return ChannelConfig(
        forwardingFeeProportionalMillionths:
            var_forwardingFeeProportionalMillionths,
        forwardingFeeBaseMsat: var_forwardingFeeBaseMsat,
        cltvExpiryDelta: var_cltvExpiryDelta,
        maxDustHtlcExposure: var_maxDustHtlcExposure,
        forceCloseAvoidanceMaxFeeSatoshis:
            var_forceCloseAvoidanceMaxFeeSatoshis,
        acceptUnderpayingHtlcs: var_acceptUnderpayingHtlcs);
  }

  @protected
  ChannelDetails sse_decode_channel_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_channelId = sse_decode_channel_id(deserializer);
    var var_counterpartyNodeId = sse_decode_public_key(deserializer);
    var var_fundingTxo = sse_decode_opt_box_autoadd_out_point(deserializer);
    var var_channelValueSats = sse_decode_u_64(deserializer);
    var var_unspendablePunishmentReserve =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_userChannelId = sse_decode_user_channel_id(deserializer);
    var var_feerateSatPer1000Weight = sse_decode_u_32(deserializer);
    var var_outboundCapacityMsat = sse_decode_u_64(deserializer);
    var var_inboundCapacityMsat = sse_decode_u_64(deserializer);
    var var_confirmationsRequired =
        sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_confirmations = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_isOutbound = sse_decode_bool(deserializer);
    var var_isChannelReady = sse_decode_bool(deserializer);
    var var_isUsable = sse_decode_bool(deserializer);
    var var_isPublic = sse_decode_bool(deserializer);
    var var_cltvExpiryDelta = sse_decode_opt_box_autoadd_u_16(deserializer);
    var var_counterpartyUnspendablePunishmentReserve =
        sse_decode_u_64(deserializer);
    var var_counterpartyOutboundHtlcMinimumMsat =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_counterpartyOutboundHtlcMaximumMsat =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_counterpartyForwardingInfoFeeBaseMsat =
        sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_counterpartyForwardingInfoFeeProportionalMillionths =
        sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_counterpartyForwardingInfoCltvExpiryDelta =
        sse_decode_opt_box_autoadd_u_16(deserializer);
    var var_nextOutboundHtlcLimitMsat = sse_decode_u_64(deserializer);
    var var_nextOutboundHtlcMinimumMsat = sse_decode_u_64(deserializer);
    var var_forceCloseSpendDelay =
        sse_decode_opt_box_autoadd_u_16(deserializer);
    var var_inboundHtlcMinimumMsat = sse_decode_u_64(deserializer);
    var var_inboundHtlcMaximumMsat =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_config = sse_decode_channel_config(deserializer);
    return ChannelDetails(
        channelId: var_channelId,
        counterpartyNodeId: var_counterpartyNodeId,
        fundingTxo: var_fundingTxo,
        channelValueSats: var_channelValueSats,
        unspendablePunishmentReserve: var_unspendablePunishmentReserve,
        userChannelId: var_userChannelId,
        feerateSatPer1000Weight: var_feerateSatPer1000Weight,
        outboundCapacityMsat: var_outboundCapacityMsat,
        inboundCapacityMsat: var_inboundCapacityMsat,
        confirmationsRequired: var_confirmationsRequired,
        confirmations: var_confirmations,
        isOutbound: var_isOutbound,
        isChannelReady: var_isChannelReady,
        isUsable: var_isUsable,
        isPublic: var_isPublic,
        cltvExpiryDelta: var_cltvExpiryDelta,
        counterpartyUnspendablePunishmentReserve:
            var_counterpartyUnspendablePunishmentReserve,
        counterpartyOutboundHtlcMinimumMsat:
            var_counterpartyOutboundHtlcMinimumMsat,
        counterpartyOutboundHtlcMaximumMsat:
            var_counterpartyOutboundHtlcMaximumMsat,
        counterpartyForwardingInfoFeeBaseMsat:
            var_counterpartyForwardingInfoFeeBaseMsat,
        counterpartyForwardingInfoFeeProportionalMillionths:
            var_counterpartyForwardingInfoFeeProportionalMillionths,
        counterpartyForwardingInfoCltvExpiryDelta:
            var_counterpartyForwardingInfoCltvExpiryDelta,
        nextOutboundHtlcLimitMsat: var_nextOutboundHtlcLimitMsat,
        nextOutboundHtlcMinimumMsat: var_nextOutboundHtlcMinimumMsat,
        forceCloseSpendDelay: var_forceCloseSpendDelay,
        inboundHtlcMinimumMsat: var_inboundHtlcMinimumMsat,
        inboundHtlcMaximumMsat: var_inboundHtlcMaximumMsat,
        config: var_config);
  }

  @protected
  ChannelId sse_decode_channel_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_8_array_32(deserializer);
    return ChannelId(data: var_data);
  }

  @protected
  ChannelInfo sse_decode_channel_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_nodeOne = sse_decode_node_id(deserializer);
    var var_oneToTwo =
        sse_decode_opt_box_autoadd_channel_update_info(deserializer);
    var var_nodeTwo = sse_decode_node_id(deserializer);
    var var_twoToOne =
        sse_decode_opt_box_autoadd_channel_update_info(deserializer);
    var var_capacitySats = sse_decode_opt_box_autoadd_u_64(deserializer);
    return ChannelInfo(
        nodeOne: var_nodeOne,
        oneToTwo: var_oneToTwo,
        nodeTwo: var_nodeTwo,
        twoToOne: var_twoToOne,
        capacitySats: var_capacitySats);
  }

  @protected
  ChannelUpdateInfo sse_decode_channel_update_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_lastUpdate = sse_decode_u_32(deserializer);
    var var_enabled = sse_decode_bool(deserializer);
    var var_cltvExpiryDelta = sse_decode_u_16(deserializer);
    var var_htlcMinimumMsat = sse_decode_u_64(deserializer);
    var var_htlcMaximumMsat = sse_decode_u_64(deserializer);
    var var_fees = sse_decode_routing_fees(deserializer);
    return ChannelUpdateInfo(
        lastUpdate: var_lastUpdate,
        enabled: var_enabled,
        cltvExpiryDelta: var_cltvExpiryDelta,
        htlcMinimumMsat: var_htlcMinimumMsat,
        htlcMaximumMsat: var_htlcMaximumMsat,
        fees: var_fees);
  }

  @protected
  ClosureReason sse_decode_closure_reason(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_peerMsg = sse_decode_String(deserializer);
        return ClosureReason_CounterpartyForceClosed(peerMsg: var_peerMsg);
      case 1:
        return ClosureReason_HolderForceClosed();
      case 2:
        return ClosureReason_LegacyCooperativeClosure();
      case 3:
        return ClosureReason_CounterpartyInitiatedCooperativeClosure();
      case 4:
        return ClosureReason_LocallyInitiatedCooperativeClosure();
      case 5:
        return ClosureReason_CommitmentTxConfirmed();
      case 6:
        return ClosureReason_FundingTimedOut();
      case 7:
        var var_err = sse_decode_String(deserializer);
        return ClosureReason_ProcessingError(err: var_err);
      case 8:
        return ClosureReason_DisconnectedPeer();
      case 9:
        return ClosureReason_OutdatedChannelManager();
      case 10:
        return ClosureReason_CounterpartyCoopClosedUnfundedChannel();
      case 11:
        return ClosureReason_FundingBatchClosure();
      case 12:
        return ClosureReason_HTLCsTimedOut();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Config sse_decode_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_storageDirPath = sse_decode_String(deserializer);
    var var_logDirPath = sse_decode_opt_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_listeningAddresses =
        sse_decode_opt_list_socket_address(deserializer);
    var var_defaultCltvExpiryDelta = sse_decode_u_32(deserializer);
    var var_onchainWalletSyncIntervalSecs = sse_decode_u_64(deserializer);
    var var_walletSyncIntervalSecs = sse_decode_u_64(deserializer);
    var var_feeRateCacheUpdateIntervalSecs = sse_decode_u_64(deserializer);
    var var_trustedPeers0Conf = sse_decode_list_public_key(deserializer);
    var var_probingLiquidityLimitMultiplier = sse_decode_u_64(deserializer);
    var var_logLevel = sse_decode_log_level(deserializer);
    var var_anchorChannelsConfig =
        sse_decode_opt_box_autoadd_anchor_channels_config(deserializer);
    return Config(
        storageDirPath: var_storageDirPath,
        logDirPath: var_logDirPath,
        network: var_network,
        listeningAddresses: var_listeningAddresses,
        defaultCltvExpiryDelta: var_defaultCltvExpiryDelta,
        onchainWalletSyncIntervalSecs: var_onchainWalletSyncIntervalSecs,
        walletSyncIntervalSecs: var_walletSyncIntervalSecs,
        feeRateCacheUpdateIntervalSecs: var_feeRateCacheUpdateIntervalSecs,
        trustedPeers0Conf: var_trustedPeers0Conf,
        probingLiquidityLimitMultiplier: var_probingLiquidityLimitMultiplier,
        logLevel: var_logLevel,
        anchorChannelsConfig: var_anchorChannelsConfig);
  }

  @protected
  DecodeError sse_decode_decode_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return DecodeError_UnknownVersion();
      case 1:
        return DecodeError_UnknownRequiredFeature();
      case 2:
        return DecodeError_InvalidValue();
      case 3:
        return DecodeError_ShortRead();
      case 4:
        return DecodeError_BadLengthDescriptor();
      case 5:
        var var_field0 = sse_decode_String(deserializer);
        return DecodeError_Io(var_field0);
      case 6:
        return DecodeError_UnsupportedCompression();
      case 7:
        return DecodeError_DangerousValue();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  EntropySourceConfig sse_decode_entropy_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return EntropySourceConfig_SeedFile(var_field0);
      case 1:
        var var_field0 = sse_decode_u_8_array_64(deserializer);
        return EntropySourceConfig_SeedBytes(var_field0);
      case 2:
        var var_mnemonic = sse_decode_box_autoadd_ldk_mnemonic(deserializer);
        var var_passphrase = sse_decode_opt_String(deserializer);
        return EntropySourceConfig_Bip39Mnemonic(
            mnemonic: var_mnemonic, passphrase: var_passphrase);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Event sse_decode_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_paymentId = sse_decode_box_autoadd_payment_id(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_claimableAmountMsat = sse_decode_u_64(deserializer);
        var var_claimDeadline = sse_decode_opt_box_autoadd_u_32(deserializer);
        return Event_PaymentClaimable(
            paymentId: var_paymentId,
            paymentHash: var_paymentHash,
            claimableAmountMsat: var_claimableAmountMsat,
            claimDeadline: var_claimDeadline);
      case 1:
        var var_paymentId = sse_decode_opt_box_autoadd_payment_id(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_feePaidMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
        return Event_PaymentSuccessful(
            paymentId: var_paymentId,
            paymentHash: var_paymentHash,
            feePaidMsat: var_feePaidMsat);
      case 2:
        var var_paymentId = sse_decode_opt_box_autoadd_payment_id(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_reason =
            sse_decode_opt_box_autoadd_payment_failure_reason(deserializer);
        return Event_PaymentFailed(
            paymentId: var_paymentId,
            paymentHash: var_paymentHash,
            reason: var_reason);
      case 3:
        var var_paymentId = sse_decode_opt_box_autoadd_payment_id(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_amountMsat = sse_decode_u_64(deserializer);
        return Event_PaymentReceived(
            paymentId: var_paymentId,
            paymentHash: var_paymentHash,
            amountMsat: var_amountMsat);
      case 4:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_userChannelId =
            sse_decode_box_autoadd_user_channel_id(deserializer);
        var var_formerTemporaryChannelId =
            sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_fundingTxo = sse_decode_box_autoadd_out_point(deserializer);
        return Event_ChannelPending(
            channelId: var_channelId,
            userChannelId: var_userChannelId,
            formerTemporaryChannelId: var_formerTemporaryChannelId,
            counterpartyNodeId: var_counterpartyNodeId,
            fundingTxo: var_fundingTxo);
      case 5:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_userChannelId =
            sse_decode_box_autoadd_user_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_opt_box_autoadd_public_key(deserializer);
        return Event_ChannelReady(
            channelId: var_channelId,
            userChannelId: var_userChannelId,
            counterpartyNodeId: var_counterpartyNodeId);
      case 6:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_userChannelId =
            sse_decode_box_autoadd_user_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_opt_box_autoadd_public_key(deserializer);
        var var_reason =
            sse_decode_opt_box_autoadd_closure_reason(deserializer);
        return Event_ChannelClosed(
            channelId: var_channelId,
            userChannelId: var_userChannelId,
            counterpartyNodeId: var_counterpartyNodeId,
            reason: var_reason);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  GossipSourceConfig sse_decode_gossip_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return GossipSourceConfig_P2PNetwork();
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return GossipSourceConfig_RapidGossipSync(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  LdkBolt11Payment sse_decode_ldk_bolt_11_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr =
        sse_decode_RustOpaque_ldk_nodepaymentBolt11Payment(deserializer);
    return LdkBolt11Payment(ptr: var_ptr);
  }

  @protected
  LdkBolt12Payment sse_decode_ldk_bolt_12_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr =
        sse_decode_RustOpaque_Arcldk_nodepaymentBolt12Payment(deserializer);
    return LdkBolt12Payment(ptr: var_ptr);
  }

  @protected
  LdkBuilderError sse_decode_ldk_builder_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return LdkBuilderError.values[inner];
  }

  @protected
  LdkMnemonic sse_decode_ldk_mnemonic(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seedPhrase = sse_decode_String(deserializer);
    return LdkMnemonic(seedPhrase: var_seedPhrase);
  }

  @protected
  LdkNetworkGraph sse_decode_ldk_network_graph(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_ldk_nodegraphNetworkGraph(deserializer);
    return LdkNetworkGraph(ptr: var_ptr);
  }

  @protected
  LdkNode sse_decode_ldk_node(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr = sse_decode_RustOpaque_Node(deserializer);
    return LdkNode(ptr: var_ptr);
  }

  @protected
  LdkNodeError sse_decode_ldk_node_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return LdkNodeError_InvalidTxid();
      case 1:
        return LdkNodeError_AlreadyRunning();
      case 2:
        return LdkNodeError_NotRunning();
      case 3:
        return LdkNodeError_OnchainTxCreationFailed();
      case 4:
        return LdkNodeError_ConnectionFailed();
      case 5:
        return LdkNodeError_InvoiceCreationFailed();
      case 6:
        return LdkNodeError_PaymentSendingFailed();
      case 7:
        return LdkNodeError_ProbeSendingFailed();
      case 8:
        return LdkNodeError_ChannelCreationFailed();
      case 9:
        return LdkNodeError_ChannelClosingFailed();
      case 10:
        return LdkNodeError_ChannelConfigUpdateFailed();
      case 11:
        return LdkNodeError_PersistenceFailed();
      case 12:
        return LdkNodeError_WalletOperationFailed();
      case 13:
        return LdkNodeError_OnchainTxSigningFailed();
      case 14:
        return LdkNodeError_MessageSigningFailed();
      case 15:
        return LdkNodeError_TxSyncFailed();
      case 16:
        return LdkNodeError_GossipUpdateFailed();
      case 17:
        return LdkNodeError_InvalidAddress();
      case 18:
        return LdkNodeError_InvalidSocketAddress();
      case 19:
        return LdkNodeError_InvalidPublicKey();
      case 20:
        return LdkNodeError_InvalidSecretKey();
      case 21:
        return LdkNodeError_InvalidPaymentHash();
      case 22:
        return LdkNodeError_InvalidPaymentPreimage();
      case 23:
        return LdkNodeError_InvalidPaymentSecret();
      case 24:
        return LdkNodeError_InvalidAmount();
      case 25:
        return LdkNodeError_InvalidInvoice();
      case 26:
        return LdkNodeError_InvalidChannelId();
      case 27:
        return LdkNodeError_InvalidNetwork();
      case 28:
        return LdkNodeError_DuplicatePayment();
      case 29:
        return LdkNodeError_InsufficientFunds();
      case 30:
        return LdkNodeError_FeerateEstimationUpdateFailed();
      case 31:
        return LdkNodeError_LiquidityRequestFailed();
      case 32:
        return LdkNodeError_LiquiditySourceUnavailable();
      case 33:
        return LdkNodeError_LiquidityFeeTooHigh();
      case 34:
        return LdkNodeError_InvalidPaymentId();
      case 35:
        var var_field0 = sse_decode_box_autoadd_decode_error(deserializer);
        return LdkNodeError_Decode(var_field0);
      case 36:
        var var_field0 =
            sse_decode_box_autoadd_bolt_12_parse_error(deserializer);
        return LdkNodeError_Bolt12Parse(var_field0);
      case 37:
        return LdkNodeError_InvoiceRequestCreationFailed();
      case 38:
        return LdkNodeError_OfferCreationFailed();
      case 39:
        return LdkNodeError_RefundCreationFailed();
      case 40:
        return LdkNodeError_FeerateEstimationUpdateTimeout();
      case 41:
        return LdkNodeError_WalletOperationTimeout();
      case 42:
        return LdkNodeError_TxSyncTimeout();
      case 43:
        return LdkNodeError_GossipUpdateTimeout();
      case 44:
        return LdkNodeError_InvalidOfferId();
      case 45:
        return LdkNodeError_InvalidNodeId();
      case 46:
        return LdkNodeError_InvalidOffer();
      case 47:
        return LdkNodeError_InvalidRefund();
      case 48:
        return LdkNodeError_UnsupportedCurrency();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LdkOnChainPayment sse_decode_ldk_on_chain_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr =
        sse_decode_RustOpaque_ldk_nodepaymentOnchainPayment(deserializer);
    return LdkOnChainPayment(ptr: var_ptr);
  }

  @protected
  LdkSpontaneousPayment sse_decode_ldk_spontaneous_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ptr =
        sse_decode_RustOpaque_ldk_nodepaymentSpontaneousPayment(deserializer);
    return LdkSpontaneousPayment(ptr: var_ptr);
  }

  @protected
  LightningBalance sse_decode_lightning_balance(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        return LightningBalance_ClaimableOnChannelClose(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis);
      case 1:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        var var_confirmationHeight = sse_decode_u_32(deserializer);
        return LightningBalance_ClaimableAwaitingConfirmations(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis,
            confirmationHeight: var_confirmationHeight);
      case 2:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        var var_timeoutHeight = sse_decode_u_32(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_paymentPreimage =
            sse_decode_box_autoadd_payment_preimage(deserializer);
        return LightningBalance_ContentiousClaimable(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis,
            timeoutHeight: var_timeoutHeight,
            paymentHash: var_paymentHash,
            paymentPreimage: var_paymentPreimage);
      case 3:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        var var_claimableHeight = sse_decode_u_32(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        return LightningBalance_MaybeTimeoutClaimableHTLC(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis,
            claimableHeight: var_claimableHeight,
            paymentHash: var_paymentHash);
      case 4:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        var var_expiryHeight = sse_decode_u_32(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        return LightningBalance_MaybePreimageClaimableHTLC(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis,
            expiryHeight: var_expiryHeight,
            paymentHash: var_paymentHash);
      case 5:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        return LightningBalance_CounterpartyRevokedOutputClaimable(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LiquiditySourceConfig sse_decode_liquidity_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_lsps2Service =
        sse_decode_record_socket_address_public_key_opt_string(deserializer);
    return LiquiditySourceConfig(lsps2Service: var_lsps2Service);
  }

  @protected
  List<ChannelDetails> sse_decode_list_channel_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ChannelDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_channel_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<LightningBalance> sse_decode_list_lightning_balance(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LightningBalance>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_lightning_balance(deserializer));
    }
    return ans_;
  }

  @protected
  List<NodeId> sse_decode_list_node_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <NodeId>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_node_id(deserializer));
    }
    return ans_;
  }

  @protected
  List<PaymentDetails> sse_decode_list_payment_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PaymentDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_payment_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<PeerDetails> sse_decode_list_peer_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PeerDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_peer_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<PendingSweepBalance> sse_decode_list_pending_sweep_balance(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PendingSweepBalance>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_pending_sweep_balance(deserializer));
    }
    return ans_;
  }

  @protected
  Uint64List sse_decode_list_prim_u_64_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint64List(len_);
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<PublicKey> sse_decode_list_public_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PublicKey>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_public_key(deserializer));
    }
    return ans_;
  }

  @protected
  List<SocketAddress> sse_decode_list_socket_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SocketAddress>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_socket_address(deserializer));
    }
    return ans_;
  }

  @protected
  LogLevel sse_decode_log_level(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return LogLevel.values[inner];
  }

  @protected
  LSPFeeLimits sse_decode_lsp_fee_limits(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_maxTotalOpeningFeeMsat =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_maxProportionalOpeningFeePpmMsat =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    return LSPFeeLimits(
        maxTotalOpeningFeeMsat: var_maxTotalOpeningFeeMsat,
        maxProportionalOpeningFeePpmMsat: var_maxProportionalOpeningFeePpmMsat);
  }

  @protected
  MaxDustHTLCExposure sse_decode_max_dust_htlc_exposure(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_u_64(deserializer);
        return MaxDustHTLCExposure_FixedLimitMsat(var_field0);
      case 1:
        var var_field0 = sse_decode_u_64(deserializer);
        return MaxDustHTLCExposure_FeeRateMultiplier(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  NodeAnnouncementInfo sse_decode_node_announcement_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_lastUpdate = sse_decode_u_32(deserializer);
    var var_alias = sse_decode_String(deserializer);
    var var_addresses = sse_decode_list_socket_address(deserializer);
    return NodeAnnouncementInfo(
        lastUpdate: var_lastUpdate, alias: var_alias, addresses: var_addresses);
  }

  @protected
  NodeId sse_decode_node_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_compressed = sse_decode_list_prim_u_8_strict(deserializer);
    return NodeId(compressed: var_compressed);
  }

  @protected
  NodeInfo sse_decode_node_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_channels = sse_decode_list_prim_u_64_strict(deserializer);
    var var_announcementInfo =
        sse_decode_opt_box_autoadd_node_announcement_info(deserializer);
    return NodeInfo(
        channels: var_channels, announcementInfo: var_announcementInfo);
  }

  @protected
  NodeStatus sse_decode_node_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_isRunning = sse_decode_bool(deserializer);
    var var_isListening = sse_decode_bool(deserializer);
    var var_currentBestBlock = sse_decode_best_block(deserializer);
    var var_latestWalletSyncTimestamp =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_latestOnchainWalletSyncTimestamp =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_latestFeeRateCacheUpdateTimestamp =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_latestRgsSnapshotTimestamp =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_latestNodeAnnouncementBroadcastTimestamp =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    return NodeStatus(
        isRunning: var_isRunning,
        isListening: var_isListening,
        currentBestBlock: var_currentBestBlock,
        latestWalletSyncTimestamp: var_latestWalletSyncTimestamp,
        latestOnchainWalletSyncTimestamp: var_latestOnchainWalletSyncTimestamp,
        latestFeeRateCacheUpdateTimestamp:
            var_latestFeeRateCacheUpdateTimestamp,
        latestRgsSnapshotTimestamp: var_latestRgsSnapshotTimestamp,
        latestNodeAnnouncementBroadcastTimestamp:
            var_latestNodeAnnouncementBroadcastTimestamp);
  }

  @protected
  Offer sse_decode_offer(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_s = sse_decode_String(deserializer);
    return Offer(s: var_s);
  }

  @protected
  OfferId sse_decode_offer_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_8_array_32(deserializer);
    return OfferId(field0: var_field0);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  AnchorChannelsConfig? sse_decode_opt_box_autoadd_anchor_channels_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_anchor_channels_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ChainDataSourceConfig? sse_decode_opt_box_autoadd_chain_data_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_chain_data_source_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ChannelConfig? sse_decode_opt_box_autoadd_channel_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_channel_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ChannelId? sse_decode_opt_box_autoadd_channel_id(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_channel_id(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ChannelInfo? sse_decode_opt_box_autoadd_channel_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_channel_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ChannelUpdateInfo? sse_decode_opt_box_autoadd_channel_update_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_channel_update_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ClosureReason? sse_decode_opt_box_autoadd_closure_reason(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_closure_reason(deserializer));
    } else {
      return null;
    }
  }

  @protected
  EntropySourceConfig? sse_decode_opt_box_autoadd_entropy_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_entropy_source_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Event? sse_decode_opt_box_autoadd_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_event(deserializer));
    } else {
      return null;
    }
  }

  @protected
  GossipSourceConfig? sse_decode_opt_box_autoadd_gossip_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_gossip_source_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  LiquiditySourceConfig? sse_decode_opt_box_autoadd_liquidity_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_liquidity_source_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  MaxDustHTLCExposure? sse_decode_opt_box_autoadd_max_dust_htlc_exposure(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_max_dust_htlc_exposure(deserializer));
    } else {
      return null;
    }
  }

  @protected
  NodeAnnouncementInfo? sse_decode_opt_box_autoadd_node_announcement_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_node_announcement_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  NodeInfo? sse_decode_opt_box_autoadd_node_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_node_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OutPoint? sse_decode_opt_box_autoadd_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_out_point(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentDetails? sse_decode_opt_box_autoadd_payment_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_details(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentFailureReason? sse_decode_opt_box_autoadd_payment_failure_reason(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_failure_reason(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentHash? sse_decode_opt_box_autoadd_payment_hash(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_hash(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentId? sse_decode_opt_box_autoadd_payment_id(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_id(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentPreimage? sse_decode_opt_box_autoadd_payment_preimage(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_preimage(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentSecret? sse_decode_opt_box_autoadd_payment_secret(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_secret(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PublicKey? sse_decode_opt_box_autoadd_public_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_public_key(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_16(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<SocketAddress>? sse_decode_opt_list_socket_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_socket_address(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OutPoint sse_decode_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_txid(deserializer);
    var var_vout = sse_decode_u_32(deserializer);
    return OutPoint(txid: var_txid, vout: var_vout);
  }

  @protected
  PaymentDetails sse_decode_payment_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_payment_id(deserializer);
    var var_kind = sse_decode_payment_kind(deserializer);
    var var_amountMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_direction = sse_decode_payment_direction(deserializer);
    var var_status = sse_decode_payment_status(deserializer);
    var var_latestUpdateTimestamp = sse_decode_u_64(deserializer);
    return PaymentDetails(
        id: var_id,
        kind: var_kind,
        amountMsat: var_amountMsat,
        direction: var_direction,
        status: var_status,
        latestUpdateTimestamp: var_latestUpdateTimestamp);
  }

  @protected
  PaymentDirection sse_decode_payment_direction(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentDirection.values[inner];
  }

  @protected
  PaymentFailureReason sse_decode_payment_failure_reason(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentFailureReason.values[inner];
  }

  @protected
  PaymentHash sse_decode_payment_hash(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_8_array_32(deserializer);
    return PaymentHash(data: var_data);
  }

  @protected
  PaymentId sse_decode_payment_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_8_array_32(deserializer);
    return PaymentId(field0: var_field0);
  }

  @protected
  PaymentKind sse_decode_payment_kind(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return PaymentKind_Onchain();
      case 1:
        var var_hash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_preimage =
            sse_decode_opt_box_autoadd_payment_preimage(deserializer);
        var var_secret =
            sse_decode_opt_box_autoadd_payment_secret(deserializer);
        return PaymentKind_Bolt11(
            hash: var_hash, preimage: var_preimage, secret: var_secret);
      case 2:
        var var_hash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_preimage =
            sse_decode_opt_box_autoadd_payment_preimage(deserializer);
        var var_secret =
            sse_decode_opt_box_autoadd_payment_secret(deserializer);
        var var_lspFeeLimits =
            sse_decode_box_autoadd_lsp_fee_limits(deserializer);
        return PaymentKind_Bolt11Jit(
            hash: var_hash,
            preimage: var_preimage,
            secret: var_secret,
            lspFeeLimits: var_lspFeeLimits);
      case 3:
        var var_hash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_preimage =
            sse_decode_opt_box_autoadd_payment_preimage(deserializer);
        return PaymentKind_Spontaneous(hash: var_hash, preimage: var_preimage);
      case 4:
        var var_hash = sse_decode_opt_box_autoadd_payment_hash(deserializer);
        var var_preimage =
            sse_decode_opt_box_autoadd_payment_preimage(deserializer);
        var var_secret =
            sse_decode_opt_box_autoadd_payment_secret(deserializer);
        var var_offerId = sse_decode_box_autoadd_offer_id(deserializer);
        return PaymentKind_Bolt12Offer(
            hash: var_hash,
            preimage: var_preimage,
            secret: var_secret,
            offerId: var_offerId);
      case 5:
        var var_hash = sse_decode_opt_box_autoadd_payment_hash(deserializer);
        var var_preimage =
            sse_decode_opt_box_autoadd_payment_preimage(deserializer);
        var var_secret =
            sse_decode_opt_box_autoadd_payment_secret(deserializer);
        return PaymentKind_Bolt12Refund(
            hash: var_hash, preimage: var_preimage, secret: var_secret);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PaymentPreimage sse_decode_payment_preimage(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_8_array_32(deserializer);
    return PaymentPreimage(data: var_data);
  }

  @protected
  PaymentSecret sse_decode_payment_secret(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_8_array_32(deserializer);
    return PaymentSecret(data: var_data);
  }

  @protected
  PaymentStatus sse_decode_payment_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentStatus.values[inner];
  }

  @protected
  PeerDetails sse_decode_peer_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_nodeId = sse_decode_public_key(deserializer);
    var var_address = sse_decode_socket_address(deserializer);
    var var_isConnected = sse_decode_bool(deserializer);
    return PeerDetails(
        nodeId: var_nodeId, address: var_address, isConnected: var_isConnected);
  }

  @protected
  PendingSweepBalance sse_decode_pending_sweep_balance(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_channelId = sse_decode_opt_box_autoadd_channel_id(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        return PendingSweepBalance_PendingBroadcast(
            channelId: var_channelId, amountSatoshis: var_amountSatoshis);
      case 1:
        var var_channelId = sse_decode_opt_box_autoadd_channel_id(deserializer);
        var var_latestBroadcastHeight = sse_decode_u_32(deserializer);
        var var_latestSpendingTxid = sse_decode_box_autoadd_txid(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        return PendingSweepBalance_BroadcastAwaitingConfirmation(
            channelId: var_channelId,
            latestBroadcastHeight: var_latestBroadcastHeight,
            latestSpendingTxid: var_latestSpendingTxid,
            amountSatoshis: var_amountSatoshis);
      case 2:
        var var_channelId = sse_decode_opt_box_autoadd_channel_id(deserializer);
        var var_latestSpendingTxid = sse_decode_box_autoadd_txid(deserializer);
        var var_confirmationHash = sse_decode_String(deserializer);
        var var_confirmationHeight = sse_decode_u_32(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        return PendingSweepBalance_AwaitingThresholdConfirmations(
            channelId: var_channelId,
            latestSpendingTxid: var_latestSpendingTxid,
            confirmationHash: var_confirmationHash,
            confirmationHeight: var_confirmationHeight,
            amountSatoshis: var_amountSatoshis);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PublicKey sse_decode_public_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hex = sse_decode_String(deserializer);
    return PublicKey(hex: var_hex);
  }

  @protected
  (SocketAddress, PublicKey, String?)
      sse_decode_record_socket_address_public_key_opt_string(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_socket_address(deserializer);
    var var_field1 = sse_decode_public_key(deserializer);
    var var_field2 = sse_decode_opt_String(deserializer);
    return (var_field0, var_field1, var_field2);
  }

  @protected
  Refund sse_decode_refund(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_s = sse_decode_String(deserializer);
    return Refund(s: var_s);
  }

  @protected
  RoutingFees sse_decode_routing_fees(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_baseMsat = sse_decode_u_32(deserializer);
    var var_proportionalMillionths = sse_decode_u_32(deserializer);
    return RoutingFees(
        baseMsat: var_baseMsat,
        proportionalMillionths: var_proportionalMillionths);
  }

  @protected
  SocketAddress sse_decode_socket_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_addr = sse_decode_u_8_array_4(deserializer);
        var var_port = sse_decode_u_16(deserializer);
        return SocketAddress_TcpIpV4(addr: var_addr, port: var_port);
      case 1:
        var var_addr = sse_decode_u_8_array_16(deserializer);
        var var_port = sse_decode_u_16(deserializer);
        return SocketAddress_TcpIpV6(addr: var_addr, port: var_port);
      case 2:
        var var_field0 = sse_decode_u_8_array_12(deserializer);
        return SocketAddress_OnionV2(var_field0);
      case 3:
        var var_ed25519Pubkey = sse_decode_u_8_array_32(deserializer);
        var var_checksum = sse_decode_u_16(deserializer);
        var var_version = sse_decode_u_8(deserializer);
        var var_port = sse_decode_u_16(deserializer);
        return SocketAddress_OnionV3(
            ed25519Pubkey: var_ed25519Pubkey,
            checksum: var_checksum,
            version: var_version,
            port: var_port);
      case 4:
        var var_addr = sse_decode_String(deserializer);
        var var_port = sse_decode_u_16(deserializer);
        return SocketAddress_Hostname(addr: var_addr, port: var_port);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Txid sse_decode_txid(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hash = sse_decode_String(deserializer);
    return Txid(hash: var_hash);
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  U8Array12 sse_decode_u_8_array_12(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array12(inner);
  }

  @protected
  U8Array16 sse_decode_u_8_array_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array16(inner);
  }

  @protected
  U8Array32 sse_decode_u_8_array_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array32(inner);
  }

  @protected
  U8Array4 sse_decode_u_8_array_4(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array4(inner);
  }

  @protected
  U8Array64 sse_decode_u_8_array_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array64(inner);
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  UserChannelId sse_decode_user_channel_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_list_prim_u_8_strict(deserializer);
    return UserChannelId(data: var_data);
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
      NodeBuilder raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as NodeBuilderImpl).frbInternalCstEncode(move: true);
  }

  @protected
  int cst_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
      NodeBuilder raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as NodeBuilderImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
      NodeBuilder raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as NodeBuilderImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_RustOpaque_Arcldk_nodepaymentBolt12Payment(
      ArcBolt12Payment raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ArcBolt12PaymentImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_Node(Node raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as NodeImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
      NodeBuilder raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as NodeBuilderImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ldk_nodeBuilder(Builder raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as BuilderImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ldk_nodegraphNetworkGraph(NetworkGraph raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as NetworkGraphImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ldk_nodepaymentBolt11Payment(Bolt11Payment raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as Bolt11PaymentImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ldk_nodepaymentOnchainPayment(OnchainPayment raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as OnchainPaymentImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ldk_nodepaymentSpontaneousPayment(
      SpontaneousPayment raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as SpontaneousPaymentImpl).frbInternalCstEncode();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_ldk_builder_error(LdkBuilderError raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_log_level(LogLevel raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_network(Network raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_direction(PaymentDirection raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_failure_reason(PaymentFailureReason raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_status(PaymentStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_16(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
          NodeBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as NodeBuilderImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
          NodeBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as NodeBuilderImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
          NodeBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as NodeBuilderImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_Arcldk_nodepaymentBolt12Payment(
      ArcBolt12Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ArcBolt12PaymentImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_Node(Node self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as NodeImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNodeBuilder(
          NodeBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as NodeBuilderImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_ldk_nodeBuilder(
      Builder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as BuilderImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_ldk_nodegraphNetworkGraph(
      NetworkGraph self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as NetworkGraphImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_ldk_nodepaymentBolt11Payment(
      Bolt11Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as Bolt11PaymentImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_ldk_nodepaymentOnchainPayment(
      OnchainPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as OnchainPaymentImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_ldk_nodepaymentSpontaneousPayment(
      SpontaneousPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SpontaneousPaymentImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_address(Address self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.s, serializer);
  }

  @protected
  void sse_encode_anchor_channels_config(
      AnchorChannelsConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_public_key(self.trustedPeersNoReserve, serializer);
    sse_encode_u_64(self.perChannelReserveSats, serializer);
  }

  @protected
  void sse_encode_balance_details(
      BalanceDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.totalOnchainBalanceSats, serializer);
    sse_encode_u_64(self.spendableOnchainBalanceSats, serializer);
    sse_encode_u_64(self.totalLightningBalanceSats, serializer);
    sse_encode_list_lightning_balance(self.lightningBalances, serializer);
    sse_encode_list_pending_sweep_balance(
        self.pendingBalancesFromChannelClosures, serializer);
  }

  @protected
  void sse_encode_best_block(BestBlock self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.blockHash, serializer);
    sse_encode_u_32(self.height, serializer);
  }

  @protected
  void sse_encode_bolt_11_invoice(
      Bolt11Invoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.signedRawInvoice, serializer);
  }

  @protected
  void sse_encode_bolt_12_invoice(
      Bolt12Invoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.data, serializer);
  }

  @protected
  void sse_encode_bolt_12_parse_error(
      Bolt12ParseError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Bolt12ParseError_InvalidContinuation():
        sse_encode_i_32(0, serializer);
      case Bolt12ParseError_InvalidBech32Hrp():
        sse_encode_i_32(1, serializer);
      case Bolt12ParseError_Bech32(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_String(field0, serializer);
      case Bolt12ParseError_Decode(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_decode_error(field0, serializer);
      case Bolt12ParseError_InvalidSemantics(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_String(field0, serializer);
      case Bolt12ParseError_InvalidSignature(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_String(field0, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_address(Address self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_address(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_anchor_channels_config(
      AnchorChannelsConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_anchor_channels_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bolt_11_invoice(
      Bolt11Invoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bolt_11_invoice(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bolt_12_parse_error(
      Bolt12ParseError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bolt_12_parse_error(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_chain_data_source_config(
      ChainDataSourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_chain_data_source_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_channel_config(
      ChannelConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_channel_id(
      ChannelId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_id(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_channel_info(
      ChannelInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_channel_update_info(
      ChannelUpdateInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_update_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_closure_reason(
      ClosureReason self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_closure_reason(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_config(Config self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_decode_error(
      DecodeError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_decode_error(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_entropy_source_config(
      EntropySourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_entropy_source_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_event(Event self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_event(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_gossip_source_config(
      GossipSourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_gossip_source_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ldk_bolt_11_payment(
      LdkBolt11Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ldk_bolt_11_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ldk_bolt_12_payment(
      LdkBolt12Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ldk_bolt_12_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ldk_mnemonic(
      LdkMnemonic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ldk_mnemonic(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ldk_network_graph(
      LdkNetworkGraph self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ldk_network_graph(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ldk_node(LdkNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ldk_node(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ldk_on_chain_payment(
      LdkOnChainPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ldk_on_chain_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ldk_spontaneous_payment(
      LdkSpontaneousPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ldk_spontaneous_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_liquidity_source_config(
      LiquiditySourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_liquidity_source_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_lsp_fee_limits(
      LSPFeeLimits self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_lsp_fee_limits(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_max_dust_htlc_exposure(
      MaxDustHTLCExposure self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_max_dust_htlc_exposure(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_node_announcement_info(
      NodeAnnouncementInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_node_announcement_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_node_id(NodeId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_node_id(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_node_info(
      NodeInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_node_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_offer(Offer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_offer(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_offer_id(OfferId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_offer_id(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_out_point(
      OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_details(
      PaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_details(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_failure_reason(
      PaymentFailureReason self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_failure_reason(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_hash(
      PaymentHash self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_hash(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_id(
      PaymentId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_id(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_preimage(
      PaymentPreimage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_preimage(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_secret(
      PaymentSecret self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_secret(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_public_key(
      PublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_public_key(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_refund(Refund self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_refund(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_socket_address(
      SocketAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_socket_address(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_txid(Txid self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_txid(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_user_channel_id(
      UserChannelId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_user_channel_id(self, serializer);
  }

  @protected
  void sse_encode_chain_data_source_config(
      ChainDataSourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ChainDataSourceConfig_Esplora(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_channel_config(ChannelConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.forwardingFeeProportionalMillionths, serializer);
    sse_encode_u_32(self.forwardingFeeBaseMsat, serializer);
    sse_encode_u_16(self.cltvExpiryDelta, serializer);
    sse_encode_opt_box_autoadd_max_dust_htlc_exposure(
        self.maxDustHtlcExposure, serializer);
    sse_encode_u_64(self.forceCloseAvoidanceMaxFeeSatoshis, serializer);
    sse_encode_bool(self.acceptUnderpayingHtlcs, serializer);
  }

  @protected
  void sse_encode_channel_details(
      ChannelDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_id(self.channelId, serializer);
    sse_encode_public_key(self.counterpartyNodeId, serializer);
    sse_encode_opt_box_autoadd_out_point(self.fundingTxo, serializer);
    sse_encode_u_64(self.channelValueSats, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.unspendablePunishmentReserve, serializer);
    sse_encode_user_channel_id(self.userChannelId, serializer);
    sse_encode_u_32(self.feerateSatPer1000Weight, serializer);
    sse_encode_u_64(self.outboundCapacityMsat, serializer);
    sse_encode_u_64(self.inboundCapacityMsat, serializer);
    sse_encode_opt_box_autoadd_u_32(self.confirmationsRequired, serializer);
    sse_encode_opt_box_autoadd_u_32(self.confirmations, serializer);
    sse_encode_bool(self.isOutbound, serializer);
    sse_encode_bool(self.isChannelReady, serializer);
    sse_encode_bool(self.isUsable, serializer);
    sse_encode_bool(self.isPublic, serializer);
    sse_encode_opt_box_autoadd_u_16(self.cltvExpiryDelta, serializer);
    sse_encode_u_64(self.counterpartyUnspendablePunishmentReserve, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.counterpartyOutboundHtlcMinimumMsat, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.counterpartyOutboundHtlcMaximumMsat, serializer);
    sse_encode_opt_box_autoadd_u_32(
        self.counterpartyForwardingInfoFeeBaseMsat, serializer);
    sse_encode_opt_box_autoadd_u_32(
        self.counterpartyForwardingInfoFeeProportionalMillionths, serializer);
    sse_encode_opt_box_autoadd_u_16(
        self.counterpartyForwardingInfoCltvExpiryDelta, serializer);
    sse_encode_u_64(self.nextOutboundHtlcLimitMsat, serializer);
    sse_encode_u_64(self.nextOutboundHtlcMinimumMsat, serializer);
    sse_encode_opt_box_autoadd_u_16(self.forceCloseSpendDelay, serializer);
    sse_encode_u_64(self.inboundHtlcMinimumMsat, serializer);
    sse_encode_opt_box_autoadd_u_64(self.inboundHtlcMaximumMsat, serializer);
    sse_encode_channel_config(self.config, serializer);
  }

  @protected
  void sse_encode_channel_id(ChannelId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.data, serializer);
  }

  @protected
  void sse_encode_channel_info(ChannelInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_node_id(self.nodeOne, serializer);
    sse_encode_opt_box_autoadd_channel_update_info(self.oneToTwo, serializer);
    sse_encode_node_id(self.nodeTwo, serializer);
    sse_encode_opt_box_autoadd_channel_update_info(self.twoToOne, serializer);
    sse_encode_opt_box_autoadd_u_64(self.capacitySats, serializer);
  }

  @protected
  void sse_encode_channel_update_info(
      ChannelUpdateInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.lastUpdate, serializer);
    sse_encode_bool(self.enabled, serializer);
    sse_encode_u_16(self.cltvExpiryDelta, serializer);
    sse_encode_u_64(self.htlcMinimumMsat, serializer);
    sse_encode_u_64(self.htlcMaximumMsat, serializer);
    sse_encode_routing_fees(self.fees, serializer);
  }

  @protected
  void sse_encode_closure_reason(ClosureReason self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ClosureReason_CounterpartyForceClosed(peerMsg: final peerMsg):
        sse_encode_i_32(0, serializer);
        sse_encode_String(peerMsg, serializer);
      case ClosureReason_HolderForceClosed():
        sse_encode_i_32(1, serializer);
      case ClosureReason_LegacyCooperativeClosure():
        sse_encode_i_32(2, serializer);
      case ClosureReason_CounterpartyInitiatedCooperativeClosure():
        sse_encode_i_32(3, serializer);
      case ClosureReason_LocallyInitiatedCooperativeClosure():
        sse_encode_i_32(4, serializer);
      case ClosureReason_CommitmentTxConfirmed():
        sse_encode_i_32(5, serializer);
      case ClosureReason_FundingTimedOut():
        sse_encode_i_32(6, serializer);
      case ClosureReason_ProcessingError(err: final err):
        sse_encode_i_32(7, serializer);
        sse_encode_String(err, serializer);
      case ClosureReason_DisconnectedPeer():
        sse_encode_i_32(8, serializer);
      case ClosureReason_OutdatedChannelManager():
        sse_encode_i_32(9, serializer);
      case ClosureReason_CounterpartyCoopClosedUnfundedChannel():
        sse_encode_i_32(10, serializer);
      case ClosureReason_FundingBatchClosure():
        sse_encode_i_32(11, serializer);
      case ClosureReason_HTLCsTimedOut():
        sse_encode_i_32(12, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_config(Config self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.storageDirPath, serializer);
    sse_encode_opt_String(self.logDirPath, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_opt_list_socket_address(self.listeningAddresses, serializer);
    sse_encode_u_32(self.defaultCltvExpiryDelta, serializer);
    sse_encode_u_64(self.onchainWalletSyncIntervalSecs, serializer);
    sse_encode_u_64(self.walletSyncIntervalSecs, serializer);
    sse_encode_u_64(self.feeRateCacheUpdateIntervalSecs, serializer);
    sse_encode_list_public_key(self.trustedPeers0Conf, serializer);
    sse_encode_u_64(self.probingLiquidityLimitMultiplier, serializer);
    sse_encode_log_level(self.logLevel, serializer);
    sse_encode_opt_box_autoadd_anchor_channels_config(
        self.anchorChannelsConfig, serializer);
  }

  @protected
  void sse_encode_decode_error(DecodeError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case DecodeError_UnknownVersion():
        sse_encode_i_32(0, serializer);
      case DecodeError_UnknownRequiredFeature():
        sse_encode_i_32(1, serializer);
      case DecodeError_InvalidValue():
        sse_encode_i_32(2, serializer);
      case DecodeError_ShortRead():
        sse_encode_i_32(3, serializer);
      case DecodeError_BadLengthDescriptor():
        sse_encode_i_32(4, serializer);
      case DecodeError_Io(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_String(field0, serializer);
      case DecodeError_UnsupportedCompression():
        sse_encode_i_32(6, serializer);
      case DecodeError_DangerousValue():
        sse_encode_i_32(7, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_entropy_source_config(
      EntropySourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case EntropySourceConfig_SeedFile(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case EntropySourceConfig_SeedBytes(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_8_array_64(field0, serializer);
      case EntropySourceConfig_Bip39Mnemonic(
          mnemonic: final mnemonic,
          passphrase: final passphrase
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_ldk_mnemonic(mnemonic, serializer);
        sse_encode_opt_String(passphrase, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_event(Event self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Event_PaymentClaimable(
          paymentId: final paymentId,
          paymentHash: final paymentHash,
          claimableAmountMsat: final claimableAmountMsat,
          claimDeadline: final claimDeadline
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_payment_id(paymentId, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
        sse_encode_u_64(claimableAmountMsat, serializer);
        sse_encode_opt_box_autoadd_u_32(claimDeadline, serializer);
      case Event_PaymentSuccessful(
          paymentId: final paymentId,
          paymentHash: final paymentHash,
          feePaidMsat: final feePaidMsat
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_opt_box_autoadd_payment_id(paymentId, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
        sse_encode_opt_box_autoadd_u_64(feePaidMsat, serializer);
      case Event_PaymentFailed(
          paymentId: final paymentId,
          paymentHash: final paymentHash,
          reason: final reason
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_opt_box_autoadd_payment_id(paymentId, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
        sse_encode_opt_box_autoadd_payment_failure_reason(reason, serializer);
      case Event_PaymentReceived(
          paymentId: final paymentId,
          paymentHash: final paymentHash,
          amountMsat: final amountMsat
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_opt_box_autoadd_payment_id(paymentId, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
        sse_encode_u_64(amountMsat, serializer);
      case Event_ChannelPending(
          channelId: final channelId,
          userChannelId: final userChannelId,
          formerTemporaryChannelId: final formerTemporaryChannelId,
          counterpartyNodeId: final counterpartyNodeId,
          fundingTxo: final fundingTxo
        ):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_user_channel_id(userChannelId, serializer);
        sse_encode_box_autoadd_channel_id(formerTemporaryChannelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_box_autoadd_out_point(fundingTxo, serializer);
      case Event_ChannelReady(
          channelId: final channelId,
          userChannelId: final userChannelId,
          counterpartyNodeId: final counterpartyNodeId
        ):
        sse_encode_i_32(5, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_user_channel_id(userChannelId, serializer);
        sse_encode_opt_box_autoadd_public_key(counterpartyNodeId, serializer);
      case Event_ChannelClosed(
          channelId: final channelId,
          userChannelId: final userChannelId,
          counterpartyNodeId: final counterpartyNodeId,
          reason: final reason
        ):
        sse_encode_i_32(6, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_user_channel_id(userChannelId, serializer);
        sse_encode_opt_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_opt_box_autoadd_closure_reason(reason, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_gossip_source_config(
      GossipSourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case GossipSourceConfig_P2PNetwork():
        sse_encode_i_32(0, serializer);
      case GossipSourceConfig_RapidGossipSync(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_ldk_bolt_11_payment(
      LdkBolt11Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ldk_nodepaymentBolt11Payment(self.ptr, serializer);
  }

  @protected
  void sse_encode_ldk_bolt_12_payment(
      LdkBolt12Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_Arcldk_nodepaymentBolt12Payment(self.ptr, serializer);
  }

  @protected
  void sse_encode_ldk_builder_error(
      LdkBuilderError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_ldk_mnemonic(LdkMnemonic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.seedPhrase, serializer);
  }

  @protected
  void sse_encode_ldk_network_graph(
      LdkNetworkGraph self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ldk_nodegraphNetworkGraph(self.ptr, serializer);
  }

  @protected
  void sse_encode_ldk_node(LdkNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_Node(self.ptr, serializer);
  }

  @protected
  void sse_encode_ldk_node_error(LdkNodeError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LdkNodeError_InvalidTxid():
        sse_encode_i_32(0, serializer);
      case LdkNodeError_AlreadyRunning():
        sse_encode_i_32(1, serializer);
      case LdkNodeError_NotRunning():
        sse_encode_i_32(2, serializer);
      case LdkNodeError_OnchainTxCreationFailed():
        sse_encode_i_32(3, serializer);
      case LdkNodeError_ConnectionFailed():
        sse_encode_i_32(4, serializer);
      case LdkNodeError_InvoiceCreationFailed():
        sse_encode_i_32(5, serializer);
      case LdkNodeError_PaymentSendingFailed():
        sse_encode_i_32(6, serializer);
      case LdkNodeError_ProbeSendingFailed():
        sse_encode_i_32(7, serializer);
      case LdkNodeError_ChannelCreationFailed():
        sse_encode_i_32(8, serializer);
      case LdkNodeError_ChannelClosingFailed():
        sse_encode_i_32(9, serializer);
      case LdkNodeError_ChannelConfigUpdateFailed():
        sse_encode_i_32(10, serializer);
      case LdkNodeError_PersistenceFailed():
        sse_encode_i_32(11, serializer);
      case LdkNodeError_WalletOperationFailed():
        sse_encode_i_32(12, serializer);
      case LdkNodeError_OnchainTxSigningFailed():
        sse_encode_i_32(13, serializer);
      case LdkNodeError_MessageSigningFailed():
        sse_encode_i_32(14, serializer);
      case LdkNodeError_TxSyncFailed():
        sse_encode_i_32(15, serializer);
      case LdkNodeError_GossipUpdateFailed():
        sse_encode_i_32(16, serializer);
      case LdkNodeError_InvalidAddress():
        sse_encode_i_32(17, serializer);
      case LdkNodeError_InvalidSocketAddress():
        sse_encode_i_32(18, serializer);
      case LdkNodeError_InvalidPublicKey():
        sse_encode_i_32(19, serializer);
      case LdkNodeError_InvalidSecretKey():
        sse_encode_i_32(20, serializer);
      case LdkNodeError_InvalidPaymentHash():
        sse_encode_i_32(21, serializer);
      case LdkNodeError_InvalidPaymentPreimage():
        sse_encode_i_32(22, serializer);
      case LdkNodeError_InvalidPaymentSecret():
        sse_encode_i_32(23, serializer);
      case LdkNodeError_InvalidAmount():
        sse_encode_i_32(24, serializer);
      case LdkNodeError_InvalidInvoice():
        sse_encode_i_32(25, serializer);
      case LdkNodeError_InvalidChannelId():
        sse_encode_i_32(26, serializer);
      case LdkNodeError_InvalidNetwork():
        sse_encode_i_32(27, serializer);
      case LdkNodeError_DuplicatePayment():
        sse_encode_i_32(28, serializer);
      case LdkNodeError_InsufficientFunds():
        sse_encode_i_32(29, serializer);
      case LdkNodeError_FeerateEstimationUpdateFailed():
        sse_encode_i_32(30, serializer);
      case LdkNodeError_LiquidityRequestFailed():
        sse_encode_i_32(31, serializer);
      case LdkNodeError_LiquiditySourceUnavailable():
        sse_encode_i_32(32, serializer);
      case LdkNodeError_LiquidityFeeTooHigh():
        sse_encode_i_32(33, serializer);
      case LdkNodeError_InvalidPaymentId():
        sse_encode_i_32(34, serializer);
      case LdkNodeError_Decode(field0: final field0):
        sse_encode_i_32(35, serializer);
        sse_encode_box_autoadd_decode_error(field0, serializer);
      case LdkNodeError_Bolt12Parse(field0: final field0):
        sse_encode_i_32(36, serializer);
        sse_encode_box_autoadd_bolt_12_parse_error(field0, serializer);
      case LdkNodeError_InvoiceRequestCreationFailed():
        sse_encode_i_32(37, serializer);
      case LdkNodeError_OfferCreationFailed():
        sse_encode_i_32(38, serializer);
      case LdkNodeError_RefundCreationFailed():
        sse_encode_i_32(39, serializer);
      case LdkNodeError_FeerateEstimationUpdateTimeout():
        sse_encode_i_32(40, serializer);
      case LdkNodeError_WalletOperationTimeout():
        sse_encode_i_32(41, serializer);
      case LdkNodeError_TxSyncTimeout():
        sse_encode_i_32(42, serializer);
      case LdkNodeError_GossipUpdateTimeout():
        sse_encode_i_32(43, serializer);
      case LdkNodeError_InvalidOfferId():
        sse_encode_i_32(44, serializer);
      case LdkNodeError_InvalidNodeId():
        sse_encode_i_32(45, serializer);
      case LdkNodeError_InvalidOffer():
        sse_encode_i_32(46, serializer);
      case LdkNodeError_InvalidRefund():
        sse_encode_i_32(47, serializer);
      case LdkNodeError_UnsupportedCurrency():
        sse_encode_i_32(48, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_ldk_on_chain_payment(
      LdkOnChainPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ldk_nodepaymentOnchainPayment(self.ptr, serializer);
  }

  @protected
  void sse_encode_ldk_spontaneous_payment(
      LdkSpontaneousPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ldk_nodepaymentSpontaneousPayment(
        self.ptr, serializer);
  }

  @protected
  void sse_encode_lightning_balance(
      LightningBalance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LightningBalance_ClaimableOnChannelClose(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
      case LightningBalance_ClaimableAwaitingConfirmations(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis,
          confirmationHeight: final confirmationHeight
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
        sse_encode_u_32(confirmationHeight, serializer);
      case LightningBalance_ContentiousClaimable(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis,
          timeoutHeight: final timeoutHeight,
          paymentHash: final paymentHash,
          paymentPreimage: final paymentPreimage
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
        sse_encode_u_32(timeoutHeight, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
        sse_encode_box_autoadd_payment_preimage(paymentPreimage, serializer);
      case LightningBalance_MaybeTimeoutClaimableHTLC(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis,
          claimableHeight: final claimableHeight,
          paymentHash: final paymentHash
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
        sse_encode_u_32(claimableHeight, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
      case LightningBalance_MaybePreimageClaimableHTLC(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis,
          expiryHeight: final expiryHeight,
          paymentHash: final paymentHash
        ):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
        sse_encode_u_32(expiryHeight, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
      case LightningBalance_CounterpartyRevokedOutputClaimable(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis
        ):
        sse_encode_i_32(5, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_liquidity_source_config(
      LiquiditySourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_record_socket_address_public_key_opt_string(
        self.lsps2Service, serializer);
  }

  @protected
  void sse_encode_list_channel_details(
      List<ChannelDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_channel_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_lightning_balance(
      List<LightningBalance> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_lightning_balance(item, serializer);
    }
  }

  @protected
  void sse_encode_list_node_id(List<NodeId> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_node_id(item, serializer);
    }
  }

  @protected
  void sse_encode_list_payment_details(
      List<PaymentDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_payment_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_peer_details(
      List<PeerDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_peer_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_pending_sweep_balance(
      List<PendingSweepBalance> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_pending_sweep_balance(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_64_strict(
      Uint64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint64List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_public_key(
      List<PublicKey> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_public_key(item, serializer);
    }
  }

  @protected
  void sse_encode_list_socket_address(
      List<SocketAddress> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_socket_address(item, serializer);
    }
  }

  @protected
  void sse_encode_log_level(LogLevel self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_lsp_fee_limits(LSPFeeLimits self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_64(self.maxTotalOpeningFeeMsat, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.maxProportionalOpeningFeePpmMsat, serializer);
  }

  @protected
  void sse_encode_max_dust_htlc_exposure(
      MaxDustHTLCExposure self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case MaxDustHTLCExposure_FixedLimitMsat(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_u_64(field0, serializer);
      case MaxDustHTLCExposure_FeeRateMultiplier(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_64(field0, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_node_announcement_info(
      NodeAnnouncementInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.lastUpdate, serializer);
    sse_encode_String(self.alias, serializer);
    sse_encode_list_socket_address(self.addresses, serializer);
  }

  @protected
  void sse_encode_node_id(NodeId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.compressed, serializer);
  }

  @protected
  void sse_encode_node_info(NodeInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_64_strict(self.channels, serializer);
    sse_encode_opt_box_autoadd_node_announcement_info(
        self.announcementInfo, serializer);
  }

  @protected
  void sse_encode_node_status(NodeStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.isRunning, serializer);
    sse_encode_bool(self.isListening, serializer);
    sse_encode_best_block(self.currentBestBlock, serializer);
    sse_encode_opt_box_autoadd_u_64(self.latestWalletSyncTimestamp, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.latestOnchainWalletSyncTimestamp, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.latestFeeRateCacheUpdateTimestamp, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.latestRgsSnapshotTimestamp, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.latestNodeAnnouncementBroadcastTimestamp, serializer);
  }

  @protected
  void sse_encode_offer(Offer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.s, serializer);
  }

  @protected
  void sse_encode_offer_id(OfferId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.field0, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_anchor_channels_config(
      AnchorChannelsConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_anchor_channels_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_chain_data_source_config(
      ChainDataSourceConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_chain_data_source_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_channel_config(
      ChannelConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_channel_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_channel_id(
      ChannelId? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_channel_id(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_channel_info(
      ChannelInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_channel_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_channel_update_info(
      ChannelUpdateInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_channel_update_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_closure_reason(
      ClosureReason? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_closure_reason(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_entropy_source_config(
      EntropySourceConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_entropy_source_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_event(Event? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_event(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_gossip_source_config(
      GossipSourceConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_gossip_source_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_liquidity_source_config(
      LiquiditySourceConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_liquidity_source_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_max_dust_htlc_exposure(
      MaxDustHTLCExposure? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_max_dust_htlc_exposure(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_node_announcement_info(
      NodeAnnouncementInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_node_announcement_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_node_info(
      NodeInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_node_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_out_point(
      OutPoint? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_out_point(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_details(
      PaymentDetails? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_details(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_failure_reason(
      PaymentFailureReason? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_failure_reason(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_hash(
      PaymentHash? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_hash(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_id(
      PaymentId? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_id(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_preimage(
      PaymentPreimage? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_preimage(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_secret(
      PaymentSecret? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_secret(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_public_key(
      PublicKey? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_public_key(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_16(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_16(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_socket_address(
      List<SocketAddress>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_socket_address(self, serializer);
    }
  }

  @protected
  void sse_encode_out_point(OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_txid(self.txid, serializer);
    sse_encode_u_32(self.vout, serializer);
  }

  @protected
  void sse_encode_payment_details(
      PaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_id(self.id, serializer);
    sse_encode_payment_kind(self.kind, serializer);
    sse_encode_opt_box_autoadd_u_64(self.amountMsat, serializer);
    sse_encode_payment_direction(self.direction, serializer);
    sse_encode_payment_status(self.status, serializer);
    sse_encode_u_64(self.latestUpdateTimestamp, serializer);
  }

  @protected
  void sse_encode_payment_direction(
      PaymentDirection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_payment_failure_reason(
      PaymentFailureReason self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_payment_hash(PaymentHash self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.data, serializer);
  }

  @protected
  void sse_encode_payment_id(PaymentId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.field0, serializer);
  }

  @protected
  void sse_encode_payment_kind(PaymentKind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PaymentKind_Onchain():
        sse_encode_i_32(0, serializer);
      case PaymentKind_Bolt11(
          hash: final hash,
          preimage: final preimage,
          secret: final secret
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_payment_hash(hash, serializer);
        sse_encode_opt_box_autoadd_payment_preimage(preimage, serializer);
        sse_encode_opt_box_autoadd_payment_secret(secret, serializer);
      case PaymentKind_Bolt11Jit(
          hash: final hash,
          preimage: final preimage,
          secret: final secret,
          lspFeeLimits: final lspFeeLimits
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_payment_hash(hash, serializer);
        sse_encode_opt_box_autoadd_payment_preimage(preimage, serializer);
        sse_encode_opt_box_autoadd_payment_secret(secret, serializer);
        sse_encode_box_autoadd_lsp_fee_limits(lspFeeLimits, serializer);
      case PaymentKind_Spontaneous(hash: final hash, preimage: final preimage):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_payment_hash(hash, serializer);
        sse_encode_opt_box_autoadd_payment_preimage(preimage, serializer);
      case PaymentKind_Bolt12Offer(
          hash: final hash,
          preimage: final preimage,
          secret: final secret,
          offerId: final offerId
        ):
        sse_encode_i_32(4, serializer);
        sse_encode_opt_box_autoadd_payment_hash(hash, serializer);
        sse_encode_opt_box_autoadd_payment_preimage(preimage, serializer);
        sse_encode_opt_box_autoadd_payment_secret(secret, serializer);
        sse_encode_box_autoadd_offer_id(offerId, serializer);
      case PaymentKind_Bolt12Refund(
          hash: final hash,
          preimage: final preimage,
          secret: final secret
        ):
        sse_encode_i_32(5, serializer);
        sse_encode_opt_box_autoadd_payment_hash(hash, serializer);
        sse_encode_opt_box_autoadd_payment_preimage(preimage, serializer);
        sse_encode_opt_box_autoadd_payment_secret(secret, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_payment_preimage(
      PaymentPreimage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.data, serializer);
  }

  @protected
  void sse_encode_payment_secret(PaymentSecret self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.data, serializer);
  }

  @protected
  void sse_encode_payment_status(PaymentStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_peer_details(PeerDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_public_key(self.nodeId, serializer);
    sse_encode_socket_address(self.address, serializer);
    sse_encode_bool(self.isConnected, serializer);
  }

  @protected
  void sse_encode_pending_sweep_balance(
      PendingSweepBalance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PendingSweepBalance_PendingBroadcast(
          channelId: final channelId,
          amountSatoshis: final amountSatoshis
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_box_autoadd_channel_id(channelId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
      case PendingSweepBalance_BroadcastAwaitingConfirmation(
          channelId: final channelId,
          latestBroadcastHeight: final latestBroadcastHeight,
          latestSpendingTxid: final latestSpendingTxid,
          amountSatoshis: final amountSatoshis
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_opt_box_autoadd_channel_id(channelId, serializer);
        sse_encode_u_32(latestBroadcastHeight, serializer);
        sse_encode_box_autoadd_txid(latestSpendingTxid, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
      case PendingSweepBalance_AwaitingThresholdConfirmations(
          channelId: final channelId,
          latestSpendingTxid: final latestSpendingTxid,
          confirmationHash: final confirmationHash,
          confirmationHeight: final confirmationHeight,
          amountSatoshis: final amountSatoshis
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_opt_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_txid(latestSpendingTxid, serializer);
        sse_encode_String(confirmationHash, serializer);
        sse_encode_u_32(confirmationHeight, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_public_key(PublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.hex, serializer);
  }

  @protected
  void sse_encode_record_socket_address_public_key_opt_string(
      (SocketAddress, PublicKey, String?) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_socket_address(self.$1, serializer);
    sse_encode_public_key(self.$2, serializer);
    sse_encode_opt_String(self.$3, serializer);
  }

  @protected
  void sse_encode_refund(Refund self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.s, serializer);
  }

  @protected
  void sse_encode_routing_fees(RoutingFees self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.baseMsat, serializer);
    sse_encode_u_32(self.proportionalMillionths, serializer);
  }

  @protected
  void sse_encode_socket_address(SocketAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SocketAddress_TcpIpV4(addr: final addr, port: final port):
        sse_encode_i_32(0, serializer);
        sse_encode_u_8_array_4(addr, serializer);
        sse_encode_u_16(port, serializer);
      case SocketAddress_TcpIpV6(addr: final addr, port: final port):
        sse_encode_i_32(1, serializer);
        sse_encode_u_8_array_16(addr, serializer);
        sse_encode_u_16(port, serializer);
      case SocketAddress_OnionV2(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_u_8_array_12(field0, serializer);
      case SocketAddress_OnionV3(
          ed25519Pubkey: final ed25519Pubkey,
          checksum: final checksum,
          version: final version,
          port: final port
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_u_8_array_32(ed25519Pubkey, serializer);
        sse_encode_u_16(checksum, serializer);
        sse_encode_u_8(version, serializer);
        sse_encode_u_16(port, serializer);
      case SocketAddress_Hostname(addr: final addr, port: final port):
        sse_encode_i_32(4, serializer);
        sse_encode_String(addr, serializer);
        sse_encode_u_16(port, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_txid(Txid self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.hash, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_u_8_array_12(U8Array12 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_8_array_16(U8Array16 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_8_array_32(U8Array32 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_8_array_4(U8Array4 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_8_array_64(U8Array64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_user_channel_id(
      UserChannelId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.data, serializer);
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}

@sealed
class ArcBolt12PaymentImpl extends RustOpaque implements ArcBolt12Payment {
  // Not to be used by end users
  ArcBolt12PaymentImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ArcBolt12PaymentImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_ArcBolt12Payment,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_ArcBolt12Payment,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_ArcBolt12PaymentPtr,
  );
}

@sealed
class Bolt11PaymentImpl extends RustOpaque implements Bolt11Payment {
  // Not to be used by end users
  Bolt11PaymentImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  Bolt11PaymentImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_Bolt11Payment,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_Bolt11Payment,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_Bolt11PaymentPtr,
  );
}

@sealed
class BuilderImpl extends RustOpaque implements Builder {
  // Not to be used by end users
  BuilderImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  BuilderImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_Builder,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_Builder,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_BuilderPtr,
  );
}

@sealed
class NetworkGraphImpl extends RustOpaque implements NetworkGraph {
  // Not to be used by end users
  NetworkGraphImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  NetworkGraphImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_NetworkGraph,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_NetworkGraph,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_NetworkGraphPtr,
  );
}

@sealed
class NodeBuilderImpl extends RustOpaque implements NodeBuilder {
  // Not to be used by end users
  NodeBuilderImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  NodeBuilderImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_NodeBuilder,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_NodeBuilder,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_NodeBuilderPtr,
  );

  Builder get builder =>
      core.instance.api.crateApiBuilderNodeBuilderAutoAccessorGetBuilder(
        that: this,
      );

  void set builder(Builder builder) =>
      core.instance.api.crateApiBuilderNodeBuilderAutoAccessorSetBuilder(
          that: this, builder: builder);

  Future<LdkNode> build() => core.instance.api.crateApiBuilderNodeBuilderBuild(
        that: this,
      );

  Future<LdkNode> buildWithFsStore() =>
      core.instance.api.crateApiBuilderNodeBuilderBuildWithFsStore(
        that: this,
      );
}

@sealed
class NodeImpl extends RustOpaque implements Node {
  // Not to be used by end users
  NodeImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  NodeImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_Node,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_Node,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_NodePtr,
  );
}

@sealed
class OnchainPaymentImpl extends RustOpaque implements OnchainPayment {
  // Not to be used by end users
  OnchainPaymentImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  OnchainPaymentImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_OnchainPayment,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_OnchainPayment,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_OnchainPaymentPtr,
  );
}

@sealed
class SpontaneousPaymentImpl extends RustOpaque implements SpontaneousPayment {
  // Not to be used by end users
  SpontaneousPaymentImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SpontaneousPaymentImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_SpontaneousPayment,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_SpontaneousPayment,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_SpontaneousPaymentPtr,
  );
}
