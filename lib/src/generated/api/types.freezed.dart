// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'types.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ChainDataSourceConfig {
  String get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) esplora,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? esplora,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? esplora,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChainDataSourceConfig_Esplora value) esplora,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChainDataSourceConfig_Esplora value)? esplora,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChainDataSourceConfig_Esplora value)? esplora,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ChainDataSourceConfigCopyWith<ChainDataSourceConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChainDataSourceConfigCopyWith<$Res> {
  factory $ChainDataSourceConfigCopyWith(ChainDataSourceConfig value,
          $Res Function(ChainDataSourceConfig) then) =
      _$ChainDataSourceConfigCopyWithImpl<$Res, ChainDataSourceConfig>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class _$ChainDataSourceConfigCopyWithImpl<$Res,
        $Val extends ChainDataSourceConfig>
    implements $ChainDataSourceConfigCopyWith<$Res> {
  _$ChainDataSourceConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_value.copyWith(
      field0: null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChainDataSourceConfig_EsploraImplCopyWith<$Res>
    implements $ChainDataSourceConfigCopyWith<$Res> {
  factory _$$ChainDataSourceConfig_EsploraImplCopyWith(
          _$ChainDataSourceConfig_EsploraImpl value,
          $Res Function(_$ChainDataSourceConfig_EsploraImpl) then) =
      __$$ChainDataSourceConfig_EsploraImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$ChainDataSourceConfig_EsploraImplCopyWithImpl<$Res>
    extends _$ChainDataSourceConfigCopyWithImpl<$Res,
        _$ChainDataSourceConfig_EsploraImpl>
    implements _$$ChainDataSourceConfig_EsploraImplCopyWith<$Res> {
  __$$ChainDataSourceConfig_EsploraImplCopyWithImpl(
      _$ChainDataSourceConfig_EsploraImpl _value,
      $Res Function(_$ChainDataSourceConfig_EsploraImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$ChainDataSourceConfig_EsploraImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ChainDataSourceConfig_EsploraImpl
    extends ChainDataSourceConfig_Esplora {
  const _$ChainDataSourceConfig_EsploraImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'ChainDataSourceConfig.esplora(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChainDataSourceConfig_EsploraImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChainDataSourceConfig_EsploraImplCopyWith<
          _$ChainDataSourceConfig_EsploraImpl>
      get copyWith => __$$ChainDataSourceConfig_EsploraImplCopyWithImpl<
          _$ChainDataSourceConfig_EsploraImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) esplora,
  }) {
    return esplora(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? esplora,
  }) {
    return esplora?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? esplora,
    required TResult orElse(),
  }) {
    if (esplora != null) {
      return esplora(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChainDataSourceConfig_Esplora value) esplora,
  }) {
    return esplora(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChainDataSourceConfig_Esplora value)? esplora,
  }) {
    return esplora?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChainDataSourceConfig_Esplora value)? esplora,
    required TResult orElse(),
  }) {
    if (esplora != null) {
      return esplora(this);
    }
    return orElse();
  }
}

abstract class ChainDataSourceConfig_Esplora extends ChainDataSourceConfig {
  const factory ChainDataSourceConfig_Esplora(final String field0) =
      _$ChainDataSourceConfig_EsploraImpl;
  const ChainDataSourceConfig_Esplora._() : super._();

  @override
  String get field0;
  @override
  @JsonKey(ignore: true)
  _$$ChainDataSourceConfig_EsploraImplCopyWith<
          _$ChainDataSourceConfig_EsploraImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ClosureReason {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() legacyCooperativeClosure,
    required TResult Function() counterpartyInitiatedCooperativeClosure,
    required TResult Function() locallyInitiatedCooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
    required TResult Function() htlCsTimedOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? legacyCooperativeClosure,
    TResult? Function()? counterpartyInitiatedCooperativeClosure,
    TResult? Function()? locallyInitiatedCooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
    TResult? Function()? htlCsTimedOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? legacyCooperativeClosure,
    TResult Function()? counterpartyInitiatedCooperativeClosure,
    TResult Function()? locallyInitiatedCooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    TResult Function()? htlCsTimedOut,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_LegacyCooperativeClosure value)
        legacyCooperativeClosure,
    required TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)
        counterpartyInitiatedCooperativeClosure,
    required TResult Function(
            ClosureReason_LocallyInitiatedCooperativeClosure value)
        locallyInitiatedCooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
    required TResult Function(ClosureReason_HTLCsTimedOut value) htlCsTimedOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult? Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult? Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClosureReasonCopyWith<$Res> {
  factory $ClosureReasonCopyWith(
          ClosureReason value, $Res Function(ClosureReason) then) =
      _$ClosureReasonCopyWithImpl<$Res, ClosureReason>;
}

/// @nodoc
class _$ClosureReasonCopyWithImpl<$Res, $Val extends ClosureReason>
    implements $ClosureReasonCopyWith<$Res> {
  _$ClosureReasonCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ClosureReason_CounterpartyForceClosedImplCopyWith<$Res> {
  factory _$$ClosureReason_CounterpartyForceClosedImplCopyWith(
          _$ClosureReason_CounterpartyForceClosedImpl value,
          $Res Function(_$ClosureReason_CounterpartyForceClosedImpl) then) =
      __$$ClosureReason_CounterpartyForceClosedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String peerMsg});
}

/// @nodoc
class __$$ClosureReason_CounterpartyForceClosedImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_CounterpartyForceClosedImpl>
    implements _$$ClosureReason_CounterpartyForceClosedImplCopyWith<$Res> {
  __$$ClosureReason_CounterpartyForceClosedImplCopyWithImpl(
      _$ClosureReason_CounterpartyForceClosedImpl _value,
      $Res Function(_$ClosureReason_CounterpartyForceClosedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? peerMsg = null,
  }) {
    return _then(_$ClosureReason_CounterpartyForceClosedImpl(
      peerMsg: null == peerMsg
          ? _value.peerMsg
          : peerMsg // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ClosureReason_CounterpartyForceClosedImpl
    extends ClosureReason_CounterpartyForceClosed {
  const _$ClosureReason_CounterpartyForceClosedImpl({required this.peerMsg})
      : super._();

  /// The error which the peer sent us.
  ///
  /// Be careful about printing the peer_msg, a well-crafted message could exploit
  /// a security vulnerability in the terminal emulator or the logging subsystem.
  /// To be safe, use `Display` on `UntrustedString`
  ///
  /// [`UntrustedString`]: crate::util::string::UntrustedString
  @override
  final String peerMsg;

  @override
  String toString() {
    return 'ClosureReason.counterpartyForceClosed(peerMsg: $peerMsg)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_CounterpartyForceClosedImpl &&
            (identical(other.peerMsg, peerMsg) || other.peerMsg == peerMsg));
  }

  @override
  int get hashCode => Object.hash(runtimeType, peerMsg);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ClosureReason_CounterpartyForceClosedImplCopyWith<
          _$ClosureReason_CounterpartyForceClosedImpl>
      get copyWith => __$$ClosureReason_CounterpartyForceClosedImplCopyWithImpl<
          _$ClosureReason_CounterpartyForceClosedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() legacyCooperativeClosure,
    required TResult Function() counterpartyInitiatedCooperativeClosure,
    required TResult Function() locallyInitiatedCooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
    required TResult Function() htlCsTimedOut,
  }) {
    return counterpartyForceClosed(peerMsg);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? legacyCooperativeClosure,
    TResult? Function()? counterpartyInitiatedCooperativeClosure,
    TResult? Function()? locallyInitiatedCooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
    TResult? Function()? htlCsTimedOut,
  }) {
    return counterpartyForceClosed?.call(peerMsg);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? legacyCooperativeClosure,
    TResult Function()? counterpartyInitiatedCooperativeClosure,
    TResult Function()? locallyInitiatedCooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    TResult Function()? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (counterpartyForceClosed != null) {
      return counterpartyForceClosed(peerMsg);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_LegacyCooperativeClosure value)
        legacyCooperativeClosure,
    required TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)
        counterpartyInitiatedCooperativeClosure,
    required TResult Function(
            ClosureReason_LocallyInitiatedCooperativeClosure value)
        locallyInitiatedCooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
    required TResult Function(ClosureReason_HTLCsTimedOut value) htlCsTimedOut,
  }) {
    return counterpartyForceClosed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult? Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult? Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
  }) {
    return counterpartyForceClosed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (counterpartyForceClosed != null) {
      return counterpartyForceClosed(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_CounterpartyForceClosed extends ClosureReason {
  const factory ClosureReason_CounterpartyForceClosed(
          {required final String peerMsg}) =
      _$ClosureReason_CounterpartyForceClosedImpl;
  const ClosureReason_CounterpartyForceClosed._() : super._();

  /// The error which the peer sent us.
  ///
  /// Be careful about printing the peer_msg, a well-crafted message could exploit
  /// a security vulnerability in the terminal emulator or the logging subsystem.
  /// To be safe, use `Display` on `UntrustedString`
  ///
  /// [`UntrustedString`]: crate::util::string::UntrustedString
  String get peerMsg;
  @JsonKey(ignore: true)
  _$$ClosureReason_CounterpartyForceClosedImplCopyWith<
          _$ClosureReason_CounterpartyForceClosedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ClosureReason_HolderForceClosedImplCopyWith<$Res> {
  factory _$$ClosureReason_HolderForceClosedImplCopyWith(
          _$ClosureReason_HolderForceClosedImpl value,
          $Res Function(_$ClosureReason_HolderForceClosedImpl) then) =
      __$$ClosureReason_HolderForceClosedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosureReason_HolderForceClosedImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_HolderForceClosedImpl>
    implements _$$ClosureReason_HolderForceClosedImplCopyWith<$Res> {
  __$$ClosureReason_HolderForceClosedImplCopyWithImpl(
      _$ClosureReason_HolderForceClosedImpl _value,
      $Res Function(_$ClosureReason_HolderForceClosedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_HolderForceClosedImpl
    extends ClosureReason_HolderForceClosed {
  const _$ClosureReason_HolderForceClosedImpl() : super._();

  @override
  String toString() {
    return 'ClosureReason.holderForceClosed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_HolderForceClosedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() legacyCooperativeClosure,
    required TResult Function() counterpartyInitiatedCooperativeClosure,
    required TResult Function() locallyInitiatedCooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
    required TResult Function() htlCsTimedOut,
  }) {
    return holderForceClosed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? legacyCooperativeClosure,
    TResult? Function()? counterpartyInitiatedCooperativeClosure,
    TResult? Function()? locallyInitiatedCooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
    TResult? Function()? htlCsTimedOut,
  }) {
    return holderForceClosed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? legacyCooperativeClosure,
    TResult Function()? counterpartyInitiatedCooperativeClosure,
    TResult Function()? locallyInitiatedCooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    TResult Function()? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (holderForceClosed != null) {
      return holderForceClosed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_LegacyCooperativeClosure value)
        legacyCooperativeClosure,
    required TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)
        counterpartyInitiatedCooperativeClosure,
    required TResult Function(
            ClosureReason_LocallyInitiatedCooperativeClosure value)
        locallyInitiatedCooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
    required TResult Function(ClosureReason_HTLCsTimedOut value) htlCsTimedOut,
  }) {
    return holderForceClosed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult? Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult? Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
  }) {
    return holderForceClosed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (holderForceClosed != null) {
      return holderForceClosed(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_HolderForceClosed extends ClosureReason {
  const factory ClosureReason_HolderForceClosed() =
      _$ClosureReason_HolderForceClosedImpl;
  const ClosureReason_HolderForceClosed._() : super._();
}

/// @nodoc
abstract class _$$ClosureReason_LegacyCooperativeClosureImplCopyWith<$Res> {
  factory _$$ClosureReason_LegacyCooperativeClosureImplCopyWith(
          _$ClosureReason_LegacyCooperativeClosureImpl value,
          $Res Function(_$ClosureReason_LegacyCooperativeClosureImpl) then) =
      __$$ClosureReason_LegacyCooperativeClosureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosureReason_LegacyCooperativeClosureImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_LegacyCooperativeClosureImpl>
    implements _$$ClosureReason_LegacyCooperativeClosureImplCopyWith<$Res> {
  __$$ClosureReason_LegacyCooperativeClosureImplCopyWithImpl(
      _$ClosureReason_LegacyCooperativeClosureImpl _value,
      $Res Function(_$ClosureReason_LegacyCooperativeClosureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_LegacyCooperativeClosureImpl
    extends ClosureReason_LegacyCooperativeClosure {
  const _$ClosureReason_LegacyCooperativeClosureImpl() : super._();

  @override
  String toString() {
    return 'ClosureReason.legacyCooperativeClosure()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_LegacyCooperativeClosureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() legacyCooperativeClosure,
    required TResult Function() counterpartyInitiatedCooperativeClosure,
    required TResult Function() locallyInitiatedCooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
    required TResult Function() htlCsTimedOut,
  }) {
    return legacyCooperativeClosure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? legacyCooperativeClosure,
    TResult? Function()? counterpartyInitiatedCooperativeClosure,
    TResult? Function()? locallyInitiatedCooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
    TResult? Function()? htlCsTimedOut,
  }) {
    return legacyCooperativeClosure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? legacyCooperativeClosure,
    TResult Function()? counterpartyInitiatedCooperativeClosure,
    TResult Function()? locallyInitiatedCooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    TResult Function()? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (legacyCooperativeClosure != null) {
      return legacyCooperativeClosure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_LegacyCooperativeClosure value)
        legacyCooperativeClosure,
    required TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)
        counterpartyInitiatedCooperativeClosure,
    required TResult Function(
            ClosureReason_LocallyInitiatedCooperativeClosure value)
        locallyInitiatedCooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
    required TResult Function(ClosureReason_HTLCsTimedOut value) htlCsTimedOut,
  }) {
    return legacyCooperativeClosure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult? Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult? Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
  }) {
    return legacyCooperativeClosure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (legacyCooperativeClosure != null) {
      return legacyCooperativeClosure(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_LegacyCooperativeClosure extends ClosureReason {
  const factory ClosureReason_LegacyCooperativeClosure() =
      _$ClosureReason_LegacyCooperativeClosureImpl;
  const ClosureReason_LegacyCooperativeClosure._() : super._();
}

/// @nodoc
abstract class _$$ClosureReason_CounterpartyInitiatedCooperativeClosureImplCopyWith<
    $Res> {
  factory _$$ClosureReason_CounterpartyInitiatedCooperativeClosureImplCopyWith(
          _$ClosureReason_CounterpartyInitiatedCooperativeClosureImpl value,
          $Res Function(
                  _$ClosureReason_CounterpartyInitiatedCooperativeClosureImpl)
              then) =
      __$$ClosureReason_CounterpartyInitiatedCooperativeClosureImplCopyWithImpl<
          $Res>;
}

/// @nodoc
class __$$ClosureReason_CounterpartyInitiatedCooperativeClosureImplCopyWithImpl<
        $Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_CounterpartyInitiatedCooperativeClosureImpl>
    implements
        _$$ClosureReason_CounterpartyInitiatedCooperativeClosureImplCopyWith<
            $Res> {
  __$$ClosureReason_CounterpartyInitiatedCooperativeClosureImplCopyWithImpl(
      _$ClosureReason_CounterpartyInitiatedCooperativeClosureImpl _value,
      $Res Function(_$ClosureReason_CounterpartyInitiatedCooperativeClosureImpl)
          _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_CounterpartyInitiatedCooperativeClosureImpl
    extends ClosureReason_CounterpartyInitiatedCooperativeClosure {
  const _$ClosureReason_CounterpartyInitiatedCooperativeClosureImpl()
      : super._();

  @override
  String toString() {
    return 'ClosureReason.counterpartyInitiatedCooperativeClosure()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$ClosureReason_CounterpartyInitiatedCooperativeClosureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() legacyCooperativeClosure,
    required TResult Function() counterpartyInitiatedCooperativeClosure,
    required TResult Function() locallyInitiatedCooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
    required TResult Function() htlCsTimedOut,
  }) {
    return counterpartyInitiatedCooperativeClosure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? legacyCooperativeClosure,
    TResult? Function()? counterpartyInitiatedCooperativeClosure,
    TResult? Function()? locallyInitiatedCooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
    TResult? Function()? htlCsTimedOut,
  }) {
    return counterpartyInitiatedCooperativeClosure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? legacyCooperativeClosure,
    TResult Function()? counterpartyInitiatedCooperativeClosure,
    TResult Function()? locallyInitiatedCooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    TResult Function()? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (counterpartyInitiatedCooperativeClosure != null) {
      return counterpartyInitiatedCooperativeClosure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_LegacyCooperativeClosure value)
        legacyCooperativeClosure,
    required TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)
        counterpartyInitiatedCooperativeClosure,
    required TResult Function(
            ClosureReason_LocallyInitiatedCooperativeClosure value)
        locallyInitiatedCooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
    required TResult Function(ClosureReason_HTLCsTimedOut value) htlCsTimedOut,
  }) {
    return counterpartyInitiatedCooperativeClosure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult? Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult? Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
  }) {
    return counterpartyInitiatedCooperativeClosure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (counterpartyInitiatedCooperativeClosure != null) {
      return counterpartyInitiatedCooperativeClosure(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_CounterpartyInitiatedCooperativeClosure
    extends ClosureReason {
  const factory ClosureReason_CounterpartyInitiatedCooperativeClosure() =
      _$ClosureReason_CounterpartyInitiatedCooperativeClosureImpl;
  const ClosureReason_CounterpartyInitiatedCooperativeClosure._() : super._();
}

/// @nodoc
abstract class _$$ClosureReason_LocallyInitiatedCooperativeClosureImplCopyWith<
    $Res> {
  factory _$$ClosureReason_LocallyInitiatedCooperativeClosureImplCopyWith(
          _$ClosureReason_LocallyInitiatedCooperativeClosureImpl value,
          $Res Function(_$ClosureReason_LocallyInitiatedCooperativeClosureImpl)
              then) =
      __$$ClosureReason_LocallyInitiatedCooperativeClosureImplCopyWithImpl<
          $Res>;
}

/// @nodoc
class __$$ClosureReason_LocallyInitiatedCooperativeClosureImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_LocallyInitiatedCooperativeClosureImpl>
    implements
        _$$ClosureReason_LocallyInitiatedCooperativeClosureImplCopyWith<$Res> {
  __$$ClosureReason_LocallyInitiatedCooperativeClosureImplCopyWithImpl(
      _$ClosureReason_LocallyInitiatedCooperativeClosureImpl _value,
      $Res Function(_$ClosureReason_LocallyInitiatedCooperativeClosureImpl)
          _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_LocallyInitiatedCooperativeClosureImpl
    extends ClosureReason_LocallyInitiatedCooperativeClosure {
  const _$ClosureReason_LocallyInitiatedCooperativeClosureImpl() : super._();

  @override
  String toString() {
    return 'ClosureReason.locallyInitiatedCooperativeClosure()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_LocallyInitiatedCooperativeClosureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() legacyCooperativeClosure,
    required TResult Function() counterpartyInitiatedCooperativeClosure,
    required TResult Function() locallyInitiatedCooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
    required TResult Function() htlCsTimedOut,
  }) {
    return locallyInitiatedCooperativeClosure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? legacyCooperativeClosure,
    TResult? Function()? counterpartyInitiatedCooperativeClosure,
    TResult? Function()? locallyInitiatedCooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
    TResult? Function()? htlCsTimedOut,
  }) {
    return locallyInitiatedCooperativeClosure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? legacyCooperativeClosure,
    TResult Function()? counterpartyInitiatedCooperativeClosure,
    TResult Function()? locallyInitiatedCooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    TResult Function()? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (locallyInitiatedCooperativeClosure != null) {
      return locallyInitiatedCooperativeClosure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_LegacyCooperativeClosure value)
        legacyCooperativeClosure,
    required TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)
        counterpartyInitiatedCooperativeClosure,
    required TResult Function(
            ClosureReason_LocallyInitiatedCooperativeClosure value)
        locallyInitiatedCooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
    required TResult Function(ClosureReason_HTLCsTimedOut value) htlCsTimedOut,
  }) {
    return locallyInitiatedCooperativeClosure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult? Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult? Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
  }) {
    return locallyInitiatedCooperativeClosure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (locallyInitiatedCooperativeClosure != null) {
      return locallyInitiatedCooperativeClosure(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_LocallyInitiatedCooperativeClosure
    extends ClosureReason {
  const factory ClosureReason_LocallyInitiatedCooperativeClosure() =
      _$ClosureReason_LocallyInitiatedCooperativeClosureImpl;
  const ClosureReason_LocallyInitiatedCooperativeClosure._() : super._();
}

/// @nodoc
abstract class _$$ClosureReason_CommitmentTxConfirmedImplCopyWith<$Res> {
  factory _$$ClosureReason_CommitmentTxConfirmedImplCopyWith(
          _$ClosureReason_CommitmentTxConfirmedImpl value,
          $Res Function(_$ClosureReason_CommitmentTxConfirmedImpl) then) =
      __$$ClosureReason_CommitmentTxConfirmedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosureReason_CommitmentTxConfirmedImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_CommitmentTxConfirmedImpl>
    implements _$$ClosureReason_CommitmentTxConfirmedImplCopyWith<$Res> {
  __$$ClosureReason_CommitmentTxConfirmedImplCopyWithImpl(
      _$ClosureReason_CommitmentTxConfirmedImpl _value,
      $Res Function(_$ClosureReason_CommitmentTxConfirmedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_CommitmentTxConfirmedImpl
    extends ClosureReason_CommitmentTxConfirmed {
  const _$ClosureReason_CommitmentTxConfirmedImpl() : super._();

  @override
  String toString() {
    return 'ClosureReason.commitmentTxConfirmed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_CommitmentTxConfirmedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() legacyCooperativeClosure,
    required TResult Function() counterpartyInitiatedCooperativeClosure,
    required TResult Function() locallyInitiatedCooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
    required TResult Function() htlCsTimedOut,
  }) {
    return commitmentTxConfirmed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? legacyCooperativeClosure,
    TResult? Function()? counterpartyInitiatedCooperativeClosure,
    TResult? Function()? locallyInitiatedCooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
    TResult? Function()? htlCsTimedOut,
  }) {
    return commitmentTxConfirmed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? legacyCooperativeClosure,
    TResult Function()? counterpartyInitiatedCooperativeClosure,
    TResult Function()? locallyInitiatedCooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    TResult Function()? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (commitmentTxConfirmed != null) {
      return commitmentTxConfirmed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_LegacyCooperativeClosure value)
        legacyCooperativeClosure,
    required TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)
        counterpartyInitiatedCooperativeClosure,
    required TResult Function(
            ClosureReason_LocallyInitiatedCooperativeClosure value)
        locallyInitiatedCooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
    required TResult Function(ClosureReason_HTLCsTimedOut value) htlCsTimedOut,
  }) {
    return commitmentTxConfirmed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult? Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult? Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
  }) {
    return commitmentTxConfirmed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (commitmentTxConfirmed != null) {
      return commitmentTxConfirmed(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_CommitmentTxConfirmed extends ClosureReason {
  const factory ClosureReason_CommitmentTxConfirmed() =
      _$ClosureReason_CommitmentTxConfirmedImpl;
  const ClosureReason_CommitmentTxConfirmed._() : super._();
}

/// @nodoc
abstract class _$$ClosureReason_FundingTimedOutImplCopyWith<$Res> {
  factory _$$ClosureReason_FundingTimedOutImplCopyWith(
          _$ClosureReason_FundingTimedOutImpl value,
          $Res Function(_$ClosureReason_FundingTimedOutImpl) then) =
      __$$ClosureReason_FundingTimedOutImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosureReason_FundingTimedOutImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_FundingTimedOutImpl>
    implements _$$ClosureReason_FundingTimedOutImplCopyWith<$Res> {
  __$$ClosureReason_FundingTimedOutImplCopyWithImpl(
      _$ClosureReason_FundingTimedOutImpl _value,
      $Res Function(_$ClosureReason_FundingTimedOutImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_FundingTimedOutImpl
    extends ClosureReason_FundingTimedOut {
  const _$ClosureReason_FundingTimedOutImpl() : super._();

  @override
  String toString() {
    return 'ClosureReason.fundingTimedOut()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_FundingTimedOutImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() legacyCooperativeClosure,
    required TResult Function() counterpartyInitiatedCooperativeClosure,
    required TResult Function() locallyInitiatedCooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
    required TResult Function() htlCsTimedOut,
  }) {
    return fundingTimedOut();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? legacyCooperativeClosure,
    TResult? Function()? counterpartyInitiatedCooperativeClosure,
    TResult? Function()? locallyInitiatedCooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
    TResult? Function()? htlCsTimedOut,
  }) {
    return fundingTimedOut?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? legacyCooperativeClosure,
    TResult Function()? counterpartyInitiatedCooperativeClosure,
    TResult Function()? locallyInitiatedCooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    TResult Function()? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (fundingTimedOut != null) {
      return fundingTimedOut();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_LegacyCooperativeClosure value)
        legacyCooperativeClosure,
    required TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)
        counterpartyInitiatedCooperativeClosure,
    required TResult Function(
            ClosureReason_LocallyInitiatedCooperativeClosure value)
        locallyInitiatedCooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
    required TResult Function(ClosureReason_HTLCsTimedOut value) htlCsTimedOut,
  }) {
    return fundingTimedOut(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult? Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult? Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
  }) {
    return fundingTimedOut?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (fundingTimedOut != null) {
      return fundingTimedOut(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_FundingTimedOut extends ClosureReason {
  const factory ClosureReason_FundingTimedOut() =
      _$ClosureReason_FundingTimedOutImpl;
  const ClosureReason_FundingTimedOut._() : super._();
}

/// @nodoc
abstract class _$$ClosureReason_ProcessingErrorImplCopyWith<$Res> {
  factory _$$ClosureReason_ProcessingErrorImplCopyWith(
          _$ClosureReason_ProcessingErrorImpl value,
          $Res Function(_$ClosureReason_ProcessingErrorImpl) then) =
      __$$ClosureReason_ProcessingErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String err});
}

/// @nodoc
class __$$ClosureReason_ProcessingErrorImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_ProcessingErrorImpl>
    implements _$$ClosureReason_ProcessingErrorImplCopyWith<$Res> {
  __$$ClosureReason_ProcessingErrorImplCopyWithImpl(
      _$ClosureReason_ProcessingErrorImpl _value,
      $Res Function(_$ClosureReason_ProcessingErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? err = null,
  }) {
    return _then(_$ClosureReason_ProcessingErrorImpl(
      err: null == err
          ? _value.err
          : err // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ClosureReason_ProcessingErrorImpl
    extends ClosureReason_ProcessingError {
  const _$ClosureReason_ProcessingErrorImpl({required this.err}) : super._();

  /// A developer-readable error message which we generated.
  @override
  final String err;

  @override
  String toString() {
    return 'ClosureReason.processingError(err: $err)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_ProcessingErrorImpl &&
            (identical(other.err, err) || other.err == err));
  }

  @override
  int get hashCode => Object.hash(runtimeType, err);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ClosureReason_ProcessingErrorImplCopyWith<
          _$ClosureReason_ProcessingErrorImpl>
      get copyWith => __$$ClosureReason_ProcessingErrorImplCopyWithImpl<
          _$ClosureReason_ProcessingErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() legacyCooperativeClosure,
    required TResult Function() counterpartyInitiatedCooperativeClosure,
    required TResult Function() locallyInitiatedCooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
    required TResult Function() htlCsTimedOut,
  }) {
    return processingError(err);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? legacyCooperativeClosure,
    TResult? Function()? counterpartyInitiatedCooperativeClosure,
    TResult? Function()? locallyInitiatedCooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
    TResult? Function()? htlCsTimedOut,
  }) {
    return processingError?.call(err);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? legacyCooperativeClosure,
    TResult Function()? counterpartyInitiatedCooperativeClosure,
    TResult Function()? locallyInitiatedCooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    TResult Function()? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (processingError != null) {
      return processingError(err);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_LegacyCooperativeClosure value)
        legacyCooperativeClosure,
    required TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)
        counterpartyInitiatedCooperativeClosure,
    required TResult Function(
            ClosureReason_LocallyInitiatedCooperativeClosure value)
        locallyInitiatedCooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
    required TResult Function(ClosureReason_HTLCsTimedOut value) htlCsTimedOut,
  }) {
    return processingError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult? Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult? Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
  }) {
    return processingError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (processingError != null) {
      return processingError(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_ProcessingError extends ClosureReason {
  const factory ClosureReason_ProcessingError({required final String err}) =
      _$ClosureReason_ProcessingErrorImpl;
  const ClosureReason_ProcessingError._() : super._();

  /// A developer-readable error message which we generated.
  String get err;
  @JsonKey(ignore: true)
  _$$ClosureReason_ProcessingErrorImplCopyWith<
          _$ClosureReason_ProcessingErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ClosureReason_DisconnectedPeerImplCopyWith<$Res> {
  factory _$$ClosureReason_DisconnectedPeerImplCopyWith(
          _$ClosureReason_DisconnectedPeerImpl value,
          $Res Function(_$ClosureReason_DisconnectedPeerImpl) then) =
      __$$ClosureReason_DisconnectedPeerImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosureReason_DisconnectedPeerImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_DisconnectedPeerImpl>
    implements _$$ClosureReason_DisconnectedPeerImplCopyWith<$Res> {
  __$$ClosureReason_DisconnectedPeerImplCopyWithImpl(
      _$ClosureReason_DisconnectedPeerImpl _value,
      $Res Function(_$ClosureReason_DisconnectedPeerImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_DisconnectedPeerImpl
    extends ClosureReason_DisconnectedPeer {
  const _$ClosureReason_DisconnectedPeerImpl() : super._();

  @override
  String toString() {
    return 'ClosureReason.disconnectedPeer()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_DisconnectedPeerImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() legacyCooperativeClosure,
    required TResult Function() counterpartyInitiatedCooperativeClosure,
    required TResult Function() locallyInitiatedCooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
    required TResult Function() htlCsTimedOut,
  }) {
    return disconnectedPeer();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? legacyCooperativeClosure,
    TResult? Function()? counterpartyInitiatedCooperativeClosure,
    TResult? Function()? locallyInitiatedCooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
    TResult? Function()? htlCsTimedOut,
  }) {
    return disconnectedPeer?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? legacyCooperativeClosure,
    TResult Function()? counterpartyInitiatedCooperativeClosure,
    TResult Function()? locallyInitiatedCooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    TResult Function()? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (disconnectedPeer != null) {
      return disconnectedPeer();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_LegacyCooperativeClosure value)
        legacyCooperativeClosure,
    required TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)
        counterpartyInitiatedCooperativeClosure,
    required TResult Function(
            ClosureReason_LocallyInitiatedCooperativeClosure value)
        locallyInitiatedCooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
    required TResult Function(ClosureReason_HTLCsTimedOut value) htlCsTimedOut,
  }) {
    return disconnectedPeer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult? Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult? Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
  }) {
    return disconnectedPeer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (disconnectedPeer != null) {
      return disconnectedPeer(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_DisconnectedPeer extends ClosureReason {
  const factory ClosureReason_DisconnectedPeer() =
      _$ClosureReason_DisconnectedPeerImpl;
  const ClosureReason_DisconnectedPeer._() : super._();
}

/// @nodoc
abstract class _$$ClosureReason_OutdatedChannelManagerImplCopyWith<$Res> {
  factory _$$ClosureReason_OutdatedChannelManagerImplCopyWith(
          _$ClosureReason_OutdatedChannelManagerImpl value,
          $Res Function(_$ClosureReason_OutdatedChannelManagerImpl) then) =
      __$$ClosureReason_OutdatedChannelManagerImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosureReason_OutdatedChannelManagerImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_OutdatedChannelManagerImpl>
    implements _$$ClosureReason_OutdatedChannelManagerImplCopyWith<$Res> {
  __$$ClosureReason_OutdatedChannelManagerImplCopyWithImpl(
      _$ClosureReason_OutdatedChannelManagerImpl _value,
      $Res Function(_$ClosureReason_OutdatedChannelManagerImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_OutdatedChannelManagerImpl
    extends ClosureReason_OutdatedChannelManager {
  const _$ClosureReason_OutdatedChannelManagerImpl() : super._();

  @override
  String toString() {
    return 'ClosureReason.outdatedChannelManager()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_OutdatedChannelManagerImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() legacyCooperativeClosure,
    required TResult Function() counterpartyInitiatedCooperativeClosure,
    required TResult Function() locallyInitiatedCooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
    required TResult Function() htlCsTimedOut,
  }) {
    return outdatedChannelManager();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? legacyCooperativeClosure,
    TResult? Function()? counterpartyInitiatedCooperativeClosure,
    TResult? Function()? locallyInitiatedCooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
    TResult? Function()? htlCsTimedOut,
  }) {
    return outdatedChannelManager?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? legacyCooperativeClosure,
    TResult Function()? counterpartyInitiatedCooperativeClosure,
    TResult Function()? locallyInitiatedCooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    TResult Function()? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (outdatedChannelManager != null) {
      return outdatedChannelManager();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_LegacyCooperativeClosure value)
        legacyCooperativeClosure,
    required TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)
        counterpartyInitiatedCooperativeClosure,
    required TResult Function(
            ClosureReason_LocallyInitiatedCooperativeClosure value)
        locallyInitiatedCooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
    required TResult Function(ClosureReason_HTLCsTimedOut value) htlCsTimedOut,
  }) {
    return outdatedChannelManager(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult? Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult? Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
  }) {
    return outdatedChannelManager?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (outdatedChannelManager != null) {
      return outdatedChannelManager(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_OutdatedChannelManager extends ClosureReason {
  const factory ClosureReason_OutdatedChannelManager() =
      _$ClosureReason_OutdatedChannelManagerImpl;
  const ClosureReason_OutdatedChannelManager._() : super._();
}

/// @nodoc
abstract class _$$ClosureReason_CounterpartyCoopClosedUnfundedChannelImplCopyWith<
    $Res> {
  factory _$$ClosureReason_CounterpartyCoopClosedUnfundedChannelImplCopyWith(
          _$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl value,
          $Res Function(
                  _$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl)
              then) =
      __$$ClosureReason_CounterpartyCoopClosedUnfundedChannelImplCopyWithImpl<
          $Res>;
}

/// @nodoc
class __$$ClosureReason_CounterpartyCoopClosedUnfundedChannelImplCopyWithImpl<
        $Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl>
    implements
        _$$ClosureReason_CounterpartyCoopClosedUnfundedChannelImplCopyWith<
            $Res> {
  __$$ClosureReason_CounterpartyCoopClosedUnfundedChannelImplCopyWithImpl(
      _$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl _value,
      $Res Function(_$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl)
          _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl
    extends ClosureReason_CounterpartyCoopClosedUnfundedChannel {
  const _$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl() : super._();

  @override
  String toString() {
    return 'ClosureReason.counterpartyCoopClosedUnfundedChannel()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() legacyCooperativeClosure,
    required TResult Function() counterpartyInitiatedCooperativeClosure,
    required TResult Function() locallyInitiatedCooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
    required TResult Function() htlCsTimedOut,
  }) {
    return counterpartyCoopClosedUnfundedChannel();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? legacyCooperativeClosure,
    TResult? Function()? counterpartyInitiatedCooperativeClosure,
    TResult? Function()? locallyInitiatedCooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
    TResult? Function()? htlCsTimedOut,
  }) {
    return counterpartyCoopClosedUnfundedChannel?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? legacyCooperativeClosure,
    TResult Function()? counterpartyInitiatedCooperativeClosure,
    TResult Function()? locallyInitiatedCooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    TResult Function()? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (counterpartyCoopClosedUnfundedChannel != null) {
      return counterpartyCoopClosedUnfundedChannel();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_LegacyCooperativeClosure value)
        legacyCooperativeClosure,
    required TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)
        counterpartyInitiatedCooperativeClosure,
    required TResult Function(
            ClosureReason_LocallyInitiatedCooperativeClosure value)
        locallyInitiatedCooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
    required TResult Function(ClosureReason_HTLCsTimedOut value) htlCsTimedOut,
  }) {
    return counterpartyCoopClosedUnfundedChannel(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult? Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult? Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
  }) {
    return counterpartyCoopClosedUnfundedChannel?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (counterpartyCoopClosedUnfundedChannel != null) {
      return counterpartyCoopClosedUnfundedChannel(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_CounterpartyCoopClosedUnfundedChannel
    extends ClosureReason {
  const factory ClosureReason_CounterpartyCoopClosedUnfundedChannel() =
      _$ClosureReason_CounterpartyCoopClosedUnfundedChannelImpl;
  const ClosureReason_CounterpartyCoopClosedUnfundedChannel._() : super._();
}

/// @nodoc
abstract class _$$ClosureReason_FundingBatchClosureImplCopyWith<$Res> {
  factory _$$ClosureReason_FundingBatchClosureImplCopyWith(
          _$ClosureReason_FundingBatchClosureImpl value,
          $Res Function(_$ClosureReason_FundingBatchClosureImpl) then) =
      __$$ClosureReason_FundingBatchClosureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosureReason_FundingBatchClosureImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res,
        _$ClosureReason_FundingBatchClosureImpl>
    implements _$$ClosureReason_FundingBatchClosureImplCopyWith<$Res> {
  __$$ClosureReason_FundingBatchClosureImplCopyWithImpl(
      _$ClosureReason_FundingBatchClosureImpl _value,
      $Res Function(_$ClosureReason_FundingBatchClosureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_FundingBatchClosureImpl
    extends ClosureReason_FundingBatchClosure {
  const _$ClosureReason_FundingBatchClosureImpl() : super._();

  @override
  String toString() {
    return 'ClosureReason.fundingBatchClosure()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_FundingBatchClosureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() legacyCooperativeClosure,
    required TResult Function() counterpartyInitiatedCooperativeClosure,
    required TResult Function() locallyInitiatedCooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
    required TResult Function() htlCsTimedOut,
  }) {
    return fundingBatchClosure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? legacyCooperativeClosure,
    TResult? Function()? counterpartyInitiatedCooperativeClosure,
    TResult? Function()? locallyInitiatedCooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
    TResult? Function()? htlCsTimedOut,
  }) {
    return fundingBatchClosure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? legacyCooperativeClosure,
    TResult Function()? counterpartyInitiatedCooperativeClosure,
    TResult Function()? locallyInitiatedCooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    TResult Function()? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (fundingBatchClosure != null) {
      return fundingBatchClosure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_LegacyCooperativeClosure value)
        legacyCooperativeClosure,
    required TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)
        counterpartyInitiatedCooperativeClosure,
    required TResult Function(
            ClosureReason_LocallyInitiatedCooperativeClosure value)
        locallyInitiatedCooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
    required TResult Function(ClosureReason_HTLCsTimedOut value) htlCsTimedOut,
  }) {
    return fundingBatchClosure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult? Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult? Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
  }) {
    return fundingBatchClosure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (fundingBatchClosure != null) {
      return fundingBatchClosure(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_FundingBatchClosure extends ClosureReason {
  const factory ClosureReason_FundingBatchClosure() =
      _$ClosureReason_FundingBatchClosureImpl;
  const ClosureReason_FundingBatchClosure._() : super._();
}

/// @nodoc
abstract class _$$ClosureReason_HTLCsTimedOutImplCopyWith<$Res> {
  factory _$$ClosureReason_HTLCsTimedOutImplCopyWith(
          _$ClosureReason_HTLCsTimedOutImpl value,
          $Res Function(_$ClosureReason_HTLCsTimedOutImpl) then) =
      __$$ClosureReason_HTLCsTimedOutImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClosureReason_HTLCsTimedOutImplCopyWithImpl<$Res>
    extends _$ClosureReasonCopyWithImpl<$Res, _$ClosureReason_HTLCsTimedOutImpl>
    implements _$$ClosureReason_HTLCsTimedOutImplCopyWith<$Res> {
  __$$ClosureReason_HTLCsTimedOutImplCopyWithImpl(
      _$ClosureReason_HTLCsTimedOutImpl _value,
      $Res Function(_$ClosureReason_HTLCsTimedOutImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClosureReason_HTLCsTimedOutImpl extends ClosureReason_HTLCsTimedOut {
  const _$ClosureReason_HTLCsTimedOutImpl() : super._();

  @override
  String toString() {
    return 'ClosureReason.htlCsTimedOut()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClosureReason_HTLCsTimedOutImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String peerMsg) counterpartyForceClosed,
    required TResult Function() holderForceClosed,
    required TResult Function() legacyCooperativeClosure,
    required TResult Function() counterpartyInitiatedCooperativeClosure,
    required TResult Function() locallyInitiatedCooperativeClosure,
    required TResult Function() commitmentTxConfirmed,
    required TResult Function() fundingTimedOut,
    required TResult Function(String err) processingError,
    required TResult Function() disconnectedPeer,
    required TResult Function() outdatedChannelManager,
    required TResult Function() counterpartyCoopClosedUnfundedChannel,
    required TResult Function() fundingBatchClosure,
    required TResult Function() htlCsTimedOut,
  }) {
    return htlCsTimedOut();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String peerMsg)? counterpartyForceClosed,
    TResult? Function()? holderForceClosed,
    TResult? Function()? legacyCooperativeClosure,
    TResult? Function()? counterpartyInitiatedCooperativeClosure,
    TResult? Function()? locallyInitiatedCooperativeClosure,
    TResult? Function()? commitmentTxConfirmed,
    TResult? Function()? fundingTimedOut,
    TResult? Function(String err)? processingError,
    TResult? Function()? disconnectedPeer,
    TResult? Function()? outdatedChannelManager,
    TResult? Function()? counterpartyCoopClosedUnfundedChannel,
    TResult? Function()? fundingBatchClosure,
    TResult? Function()? htlCsTimedOut,
  }) {
    return htlCsTimedOut?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String peerMsg)? counterpartyForceClosed,
    TResult Function()? holderForceClosed,
    TResult Function()? legacyCooperativeClosure,
    TResult Function()? counterpartyInitiatedCooperativeClosure,
    TResult Function()? locallyInitiatedCooperativeClosure,
    TResult Function()? commitmentTxConfirmed,
    TResult Function()? fundingTimedOut,
    TResult Function(String err)? processingError,
    TResult Function()? disconnectedPeer,
    TResult Function()? outdatedChannelManager,
    TResult Function()? counterpartyCoopClosedUnfundedChannel,
    TResult Function()? fundingBatchClosure,
    TResult Function()? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (htlCsTimedOut != null) {
      return htlCsTimedOut();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClosureReason_CounterpartyForceClosed value)
        counterpartyForceClosed,
    required TResult Function(ClosureReason_HolderForceClosed value)
        holderForceClosed,
    required TResult Function(ClosureReason_LegacyCooperativeClosure value)
        legacyCooperativeClosure,
    required TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)
        counterpartyInitiatedCooperativeClosure,
    required TResult Function(
            ClosureReason_LocallyInitiatedCooperativeClosure value)
        locallyInitiatedCooperativeClosure,
    required TResult Function(ClosureReason_CommitmentTxConfirmed value)
        commitmentTxConfirmed,
    required TResult Function(ClosureReason_FundingTimedOut value)
        fundingTimedOut,
    required TResult Function(ClosureReason_ProcessingError value)
        processingError,
    required TResult Function(ClosureReason_DisconnectedPeer value)
        disconnectedPeer,
    required TResult Function(ClosureReason_OutdatedChannelManager value)
        outdatedChannelManager,
    required TResult Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)
        counterpartyCoopClosedUnfundedChannel,
    required TResult Function(ClosureReason_FundingBatchClosure value)
        fundingBatchClosure,
    required TResult Function(ClosureReason_HTLCsTimedOut value) htlCsTimedOut,
  }) {
    return htlCsTimedOut(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult? Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult? Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult? Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult? Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult? Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult? Function(ClosureReason_ProcessingError value)? processingError,
    TResult? Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult? Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult? Function(
            ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult? Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult? Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
  }) {
    return htlCsTimedOut?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClosureReason_CounterpartyForceClosed value)?
        counterpartyForceClosed,
    TResult Function(ClosureReason_HolderForceClosed value)? holderForceClosed,
    TResult Function(ClosureReason_LegacyCooperativeClosure value)?
        legacyCooperativeClosure,
    TResult Function(
            ClosureReason_CounterpartyInitiatedCooperativeClosure value)?
        counterpartyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_LocallyInitiatedCooperativeClosure value)?
        locallyInitiatedCooperativeClosure,
    TResult Function(ClosureReason_CommitmentTxConfirmed value)?
        commitmentTxConfirmed,
    TResult Function(ClosureReason_FundingTimedOut value)? fundingTimedOut,
    TResult Function(ClosureReason_ProcessingError value)? processingError,
    TResult Function(ClosureReason_DisconnectedPeer value)? disconnectedPeer,
    TResult Function(ClosureReason_OutdatedChannelManager value)?
        outdatedChannelManager,
    TResult Function(ClosureReason_CounterpartyCoopClosedUnfundedChannel value)?
        counterpartyCoopClosedUnfundedChannel,
    TResult Function(ClosureReason_FundingBatchClosure value)?
        fundingBatchClosure,
    TResult Function(ClosureReason_HTLCsTimedOut value)? htlCsTimedOut,
    required TResult orElse(),
  }) {
    if (htlCsTimedOut != null) {
      return htlCsTimedOut(this);
    }
    return orElse();
  }
}

abstract class ClosureReason_HTLCsTimedOut extends ClosureReason {
  const factory ClosureReason_HTLCsTimedOut() =
      _$ClosureReason_HTLCsTimedOutImpl;
  const ClosureReason_HTLCsTimedOut._() : super._();
}

/// @nodoc
mixin _$EntropySourceConfig {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) seedFile,
    required TResult Function(U8Array64 field0) seedBytes,
    required TResult Function(LdkMnemonic mnemonic, String? passphrase)
        bip39Mnemonic,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? seedFile,
    TResult? Function(U8Array64 field0)? seedBytes,
    TResult? Function(LdkMnemonic mnemonic, String? passphrase)? bip39Mnemonic,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? seedFile,
    TResult Function(U8Array64 field0)? seedBytes,
    TResult Function(LdkMnemonic mnemonic, String? passphrase)? bip39Mnemonic,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntropySourceConfig_SeedFile value) seedFile,
    required TResult Function(EntropySourceConfig_SeedBytes value) seedBytes,
    required TResult Function(EntropySourceConfig_Bip39Mnemonic value)
        bip39Mnemonic,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntropySourceConfig_SeedFile value)? seedFile,
    TResult? Function(EntropySourceConfig_SeedBytes value)? seedBytes,
    TResult? Function(EntropySourceConfig_Bip39Mnemonic value)? bip39Mnemonic,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntropySourceConfig_SeedFile value)? seedFile,
    TResult Function(EntropySourceConfig_SeedBytes value)? seedBytes,
    TResult Function(EntropySourceConfig_Bip39Mnemonic value)? bip39Mnemonic,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntropySourceConfigCopyWith<$Res> {
  factory $EntropySourceConfigCopyWith(
          EntropySourceConfig value, $Res Function(EntropySourceConfig) then) =
      _$EntropySourceConfigCopyWithImpl<$Res, EntropySourceConfig>;
}

/// @nodoc
class _$EntropySourceConfigCopyWithImpl<$Res, $Val extends EntropySourceConfig>
    implements $EntropySourceConfigCopyWith<$Res> {
  _$EntropySourceConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EntropySourceConfig_SeedFileImplCopyWith<$Res> {
  factory _$$EntropySourceConfig_SeedFileImplCopyWith(
          _$EntropySourceConfig_SeedFileImpl value,
          $Res Function(_$EntropySourceConfig_SeedFileImpl) then) =
      __$$EntropySourceConfig_SeedFileImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$EntropySourceConfig_SeedFileImplCopyWithImpl<$Res>
    extends _$EntropySourceConfigCopyWithImpl<$Res,
        _$EntropySourceConfig_SeedFileImpl>
    implements _$$EntropySourceConfig_SeedFileImplCopyWith<$Res> {
  __$$EntropySourceConfig_SeedFileImplCopyWithImpl(
      _$EntropySourceConfig_SeedFileImpl _value,
      $Res Function(_$EntropySourceConfig_SeedFileImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$EntropySourceConfig_SeedFileImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EntropySourceConfig_SeedFileImpl extends EntropySourceConfig_SeedFile {
  const _$EntropySourceConfig_SeedFileImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'EntropySourceConfig.seedFile(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntropySourceConfig_SeedFileImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntropySourceConfig_SeedFileImplCopyWith<
          _$EntropySourceConfig_SeedFileImpl>
      get copyWith => __$$EntropySourceConfig_SeedFileImplCopyWithImpl<
          _$EntropySourceConfig_SeedFileImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) seedFile,
    required TResult Function(U8Array64 field0) seedBytes,
    required TResult Function(LdkMnemonic mnemonic, String? passphrase)
        bip39Mnemonic,
  }) {
    return seedFile(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? seedFile,
    TResult? Function(U8Array64 field0)? seedBytes,
    TResult? Function(LdkMnemonic mnemonic, String? passphrase)? bip39Mnemonic,
  }) {
    return seedFile?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? seedFile,
    TResult Function(U8Array64 field0)? seedBytes,
    TResult Function(LdkMnemonic mnemonic, String? passphrase)? bip39Mnemonic,
    required TResult orElse(),
  }) {
    if (seedFile != null) {
      return seedFile(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntropySourceConfig_SeedFile value) seedFile,
    required TResult Function(EntropySourceConfig_SeedBytes value) seedBytes,
    required TResult Function(EntropySourceConfig_Bip39Mnemonic value)
        bip39Mnemonic,
  }) {
    return seedFile(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntropySourceConfig_SeedFile value)? seedFile,
    TResult? Function(EntropySourceConfig_SeedBytes value)? seedBytes,
    TResult? Function(EntropySourceConfig_Bip39Mnemonic value)? bip39Mnemonic,
  }) {
    return seedFile?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntropySourceConfig_SeedFile value)? seedFile,
    TResult Function(EntropySourceConfig_SeedBytes value)? seedBytes,
    TResult Function(EntropySourceConfig_Bip39Mnemonic value)? bip39Mnemonic,
    required TResult orElse(),
  }) {
    if (seedFile != null) {
      return seedFile(this);
    }
    return orElse();
  }
}

abstract class EntropySourceConfig_SeedFile extends EntropySourceConfig {
  const factory EntropySourceConfig_SeedFile(final String field0) =
      _$EntropySourceConfig_SeedFileImpl;
  const EntropySourceConfig_SeedFile._() : super._();

  String get field0;
  @JsonKey(ignore: true)
  _$$EntropySourceConfig_SeedFileImplCopyWith<
          _$EntropySourceConfig_SeedFileImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EntropySourceConfig_SeedBytesImplCopyWith<$Res> {
  factory _$$EntropySourceConfig_SeedBytesImplCopyWith(
          _$EntropySourceConfig_SeedBytesImpl value,
          $Res Function(_$EntropySourceConfig_SeedBytesImpl) then) =
      __$$EntropySourceConfig_SeedBytesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({U8Array64 field0});
}

/// @nodoc
class __$$EntropySourceConfig_SeedBytesImplCopyWithImpl<$Res>
    extends _$EntropySourceConfigCopyWithImpl<$Res,
        _$EntropySourceConfig_SeedBytesImpl>
    implements _$$EntropySourceConfig_SeedBytesImplCopyWith<$Res> {
  __$$EntropySourceConfig_SeedBytesImplCopyWithImpl(
      _$EntropySourceConfig_SeedBytesImpl _value,
      $Res Function(_$EntropySourceConfig_SeedBytesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$EntropySourceConfig_SeedBytesImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as U8Array64,
    ));
  }
}

/// @nodoc

class _$EntropySourceConfig_SeedBytesImpl
    extends EntropySourceConfig_SeedBytes {
  const _$EntropySourceConfig_SeedBytesImpl(this.field0) : super._();

  @override
  final U8Array64 field0;

  @override
  String toString() {
    return 'EntropySourceConfig.seedBytes(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntropySourceConfig_SeedBytesImpl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntropySourceConfig_SeedBytesImplCopyWith<
          _$EntropySourceConfig_SeedBytesImpl>
      get copyWith => __$$EntropySourceConfig_SeedBytesImplCopyWithImpl<
          _$EntropySourceConfig_SeedBytesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) seedFile,
    required TResult Function(U8Array64 field0) seedBytes,
    required TResult Function(LdkMnemonic mnemonic, String? passphrase)
        bip39Mnemonic,
  }) {
    return seedBytes(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? seedFile,
    TResult? Function(U8Array64 field0)? seedBytes,
    TResult? Function(LdkMnemonic mnemonic, String? passphrase)? bip39Mnemonic,
  }) {
    return seedBytes?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? seedFile,
    TResult Function(U8Array64 field0)? seedBytes,
    TResult Function(LdkMnemonic mnemonic, String? passphrase)? bip39Mnemonic,
    required TResult orElse(),
  }) {
    if (seedBytes != null) {
      return seedBytes(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntropySourceConfig_SeedFile value) seedFile,
    required TResult Function(EntropySourceConfig_SeedBytes value) seedBytes,
    required TResult Function(EntropySourceConfig_Bip39Mnemonic value)
        bip39Mnemonic,
  }) {
    return seedBytes(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntropySourceConfig_SeedFile value)? seedFile,
    TResult? Function(EntropySourceConfig_SeedBytes value)? seedBytes,
    TResult? Function(EntropySourceConfig_Bip39Mnemonic value)? bip39Mnemonic,
  }) {
    return seedBytes?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntropySourceConfig_SeedFile value)? seedFile,
    TResult Function(EntropySourceConfig_SeedBytes value)? seedBytes,
    TResult Function(EntropySourceConfig_Bip39Mnemonic value)? bip39Mnemonic,
    required TResult orElse(),
  }) {
    if (seedBytes != null) {
      return seedBytes(this);
    }
    return orElse();
  }
}

abstract class EntropySourceConfig_SeedBytes extends EntropySourceConfig {
  const factory EntropySourceConfig_SeedBytes(final U8Array64 field0) =
      _$EntropySourceConfig_SeedBytesImpl;
  const EntropySourceConfig_SeedBytes._() : super._();

  U8Array64 get field0;
  @JsonKey(ignore: true)
  _$$EntropySourceConfig_SeedBytesImplCopyWith<
          _$EntropySourceConfig_SeedBytesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EntropySourceConfig_Bip39MnemonicImplCopyWith<$Res> {
  factory _$$EntropySourceConfig_Bip39MnemonicImplCopyWith(
          _$EntropySourceConfig_Bip39MnemonicImpl value,
          $Res Function(_$EntropySourceConfig_Bip39MnemonicImpl) then) =
      __$$EntropySourceConfig_Bip39MnemonicImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LdkMnemonic mnemonic, String? passphrase});
}

/// @nodoc
class __$$EntropySourceConfig_Bip39MnemonicImplCopyWithImpl<$Res>
    extends _$EntropySourceConfigCopyWithImpl<$Res,
        _$EntropySourceConfig_Bip39MnemonicImpl>
    implements _$$EntropySourceConfig_Bip39MnemonicImplCopyWith<$Res> {
  __$$EntropySourceConfig_Bip39MnemonicImplCopyWithImpl(
      _$EntropySourceConfig_Bip39MnemonicImpl _value,
      $Res Function(_$EntropySourceConfig_Bip39MnemonicImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mnemonic = null,
    Object? passphrase = freezed,
  }) {
    return _then(_$EntropySourceConfig_Bip39MnemonicImpl(
      mnemonic: null == mnemonic
          ? _value.mnemonic
          : mnemonic // ignore: cast_nullable_to_non_nullable
              as LdkMnemonic,
      passphrase: freezed == passphrase
          ? _value.passphrase
          : passphrase // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$EntropySourceConfig_Bip39MnemonicImpl
    extends EntropySourceConfig_Bip39Mnemonic {
  const _$EntropySourceConfig_Bip39MnemonicImpl(
      {required this.mnemonic, this.passphrase})
      : super._();

  @override
  final LdkMnemonic mnemonic;
  @override
  final String? passphrase;

  @override
  String toString() {
    return 'EntropySourceConfig.bip39Mnemonic(mnemonic: $mnemonic, passphrase: $passphrase)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntropySourceConfig_Bip39MnemonicImpl &&
            (identical(other.mnemonic, mnemonic) ||
                other.mnemonic == mnemonic) &&
            (identical(other.passphrase, passphrase) ||
                other.passphrase == passphrase));
  }

  @override
  int get hashCode => Object.hash(runtimeType, mnemonic, passphrase);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntropySourceConfig_Bip39MnemonicImplCopyWith<
          _$EntropySourceConfig_Bip39MnemonicImpl>
      get copyWith => __$$EntropySourceConfig_Bip39MnemonicImplCopyWithImpl<
          _$EntropySourceConfig_Bip39MnemonicImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) seedFile,
    required TResult Function(U8Array64 field0) seedBytes,
    required TResult Function(LdkMnemonic mnemonic, String? passphrase)
        bip39Mnemonic,
  }) {
    return bip39Mnemonic(mnemonic, passphrase);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? seedFile,
    TResult? Function(U8Array64 field0)? seedBytes,
    TResult? Function(LdkMnemonic mnemonic, String? passphrase)? bip39Mnemonic,
  }) {
    return bip39Mnemonic?.call(mnemonic, passphrase);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? seedFile,
    TResult Function(U8Array64 field0)? seedBytes,
    TResult Function(LdkMnemonic mnemonic, String? passphrase)? bip39Mnemonic,
    required TResult orElse(),
  }) {
    if (bip39Mnemonic != null) {
      return bip39Mnemonic(mnemonic, passphrase);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EntropySourceConfig_SeedFile value) seedFile,
    required TResult Function(EntropySourceConfig_SeedBytes value) seedBytes,
    required TResult Function(EntropySourceConfig_Bip39Mnemonic value)
        bip39Mnemonic,
  }) {
    return bip39Mnemonic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EntropySourceConfig_SeedFile value)? seedFile,
    TResult? Function(EntropySourceConfig_SeedBytes value)? seedBytes,
    TResult? Function(EntropySourceConfig_Bip39Mnemonic value)? bip39Mnemonic,
  }) {
    return bip39Mnemonic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EntropySourceConfig_SeedFile value)? seedFile,
    TResult Function(EntropySourceConfig_SeedBytes value)? seedBytes,
    TResult Function(EntropySourceConfig_Bip39Mnemonic value)? bip39Mnemonic,
    required TResult orElse(),
  }) {
    if (bip39Mnemonic != null) {
      return bip39Mnemonic(this);
    }
    return orElse();
  }
}

abstract class EntropySourceConfig_Bip39Mnemonic extends EntropySourceConfig {
  const factory EntropySourceConfig_Bip39Mnemonic(
      {required final LdkMnemonic mnemonic,
      final String? passphrase}) = _$EntropySourceConfig_Bip39MnemonicImpl;
  const EntropySourceConfig_Bip39Mnemonic._() : super._();

  LdkMnemonic get mnemonic;
  String? get passphrase;
  @JsonKey(ignore: true)
  _$$EntropySourceConfig_Bip39MnemonicImplCopyWith<
          _$EntropySourceConfig_Bip39MnemonicImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Event {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)
        paymentSuccessful,
    required TResult Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)
        paymentFailed,
    required TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)
        paymentReceived,
    required TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)
        channelPending,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)
        channelReady,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)
        channelClosed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult? Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)?
        paymentFailed,
    TResult? Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)?
        paymentReceived,
    TResult? Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)?
        paymentFailed,
    TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)?
        paymentReceived,
    TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Event_PaymentSuccessful value) paymentSuccessful,
    required TResult Function(Event_PaymentFailed value) paymentFailed,
    required TResult Function(Event_PaymentReceived value) paymentReceived,
    required TResult Function(Event_ChannelPending value) channelPending,
    required TResult Function(Event_ChannelReady value) channelReady,
    required TResult Function(Event_ChannelClosed value) channelClosed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult? Function(Event_PaymentFailed value)? paymentFailed,
    TResult? Function(Event_PaymentReceived value)? paymentReceived,
    TResult? Function(Event_ChannelPending value)? channelPending,
    TResult? Function(Event_ChannelReady value)? channelReady,
    TResult? Function(Event_ChannelClosed value)? channelClosed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult Function(Event_PaymentFailed value)? paymentFailed,
    TResult Function(Event_PaymentReceived value)? paymentReceived,
    TResult Function(Event_ChannelPending value)? channelPending,
    TResult Function(Event_ChannelReady value)? channelReady,
    TResult Function(Event_ChannelClosed value)? channelClosed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EventCopyWith<$Res> {
  factory $EventCopyWith(Event value, $Res Function(Event) then) =
      _$EventCopyWithImpl<$Res, Event>;
}

/// @nodoc
class _$EventCopyWithImpl<$Res, $Val extends Event>
    implements $EventCopyWith<$Res> {
  _$EventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$Event_PaymentSuccessfulImplCopyWith<$Res> {
  factory _$$Event_PaymentSuccessfulImplCopyWith(
          _$Event_PaymentSuccessfulImpl value,
          $Res Function(_$Event_PaymentSuccessfulImpl) then) =
      __$$Event_PaymentSuccessfulImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat});
}

/// @nodoc
class __$$Event_PaymentSuccessfulImplCopyWithImpl<$Res>
    extends _$EventCopyWithImpl<$Res, _$Event_PaymentSuccessfulImpl>
    implements _$$Event_PaymentSuccessfulImplCopyWith<$Res> {
  __$$Event_PaymentSuccessfulImplCopyWithImpl(
      _$Event_PaymentSuccessfulImpl _value,
      $Res Function(_$Event_PaymentSuccessfulImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? paymentId = freezed,
    Object? paymentHash = null,
    Object? feePaidMsat = freezed,
  }) {
    return _then(_$Event_PaymentSuccessfulImpl(
      paymentId: freezed == paymentId
          ? _value.paymentId
          : paymentId // ignore: cast_nullable_to_non_nullable
              as PaymentId?,
      paymentHash: null == paymentHash
          ? _value.paymentHash
          : paymentHash // ignore: cast_nullable_to_non_nullable
              as PaymentHash,
      feePaidMsat: freezed == feePaidMsat
          ? _value.feePaidMsat
          : feePaidMsat // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$Event_PaymentSuccessfulImpl extends Event_PaymentSuccessful {
  const _$Event_PaymentSuccessfulImpl(
      {this.paymentId, required this.paymentHash, this.feePaidMsat})
      : super._();

  /// A local identifier used to track the payment.
  ///
  /// Will only be `None` for events serialized with LDK Node v0.2.1 or prior.
  @override
  final PaymentId? paymentId;

  /// The hash of the payment.
  @override
  final PaymentHash paymentHash;

  /// The total fee which was spent at intermediate hops in this payment.
  @override
  final int? feePaidMsat;

  @override
  String toString() {
    return 'Event.paymentSuccessful(paymentId: $paymentId, paymentHash: $paymentHash, feePaidMsat: $feePaidMsat)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Event_PaymentSuccessfulImpl &&
            (identical(other.paymentId, paymentId) ||
                other.paymentId == paymentId) &&
            (identical(other.paymentHash, paymentHash) ||
                other.paymentHash == paymentHash) &&
            (identical(other.feePaidMsat, feePaidMsat) ||
                other.feePaidMsat == feePaidMsat));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, paymentId, paymentHash, feePaidMsat);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Event_PaymentSuccessfulImplCopyWith<_$Event_PaymentSuccessfulImpl>
      get copyWith => __$$Event_PaymentSuccessfulImplCopyWithImpl<
          _$Event_PaymentSuccessfulImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)
        paymentSuccessful,
    required TResult Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)
        paymentFailed,
    required TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)
        paymentReceived,
    required TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)
        channelPending,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)
        channelReady,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)
        channelClosed,
  }) {
    return paymentSuccessful(paymentId, paymentHash, feePaidMsat);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult? Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)?
        paymentFailed,
    TResult? Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)?
        paymentReceived,
    TResult? Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
  }) {
    return paymentSuccessful?.call(paymentId, paymentHash, feePaidMsat);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)?
        paymentFailed,
    TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)?
        paymentReceived,
    TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
    required TResult orElse(),
  }) {
    if (paymentSuccessful != null) {
      return paymentSuccessful(paymentId, paymentHash, feePaidMsat);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Event_PaymentSuccessful value) paymentSuccessful,
    required TResult Function(Event_PaymentFailed value) paymentFailed,
    required TResult Function(Event_PaymentReceived value) paymentReceived,
    required TResult Function(Event_ChannelPending value) channelPending,
    required TResult Function(Event_ChannelReady value) channelReady,
    required TResult Function(Event_ChannelClosed value) channelClosed,
  }) {
    return paymentSuccessful(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult? Function(Event_PaymentFailed value)? paymentFailed,
    TResult? Function(Event_PaymentReceived value)? paymentReceived,
    TResult? Function(Event_ChannelPending value)? channelPending,
    TResult? Function(Event_ChannelReady value)? channelReady,
    TResult? Function(Event_ChannelClosed value)? channelClosed,
  }) {
    return paymentSuccessful?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult Function(Event_PaymentFailed value)? paymentFailed,
    TResult Function(Event_PaymentReceived value)? paymentReceived,
    TResult Function(Event_ChannelPending value)? channelPending,
    TResult Function(Event_ChannelReady value)? channelReady,
    TResult Function(Event_ChannelClosed value)? channelClosed,
    required TResult orElse(),
  }) {
    if (paymentSuccessful != null) {
      return paymentSuccessful(this);
    }
    return orElse();
  }
}

abstract class Event_PaymentSuccessful extends Event {
  const factory Event_PaymentSuccessful(
      {final PaymentId? paymentId,
      required final PaymentHash paymentHash,
      final int? feePaidMsat}) = _$Event_PaymentSuccessfulImpl;
  const Event_PaymentSuccessful._() : super._();

  /// A local identifier used to track the payment.
  ///
  /// Will only be `None` for events serialized with LDK Node v0.2.1 or prior.
  PaymentId? get paymentId;

  /// The hash of the payment.
  PaymentHash get paymentHash;

  /// The total fee which was spent at intermediate hops in this payment.
  int? get feePaidMsat;
  @JsonKey(ignore: true)
  _$$Event_PaymentSuccessfulImplCopyWith<_$Event_PaymentSuccessfulImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Event_PaymentFailedImplCopyWith<$Res> {
  factory _$$Event_PaymentFailedImplCopyWith(_$Event_PaymentFailedImpl value,
          $Res Function(_$Event_PaymentFailedImpl) then) =
      __$$Event_PaymentFailedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {PaymentId? paymentId,
      PaymentHash paymentHash,
      PaymentFailureReason? reason});
}

/// @nodoc
class __$$Event_PaymentFailedImplCopyWithImpl<$Res>
    extends _$EventCopyWithImpl<$Res, _$Event_PaymentFailedImpl>
    implements _$$Event_PaymentFailedImplCopyWith<$Res> {
  __$$Event_PaymentFailedImplCopyWithImpl(_$Event_PaymentFailedImpl _value,
      $Res Function(_$Event_PaymentFailedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? paymentId = freezed,
    Object? paymentHash = null,
    Object? reason = freezed,
  }) {
    return _then(_$Event_PaymentFailedImpl(
      paymentId: freezed == paymentId
          ? _value.paymentId
          : paymentId // ignore: cast_nullable_to_non_nullable
              as PaymentId?,
      paymentHash: null == paymentHash
          ? _value.paymentHash
          : paymentHash // ignore: cast_nullable_to_non_nullable
              as PaymentHash,
      reason: freezed == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as PaymentFailureReason?,
    ));
  }
}

/// @nodoc

class _$Event_PaymentFailedImpl extends Event_PaymentFailed {
  const _$Event_PaymentFailedImpl(
      {this.paymentId, required this.paymentHash, this.reason})
      : super._();

  /// A local identifier used to track the payment.
  ///
  /// Will only be `None` for events serialized with LDK Node v0.2.1 or prior.
  @override
  final PaymentId? paymentId;

  /// The hash of the payment.
  @override
  final PaymentHash paymentHash;

  /// The reason why the payment failed.
  ///
  /// This will be `None` for events serialized by LDK Node v0.2.1 and prior.
  @override
  final PaymentFailureReason? reason;

  @override
  String toString() {
    return 'Event.paymentFailed(paymentId: $paymentId, paymentHash: $paymentHash, reason: $reason)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Event_PaymentFailedImpl &&
            (identical(other.paymentId, paymentId) ||
                other.paymentId == paymentId) &&
            (identical(other.paymentHash, paymentHash) ||
                other.paymentHash == paymentHash) &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @override
  int get hashCode => Object.hash(runtimeType, paymentId, paymentHash, reason);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Event_PaymentFailedImplCopyWith<_$Event_PaymentFailedImpl> get copyWith =>
      __$$Event_PaymentFailedImplCopyWithImpl<_$Event_PaymentFailedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)
        paymentSuccessful,
    required TResult Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)
        paymentFailed,
    required TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)
        paymentReceived,
    required TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)
        channelPending,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)
        channelReady,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)
        channelClosed,
  }) {
    return paymentFailed(paymentId, paymentHash, reason);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult? Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)?
        paymentFailed,
    TResult? Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)?
        paymentReceived,
    TResult? Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
  }) {
    return paymentFailed?.call(paymentId, paymentHash, reason);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)?
        paymentFailed,
    TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)?
        paymentReceived,
    TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
    required TResult orElse(),
  }) {
    if (paymentFailed != null) {
      return paymentFailed(paymentId, paymentHash, reason);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Event_PaymentSuccessful value) paymentSuccessful,
    required TResult Function(Event_PaymentFailed value) paymentFailed,
    required TResult Function(Event_PaymentReceived value) paymentReceived,
    required TResult Function(Event_ChannelPending value) channelPending,
    required TResult Function(Event_ChannelReady value) channelReady,
    required TResult Function(Event_ChannelClosed value) channelClosed,
  }) {
    return paymentFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult? Function(Event_PaymentFailed value)? paymentFailed,
    TResult? Function(Event_PaymentReceived value)? paymentReceived,
    TResult? Function(Event_ChannelPending value)? channelPending,
    TResult? Function(Event_ChannelReady value)? channelReady,
    TResult? Function(Event_ChannelClosed value)? channelClosed,
  }) {
    return paymentFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult Function(Event_PaymentFailed value)? paymentFailed,
    TResult Function(Event_PaymentReceived value)? paymentReceived,
    TResult Function(Event_ChannelPending value)? channelPending,
    TResult Function(Event_ChannelReady value)? channelReady,
    TResult Function(Event_ChannelClosed value)? channelClosed,
    required TResult orElse(),
  }) {
    if (paymentFailed != null) {
      return paymentFailed(this);
    }
    return orElse();
  }
}

abstract class Event_PaymentFailed extends Event {
  const factory Event_PaymentFailed(
      {final PaymentId? paymentId,
      required final PaymentHash paymentHash,
      final PaymentFailureReason? reason}) = _$Event_PaymentFailedImpl;
  const Event_PaymentFailed._() : super._();

  /// A local identifier used to track the payment.
  ///
  /// Will only be `None` for events serialized with LDK Node v0.2.1 or prior.
  PaymentId? get paymentId;

  /// The hash of the payment.
  PaymentHash get paymentHash;

  /// The reason why the payment failed.
  ///
  /// This will be `None` for events serialized by LDK Node v0.2.1 and prior.
  PaymentFailureReason? get reason;
  @JsonKey(ignore: true)
  _$$Event_PaymentFailedImplCopyWith<_$Event_PaymentFailedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Event_PaymentReceivedImplCopyWith<$Res> {
  factory _$$Event_PaymentReceivedImplCopyWith(
          _$Event_PaymentReceivedImpl value,
          $Res Function(_$Event_PaymentReceivedImpl) then) =
      __$$Event_PaymentReceivedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PaymentId? paymentId, PaymentHash paymentHash, int amountMsat});
}

/// @nodoc
class __$$Event_PaymentReceivedImplCopyWithImpl<$Res>
    extends _$EventCopyWithImpl<$Res, _$Event_PaymentReceivedImpl>
    implements _$$Event_PaymentReceivedImplCopyWith<$Res> {
  __$$Event_PaymentReceivedImplCopyWithImpl(_$Event_PaymentReceivedImpl _value,
      $Res Function(_$Event_PaymentReceivedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? paymentId = freezed,
    Object? paymentHash = null,
    Object? amountMsat = null,
  }) {
    return _then(_$Event_PaymentReceivedImpl(
      paymentId: freezed == paymentId
          ? _value.paymentId
          : paymentId // ignore: cast_nullable_to_non_nullable
              as PaymentId?,
      paymentHash: null == paymentHash
          ? _value.paymentHash
          : paymentHash // ignore: cast_nullable_to_non_nullable
              as PaymentHash,
      amountMsat: null == amountMsat
          ? _value.amountMsat
          : amountMsat // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Event_PaymentReceivedImpl extends Event_PaymentReceived {
  const _$Event_PaymentReceivedImpl(
      {this.paymentId, required this.paymentHash, required this.amountMsat})
      : super._();

  /// A local identifier used to track the payment.
  ///
  /// Will only be `None` for events serialized with LDK Node v0.2.1 or prior.
  @override
  final PaymentId? paymentId;

  /// The hash of the payment.
  @override
  final PaymentHash paymentHash;

  /// The value, in thousandths of a satoshi, that has been received.
  @override
  final int amountMsat;

  @override
  String toString() {
    return 'Event.paymentReceived(paymentId: $paymentId, paymentHash: $paymentHash, amountMsat: $amountMsat)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Event_PaymentReceivedImpl &&
            (identical(other.paymentId, paymentId) ||
                other.paymentId == paymentId) &&
            (identical(other.paymentHash, paymentHash) ||
                other.paymentHash == paymentHash) &&
            (identical(other.amountMsat, amountMsat) ||
                other.amountMsat == amountMsat));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, paymentId, paymentHash, amountMsat);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Event_PaymentReceivedImplCopyWith<_$Event_PaymentReceivedImpl>
      get copyWith => __$$Event_PaymentReceivedImplCopyWithImpl<
          _$Event_PaymentReceivedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)
        paymentSuccessful,
    required TResult Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)
        paymentFailed,
    required TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)
        paymentReceived,
    required TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)
        channelPending,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)
        channelReady,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)
        channelClosed,
  }) {
    return paymentReceived(paymentId, paymentHash, amountMsat);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult? Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)?
        paymentFailed,
    TResult? Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)?
        paymentReceived,
    TResult? Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
  }) {
    return paymentReceived?.call(paymentId, paymentHash, amountMsat);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)?
        paymentFailed,
    TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)?
        paymentReceived,
    TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
    required TResult orElse(),
  }) {
    if (paymentReceived != null) {
      return paymentReceived(paymentId, paymentHash, amountMsat);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Event_PaymentSuccessful value) paymentSuccessful,
    required TResult Function(Event_PaymentFailed value) paymentFailed,
    required TResult Function(Event_PaymentReceived value) paymentReceived,
    required TResult Function(Event_ChannelPending value) channelPending,
    required TResult Function(Event_ChannelReady value) channelReady,
    required TResult Function(Event_ChannelClosed value) channelClosed,
  }) {
    return paymentReceived(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult? Function(Event_PaymentFailed value)? paymentFailed,
    TResult? Function(Event_PaymentReceived value)? paymentReceived,
    TResult? Function(Event_ChannelPending value)? channelPending,
    TResult? Function(Event_ChannelReady value)? channelReady,
    TResult? Function(Event_ChannelClosed value)? channelClosed,
  }) {
    return paymentReceived?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult Function(Event_PaymentFailed value)? paymentFailed,
    TResult Function(Event_PaymentReceived value)? paymentReceived,
    TResult Function(Event_ChannelPending value)? channelPending,
    TResult Function(Event_ChannelReady value)? channelReady,
    TResult Function(Event_ChannelClosed value)? channelClosed,
    required TResult orElse(),
  }) {
    if (paymentReceived != null) {
      return paymentReceived(this);
    }
    return orElse();
  }
}

abstract class Event_PaymentReceived extends Event {
  const factory Event_PaymentReceived(
      {final PaymentId? paymentId,
      required final PaymentHash paymentHash,
      required final int amountMsat}) = _$Event_PaymentReceivedImpl;
  const Event_PaymentReceived._() : super._();

  /// A local identifier used to track the payment.
  ///
  /// Will only be `None` for events serialized with LDK Node v0.2.1 or prior.
  PaymentId? get paymentId;

  /// The hash of the payment.
  PaymentHash get paymentHash;

  /// The value, in thousandths of a satoshi, that has been received.
  int get amountMsat;
  @JsonKey(ignore: true)
  _$$Event_PaymentReceivedImplCopyWith<_$Event_PaymentReceivedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Event_ChannelPendingImplCopyWith<$Res> {
  factory _$$Event_ChannelPendingImplCopyWith(_$Event_ChannelPendingImpl value,
          $Res Function(_$Event_ChannelPendingImpl) then) =
      __$$Event_ChannelPendingImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {ChannelId channelId,
      UserChannelId userChannelId,
      ChannelId formerTemporaryChannelId,
      PublicKey counterpartyNodeId,
      OutPoint fundingTxo});
}

/// @nodoc
class __$$Event_ChannelPendingImplCopyWithImpl<$Res>
    extends _$EventCopyWithImpl<$Res, _$Event_ChannelPendingImpl>
    implements _$$Event_ChannelPendingImplCopyWith<$Res> {
  __$$Event_ChannelPendingImplCopyWithImpl(_$Event_ChannelPendingImpl _value,
      $Res Function(_$Event_ChannelPendingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? userChannelId = null,
    Object? formerTemporaryChannelId = null,
    Object? counterpartyNodeId = null,
    Object? fundingTxo = null,
  }) {
    return _then(_$Event_ChannelPendingImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      userChannelId: null == userChannelId
          ? _value.userChannelId
          : userChannelId // ignore: cast_nullable_to_non_nullable
              as UserChannelId,
      formerTemporaryChannelId: null == formerTemporaryChannelId
          ? _value.formerTemporaryChannelId
          : formerTemporaryChannelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      counterpartyNodeId: null == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      fundingTxo: null == fundingTxo
          ? _value.fundingTxo
          : fundingTxo // ignore: cast_nullable_to_non_nullable
              as OutPoint,
    ));
  }
}

/// @nodoc

class _$Event_ChannelPendingImpl extends Event_ChannelPending {
  const _$Event_ChannelPendingImpl(
      {required this.channelId,
      required this.userChannelId,
      required this.formerTemporaryChannelId,
      required this.counterpartyNodeId,
      required this.fundingTxo})
      : super._();

  /// The `channelId` of the channel.
  @override
  final ChannelId channelId;

  /// The `userChannelId` of the channel.
  @override
  final UserChannelId userChannelId;

  /// The `temporaryChannelId` this channel used to be known by during channel establishment.
  @override
  final ChannelId formerTemporaryChannelId;

  /// The `nodeId` of the channel counterparty.
  @override
  final PublicKey counterpartyNodeId;

  /// The outpoint of the channel's funding transaction.
  @override
  final OutPoint fundingTxo;

  @override
  String toString() {
    return 'Event.channelPending(channelId: $channelId, userChannelId: $userChannelId, formerTemporaryChannelId: $formerTemporaryChannelId, counterpartyNodeId: $counterpartyNodeId, fundingTxo: $fundingTxo)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Event_ChannelPendingImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.userChannelId, userChannelId) ||
                other.userChannelId == userChannelId) &&
            (identical(
                    other.formerTemporaryChannelId, formerTemporaryChannelId) ||
                other.formerTemporaryChannelId == formerTemporaryChannelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId) &&
            (identical(other.fundingTxo, fundingTxo) ||
                other.fundingTxo == fundingTxo));
  }

  @override
  int get hashCode => Object.hash(runtimeType, channelId, userChannelId,
      formerTemporaryChannelId, counterpartyNodeId, fundingTxo);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Event_ChannelPendingImplCopyWith<_$Event_ChannelPendingImpl>
      get copyWith =>
          __$$Event_ChannelPendingImplCopyWithImpl<_$Event_ChannelPendingImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)
        paymentSuccessful,
    required TResult Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)
        paymentFailed,
    required TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)
        paymentReceived,
    required TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)
        channelPending,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)
        channelReady,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)
        channelClosed,
  }) {
    return channelPending(channelId, userChannelId, formerTemporaryChannelId,
        counterpartyNodeId, fundingTxo);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult? Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)?
        paymentFailed,
    TResult? Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)?
        paymentReceived,
    TResult? Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
  }) {
    return channelPending?.call(channelId, userChannelId,
        formerTemporaryChannelId, counterpartyNodeId, fundingTxo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)?
        paymentFailed,
    TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)?
        paymentReceived,
    TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
    required TResult orElse(),
  }) {
    if (channelPending != null) {
      return channelPending(channelId, userChannelId, formerTemporaryChannelId,
          counterpartyNodeId, fundingTxo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Event_PaymentSuccessful value) paymentSuccessful,
    required TResult Function(Event_PaymentFailed value) paymentFailed,
    required TResult Function(Event_PaymentReceived value) paymentReceived,
    required TResult Function(Event_ChannelPending value) channelPending,
    required TResult Function(Event_ChannelReady value) channelReady,
    required TResult Function(Event_ChannelClosed value) channelClosed,
  }) {
    return channelPending(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult? Function(Event_PaymentFailed value)? paymentFailed,
    TResult? Function(Event_PaymentReceived value)? paymentReceived,
    TResult? Function(Event_ChannelPending value)? channelPending,
    TResult? Function(Event_ChannelReady value)? channelReady,
    TResult? Function(Event_ChannelClosed value)? channelClosed,
  }) {
    return channelPending?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult Function(Event_PaymentFailed value)? paymentFailed,
    TResult Function(Event_PaymentReceived value)? paymentReceived,
    TResult Function(Event_ChannelPending value)? channelPending,
    TResult Function(Event_ChannelReady value)? channelReady,
    TResult Function(Event_ChannelClosed value)? channelClosed,
    required TResult orElse(),
  }) {
    if (channelPending != null) {
      return channelPending(this);
    }
    return orElse();
  }
}

abstract class Event_ChannelPending extends Event {
  const factory Event_ChannelPending(
      {required final ChannelId channelId,
      required final UserChannelId userChannelId,
      required final ChannelId formerTemporaryChannelId,
      required final PublicKey counterpartyNodeId,
      required final OutPoint fundingTxo}) = _$Event_ChannelPendingImpl;
  const Event_ChannelPending._() : super._();

  /// The `channelId` of the channel.
  ChannelId get channelId;

  /// The `userChannelId` of the channel.
  UserChannelId get userChannelId;

  /// The `temporaryChannelId` this channel used to be known by during channel establishment.
  ChannelId get formerTemporaryChannelId;

  /// The `nodeId` of the channel counterparty.
  PublicKey get counterpartyNodeId;

  /// The outpoint of the channel's funding transaction.
  OutPoint get fundingTxo;
  @JsonKey(ignore: true)
  _$$Event_ChannelPendingImplCopyWith<_$Event_ChannelPendingImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Event_ChannelReadyImplCopyWith<$Res> {
  factory _$$Event_ChannelReadyImplCopyWith(_$Event_ChannelReadyImpl value,
          $Res Function(_$Event_ChannelReadyImpl) then) =
      __$$Event_ChannelReadyImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {ChannelId channelId,
      UserChannelId userChannelId,
      PublicKey? counterpartyNodeId});
}

/// @nodoc
class __$$Event_ChannelReadyImplCopyWithImpl<$Res>
    extends _$EventCopyWithImpl<$Res, _$Event_ChannelReadyImpl>
    implements _$$Event_ChannelReadyImplCopyWith<$Res> {
  __$$Event_ChannelReadyImplCopyWithImpl(_$Event_ChannelReadyImpl _value,
      $Res Function(_$Event_ChannelReadyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? userChannelId = null,
    Object? counterpartyNodeId = freezed,
  }) {
    return _then(_$Event_ChannelReadyImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      userChannelId: null == userChannelId
          ? _value.userChannelId
          : userChannelId // ignore: cast_nullable_to_non_nullable
              as UserChannelId,
      counterpartyNodeId: freezed == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey?,
    ));
  }
}

/// @nodoc

class _$Event_ChannelReadyImpl extends Event_ChannelReady {
  const _$Event_ChannelReadyImpl(
      {required this.channelId,
      required this.userChannelId,
      this.counterpartyNodeId})
      : super._();

  /// The `channelId` of the channel.
  @override
  final ChannelId channelId;

  /// The `userChannelId` of the channel.
  @override
  final UserChannelId userChannelId;

  /// The `nodeId` of the channel counterparty.
  ///
  /// This will be `None` for events serialized by LDK Node v0.1.0 and prior.
  @override
  final PublicKey? counterpartyNodeId;

  @override
  String toString() {
    return 'Event.channelReady(channelId: $channelId, userChannelId: $userChannelId, counterpartyNodeId: $counterpartyNodeId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Event_ChannelReadyImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.userChannelId, userChannelId) ||
                other.userChannelId == userChannelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, channelId, userChannelId, counterpartyNodeId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Event_ChannelReadyImplCopyWith<_$Event_ChannelReadyImpl> get copyWith =>
      __$$Event_ChannelReadyImplCopyWithImpl<_$Event_ChannelReadyImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)
        paymentSuccessful,
    required TResult Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)
        paymentFailed,
    required TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)
        paymentReceived,
    required TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)
        channelPending,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)
        channelReady,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)
        channelClosed,
  }) {
    return channelReady(channelId, userChannelId, counterpartyNodeId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult? Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)?
        paymentFailed,
    TResult? Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)?
        paymentReceived,
    TResult? Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
  }) {
    return channelReady?.call(channelId, userChannelId, counterpartyNodeId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)?
        paymentFailed,
    TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)?
        paymentReceived,
    TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
    required TResult orElse(),
  }) {
    if (channelReady != null) {
      return channelReady(channelId, userChannelId, counterpartyNodeId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Event_PaymentSuccessful value) paymentSuccessful,
    required TResult Function(Event_PaymentFailed value) paymentFailed,
    required TResult Function(Event_PaymentReceived value) paymentReceived,
    required TResult Function(Event_ChannelPending value) channelPending,
    required TResult Function(Event_ChannelReady value) channelReady,
    required TResult Function(Event_ChannelClosed value) channelClosed,
  }) {
    return channelReady(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult? Function(Event_PaymentFailed value)? paymentFailed,
    TResult? Function(Event_PaymentReceived value)? paymentReceived,
    TResult? Function(Event_ChannelPending value)? channelPending,
    TResult? Function(Event_ChannelReady value)? channelReady,
    TResult? Function(Event_ChannelClosed value)? channelClosed,
  }) {
    return channelReady?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult Function(Event_PaymentFailed value)? paymentFailed,
    TResult Function(Event_PaymentReceived value)? paymentReceived,
    TResult Function(Event_ChannelPending value)? channelPending,
    TResult Function(Event_ChannelReady value)? channelReady,
    TResult Function(Event_ChannelClosed value)? channelClosed,
    required TResult orElse(),
  }) {
    if (channelReady != null) {
      return channelReady(this);
    }
    return orElse();
  }
}

abstract class Event_ChannelReady extends Event {
  const factory Event_ChannelReady(
      {required final ChannelId channelId,
      required final UserChannelId userChannelId,
      final PublicKey? counterpartyNodeId}) = _$Event_ChannelReadyImpl;
  const Event_ChannelReady._() : super._();

  /// The `channelId` of the channel.
  ChannelId get channelId;

  /// The `userChannelId` of the channel.
  UserChannelId get userChannelId;

  /// The `nodeId` of the channel counterparty.
  ///
  /// This will be `None` for events serialized by LDK Node v0.1.0 and prior.
  PublicKey? get counterpartyNodeId;
  @JsonKey(ignore: true)
  _$$Event_ChannelReadyImplCopyWith<_$Event_ChannelReadyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Event_ChannelClosedImplCopyWith<$Res> {
  factory _$$Event_ChannelClosedImplCopyWith(_$Event_ChannelClosedImpl value,
          $Res Function(_$Event_ChannelClosedImpl) then) =
      __$$Event_ChannelClosedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {ChannelId channelId,
      UserChannelId userChannelId,
      PublicKey? counterpartyNodeId,
      ClosureReason? reason});

  $ClosureReasonCopyWith<$Res>? get reason;
}

/// @nodoc
class __$$Event_ChannelClosedImplCopyWithImpl<$Res>
    extends _$EventCopyWithImpl<$Res, _$Event_ChannelClosedImpl>
    implements _$$Event_ChannelClosedImplCopyWith<$Res> {
  __$$Event_ChannelClosedImplCopyWithImpl(_$Event_ChannelClosedImpl _value,
      $Res Function(_$Event_ChannelClosedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? userChannelId = null,
    Object? counterpartyNodeId = freezed,
    Object? reason = freezed,
  }) {
    return _then(_$Event_ChannelClosedImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      userChannelId: null == userChannelId
          ? _value.userChannelId
          : userChannelId // ignore: cast_nullable_to_non_nullable
              as UserChannelId,
      counterpartyNodeId: freezed == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey?,
      reason: freezed == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as ClosureReason?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ClosureReasonCopyWith<$Res>? get reason {
    if (_value.reason == null) {
      return null;
    }

    return $ClosureReasonCopyWith<$Res>(_value.reason!, (value) {
      return _then(_value.copyWith(reason: value));
    });
  }
}

/// @nodoc

class _$Event_ChannelClosedImpl extends Event_ChannelClosed {
  const _$Event_ChannelClosedImpl(
      {required this.channelId,
      required this.userChannelId,
      this.counterpartyNodeId,
      this.reason})
      : super._();

  /// The `channelId` of the channel.
  @override
  final ChannelId channelId;

  /// The `userChannelId` of the channel.
  @override
  final UserChannelId userChannelId;

  /// The `nodeId` of the channel counterparty.
  ///
  /// This will be `None` for events serialized by LDK Node v0.1.0 and prior.
  @override
  final PublicKey? counterpartyNodeId;

  /// This will be `None` for events serialized by LDK Node v0.2.1 and prior.
  @override
  final ClosureReason? reason;

  @override
  String toString() {
    return 'Event.channelClosed(channelId: $channelId, userChannelId: $userChannelId, counterpartyNodeId: $counterpartyNodeId, reason: $reason)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Event_ChannelClosedImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.userChannelId, userChannelId) ||
                other.userChannelId == userChannelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId) &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, channelId, userChannelId, counterpartyNodeId, reason);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Event_ChannelClosedImplCopyWith<_$Event_ChannelClosedImpl> get copyWith =>
      __$$Event_ChannelClosedImplCopyWithImpl<_$Event_ChannelClosedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)
        paymentSuccessful,
    required TResult Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)
        paymentFailed,
    required TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)
        paymentReceived,
    required TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)
        channelPending,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)
        channelReady,
    required TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)
        channelClosed,
  }) {
    return channelClosed(channelId, userChannelId, counterpartyNodeId, reason);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult? Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)?
        paymentFailed,
    TResult? Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)?
        paymentReceived,
    TResult? Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult? Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
  }) {
    return channelClosed?.call(
        channelId, userChannelId, counterpartyNodeId, reason);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int? feePaidMsat)?
        paymentSuccessful,
    TResult Function(PaymentId? paymentId, PaymentHash paymentHash,
            PaymentFailureReason? reason)?
        paymentFailed,
    TResult Function(
            PaymentId? paymentId, PaymentHash paymentHash, int amountMsat)?
        paymentReceived,
    TResult Function(
            ChannelId channelId,
            UserChannelId userChannelId,
            ChannelId formerTemporaryChannelId,
            PublicKey counterpartyNodeId,
            OutPoint fundingTxo)?
        channelPending,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId)?
        channelReady,
    TResult Function(ChannelId channelId, UserChannelId userChannelId,
            PublicKey? counterpartyNodeId, ClosureReason? reason)?
        channelClosed,
    required TResult orElse(),
  }) {
    if (channelClosed != null) {
      return channelClosed(
          channelId, userChannelId, counterpartyNodeId, reason);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Event_PaymentSuccessful value) paymentSuccessful,
    required TResult Function(Event_PaymentFailed value) paymentFailed,
    required TResult Function(Event_PaymentReceived value) paymentReceived,
    required TResult Function(Event_ChannelPending value) channelPending,
    required TResult Function(Event_ChannelReady value) channelReady,
    required TResult Function(Event_ChannelClosed value) channelClosed,
  }) {
    return channelClosed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult? Function(Event_PaymentFailed value)? paymentFailed,
    TResult? Function(Event_PaymentReceived value)? paymentReceived,
    TResult? Function(Event_ChannelPending value)? channelPending,
    TResult? Function(Event_ChannelReady value)? channelReady,
    TResult? Function(Event_ChannelClosed value)? channelClosed,
  }) {
    return channelClosed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Event_PaymentSuccessful value)? paymentSuccessful,
    TResult Function(Event_PaymentFailed value)? paymentFailed,
    TResult Function(Event_PaymentReceived value)? paymentReceived,
    TResult Function(Event_ChannelPending value)? channelPending,
    TResult Function(Event_ChannelReady value)? channelReady,
    TResult Function(Event_ChannelClosed value)? channelClosed,
    required TResult orElse(),
  }) {
    if (channelClosed != null) {
      return channelClosed(this);
    }
    return orElse();
  }
}

abstract class Event_ChannelClosed extends Event {
  const factory Event_ChannelClosed(
      {required final ChannelId channelId,
      required final UserChannelId userChannelId,
      final PublicKey? counterpartyNodeId,
      final ClosureReason? reason}) = _$Event_ChannelClosedImpl;
  const Event_ChannelClosed._() : super._();

  /// The `channelId` of the channel.
  ChannelId get channelId;

  /// The `userChannelId` of the channel.
  UserChannelId get userChannelId;

  /// The `nodeId` of the channel counterparty.
  ///
  /// This will be `None` for events serialized by LDK Node v0.1.0 and prior.
  PublicKey? get counterpartyNodeId;

  /// This will be `None` for events serialized by LDK Node v0.2.1 and prior.
  ClosureReason? get reason;
  @JsonKey(ignore: true)
  _$$Event_ChannelClosedImplCopyWith<_$Event_ChannelClosedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$GossipSourceConfig {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() p2PNetwork,
    required TResult Function(String field0) rapidGossipSync,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? p2PNetwork,
    TResult? Function(String field0)? rapidGossipSync,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? p2PNetwork,
    TResult Function(String field0)? rapidGossipSync,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GossipSourceConfig_P2PNetwork value) p2PNetwork,
    required TResult Function(GossipSourceConfig_RapidGossipSync value)
        rapidGossipSync,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GossipSourceConfig_P2PNetwork value)? p2PNetwork,
    TResult? Function(GossipSourceConfig_RapidGossipSync value)?
        rapidGossipSync,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GossipSourceConfig_P2PNetwork value)? p2PNetwork,
    TResult Function(GossipSourceConfig_RapidGossipSync value)? rapidGossipSync,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GossipSourceConfigCopyWith<$Res> {
  factory $GossipSourceConfigCopyWith(
          GossipSourceConfig value, $Res Function(GossipSourceConfig) then) =
      _$GossipSourceConfigCopyWithImpl<$Res, GossipSourceConfig>;
}

/// @nodoc
class _$GossipSourceConfigCopyWithImpl<$Res, $Val extends GossipSourceConfig>
    implements $GossipSourceConfigCopyWith<$Res> {
  _$GossipSourceConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$GossipSourceConfig_P2PNetworkImplCopyWith<$Res> {
  factory _$$GossipSourceConfig_P2PNetworkImplCopyWith(
          _$GossipSourceConfig_P2PNetworkImpl value,
          $Res Function(_$GossipSourceConfig_P2PNetworkImpl) then) =
      __$$GossipSourceConfig_P2PNetworkImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GossipSourceConfig_P2PNetworkImplCopyWithImpl<$Res>
    extends _$GossipSourceConfigCopyWithImpl<$Res,
        _$GossipSourceConfig_P2PNetworkImpl>
    implements _$$GossipSourceConfig_P2PNetworkImplCopyWith<$Res> {
  __$$GossipSourceConfig_P2PNetworkImplCopyWithImpl(
      _$GossipSourceConfig_P2PNetworkImpl _value,
      $Res Function(_$GossipSourceConfig_P2PNetworkImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GossipSourceConfig_P2PNetworkImpl
    extends GossipSourceConfig_P2PNetwork {
  const _$GossipSourceConfig_P2PNetworkImpl() : super._();

  @override
  String toString() {
    return 'GossipSourceConfig.p2PNetwork()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GossipSourceConfig_P2PNetworkImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() p2PNetwork,
    required TResult Function(String field0) rapidGossipSync,
  }) {
    return p2PNetwork();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? p2PNetwork,
    TResult? Function(String field0)? rapidGossipSync,
  }) {
    return p2PNetwork?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? p2PNetwork,
    TResult Function(String field0)? rapidGossipSync,
    required TResult orElse(),
  }) {
    if (p2PNetwork != null) {
      return p2PNetwork();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GossipSourceConfig_P2PNetwork value) p2PNetwork,
    required TResult Function(GossipSourceConfig_RapidGossipSync value)
        rapidGossipSync,
  }) {
    return p2PNetwork(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GossipSourceConfig_P2PNetwork value)? p2PNetwork,
    TResult? Function(GossipSourceConfig_RapidGossipSync value)?
        rapidGossipSync,
  }) {
    return p2PNetwork?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GossipSourceConfig_P2PNetwork value)? p2PNetwork,
    TResult Function(GossipSourceConfig_RapidGossipSync value)? rapidGossipSync,
    required TResult orElse(),
  }) {
    if (p2PNetwork != null) {
      return p2PNetwork(this);
    }
    return orElse();
  }
}

abstract class GossipSourceConfig_P2PNetwork extends GossipSourceConfig {
  const factory GossipSourceConfig_P2PNetwork() =
      _$GossipSourceConfig_P2PNetworkImpl;
  const GossipSourceConfig_P2PNetwork._() : super._();
}

/// @nodoc
abstract class _$$GossipSourceConfig_RapidGossipSyncImplCopyWith<$Res> {
  factory _$$GossipSourceConfig_RapidGossipSyncImplCopyWith(
          _$GossipSourceConfig_RapidGossipSyncImpl value,
          $Res Function(_$GossipSourceConfig_RapidGossipSyncImpl) then) =
      __$$GossipSourceConfig_RapidGossipSyncImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$GossipSourceConfig_RapidGossipSyncImplCopyWithImpl<$Res>
    extends _$GossipSourceConfigCopyWithImpl<$Res,
        _$GossipSourceConfig_RapidGossipSyncImpl>
    implements _$$GossipSourceConfig_RapidGossipSyncImplCopyWith<$Res> {
  __$$GossipSourceConfig_RapidGossipSyncImplCopyWithImpl(
      _$GossipSourceConfig_RapidGossipSyncImpl _value,
      $Res Function(_$GossipSourceConfig_RapidGossipSyncImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$GossipSourceConfig_RapidGossipSyncImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$GossipSourceConfig_RapidGossipSyncImpl
    extends GossipSourceConfig_RapidGossipSync {
  const _$GossipSourceConfig_RapidGossipSyncImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'GossipSourceConfig.rapidGossipSync(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GossipSourceConfig_RapidGossipSyncImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GossipSourceConfig_RapidGossipSyncImplCopyWith<
          _$GossipSourceConfig_RapidGossipSyncImpl>
      get copyWith => __$$GossipSourceConfig_RapidGossipSyncImplCopyWithImpl<
          _$GossipSourceConfig_RapidGossipSyncImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() p2PNetwork,
    required TResult Function(String field0) rapidGossipSync,
  }) {
    return rapidGossipSync(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? p2PNetwork,
    TResult? Function(String field0)? rapidGossipSync,
  }) {
    return rapidGossipSync?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? p2PNetwork,
    TResult Function(String field0)? rapidGossipSync,
    required TResult orElse(),
  }) {
    if (rapidGossipSync != null) {
      return rapidGossipSync(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GossipSourceConfig_P2PNetwork value) p2PNetwork,
    required TResult Function(GossipSourceConfig_RapidGossipSync value)
        rapidGossipSync,
  }) {
    return rapidGossipSync(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GossipSourceConfig_P2PNetwork value)? p2PNetwork,
    TResult? Function(GossipSourceConfig_RapidGossipSync value)?
        rapidGossipSync,
  }) {
    return rapidGossipSync?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GossipSourceConfig_P2PNetwork value)? p2PNetwork,
    TResult Function(GossipSourceConfig_RapidGossipSync value)? rapidGossipSync,
    required TResult orElse(),
  }) {
    if (rapidGossipSync != null) {
      return rapidGossipSync(this);
    }
    return orElse();
  }
}

abstract class GossipSourceConfig_RapidGossipSync extends GossipSourceConfig {
  const factory GossipSourceConfig_RapidGossipSync(final String field0) =
      _$GossipSourceConfig_RapidGossipSyncImpl;
  const GossipSourceConfig_RapidGossipSync._() : super._();

  String get field0;
  @JsonKey(ignore: true)
  _$$GossipSourceConfig_RapidGossipSyncImplCopyWith<
          _$GossipSourceConfig_RapidGossipSyncImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$LightningBalance {
  /// The identifier of the channel this balance belongs to.
  ChannelId get channelId => throw _privateConstructorUsedError;

  /// The identifier of our channel counterparty.
  PublicKey get counterpartyNodeId => throw _privateConstructorUsedError;

  /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
  /// required to do so.
  int get amountSatoshis => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        claimableOnChannelClose,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)
        claimableAwaitingConfirmations,
    required TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)
        contentiousClaimable,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)
        maybeTimeoutClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)
        maybePreimageClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        counterpartyRevokedOutputClaimable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult? Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LightningBalance_ClaimableOnChannelClose value)
        claimableOnChannelClose,
    required TResult Function(
            LightningBalance_ClaimableAwaitingConfirmations value)
        claimableAwaitingConfirmations,
    required TResult Function(LightningBalance_ContentiousClaimable value)
        contentiousClaimable,
    required TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)
        maybeTimeoutClaimableHtlc,
    required TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)
        maybePreimageClaimableHtlc,
    required TResult Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)
        counterpartyRevokedOutputClaimable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult? Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult? Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult? Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult? Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult Function(LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LightningBalanceCopyWith<LightningBalance> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LightningBalanceCopyWith<$Res> {
  factory $LightningBalanceCopyWith(
          LightningBalance value, $Res Function(LightningBalance) then) =
      _$LightningBalanceCopyWithImpl<$Res, LightningBalance>;
  @useResult
  $Res call(
      {ChannelId channelId, PublicKey counterpartyNodeId, int amountSatoshis});
}

/// @nodoc
class _$LightningBalanceCopyWithImpl<$Res, $Val extends LightningBalance>
    implements $LightningBalanceCopyWith<$Res> {
  _$LightningBalanceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? counterpartyNodeId = null,
    Object? amountSatoshis = null,
  }) {
    return _then(_value.copyWith(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      counterpartyNodeId: null == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LightningBalance_ClaimableOnChannelCloseImplCopyWith<$Res>
    implements $LightningBalanceCopyWith<$Res> {
  factory _$$LightningBalance_ClaimableOnChannelCloseImplCopyWith(
          _$LightningBalance_ClaimableOnChannelCloseImpl value,
          $Res Function(_$LightningBalance_ClaimableOnChannelCloseImpl) then) =
      __$$LightningBalance_ClaimableOnChannelCloseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChannelId channelId, PublicKey counterpartyNodeId, int amountSatoshis});
}

/// @nodoc
class __$$LightningBalance_ClaimableOnChannelCloseImplCopyWithImpl<$Res>
    extends _$LightningBalanceCopyWithImpl<$Res,
        _$LightningBalance_ClaimableOnChannelCloseImpl>
    implements _$$LightningBalance_ClaimableOnChannelCloseImplCopyWith<$Res> {
  __$$LightningBalance_ClaimableOnChannelCloseImplCopyWithImpl(
      _$LightningBalance_ClaimableOnChannelCloseImpl _value,
      $Res Function(_$LightningBalance_ClaimableOnChannelCloseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? counterpartyNodeId = null,
    Object? amountSatoshis = null,
  }) {
    return _then(_$LightningBalance_ClaimableOnChannelCloseImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      counterpartyNodeId: null == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LightningBalance_ClaimableOnChannelCloseImpl
    extends LightningBalance_ClaimableOnChannelClose {
  const _$LightningBalance_ClaimableOnChannelCloseImpl(
      {required this.channelId,
      required this.counterpartyNodeId,
      required this.amountSatoshis})
      : super._();

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId channelId;

  /// The identifier of our channel counterparty.
  @override
  final PublicKey counterpartyNodeId;

  /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
  /// required to do so.
  @override
  final int amountSatoshis;

  @override
  String toString() {
    return 'LightningBalance.claimableOnChannelClose(channelId: $channelId, counterpartyNodeId: $counterpartyNodeId, amountSatoshis: $amountSatoshis)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LightningBalance_ClaimableOnChannelCloseImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, channelId, counterpartyNodeId, amountSatoshis);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LightningBalance_ClaimableOnChannelCloseImplCopyWith<
          _$LightningBalance_ClaimableOnChannelCloseImpl>
      get copyWith =>
          __$$LightningBalance_ClaimableOnChannelCloseImplCopyWithImpl<
              _$LightningBalance_ClaimableOnChannelCloseImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        claimableOnChannelClose,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)
        claimableAwaitingConfirmations,
    required TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)
        contentiousClaimable,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)
        maybeTimeoutClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)
        maybePreimageClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        counterpartyRevokedOutputClaimable,
  }) {
    return claimableOnChannelClose(
        channelId, counterpartyNodeId, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult? Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
  }) {
    return claimableOnChannelClose?.call(
        channelId, counterpartyNodeId, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (claimableOnChannelClose != null) {
      return claimableOnChannelClose(
          channelId, counterpartyNodeId, amountSatoshis);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LightningBalance_ClaimableOnChannelClose value)
        claimableOnChannelClose,
    required TResult Function(
            LightningBalance_ClaimableAwaitingConfirmations value)
        claimableAwaitingConfirmations,
    required TResult Function(LightningBalance_ContentiousClaimable value)
        contentiousClaimable,
    required TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)
        maybeTimeoutClaimableHtlc,
    required TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)
        maybePreimageClaimableHtlc,
    required TResult Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)
        counterpartyRevokedOutputClaimable,
  }) {
    return claimableOnChannelClose(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult? Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult? Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult? Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult? Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
  }) {
    return claimableOnChannelClose?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult Function(LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (claimableOnChannelClose != null) {
      return claimableOnChannelClose(this);
    }
    return orElse();
  }
}

abstract class LightningBalance_ClaimableOnChannelClose
    extends LightningBalance {
  const factory LightningBalance_ClaimableOnChannelClose(
          {required final ChannelId channelId,
          required final PublicKey counterpartyNodeId,
          required final int amountSatoshis}) =
      _$LightningBalance_ClaimableOnChannelCloseImpl;
  const LightningBalance_ClaimableOnChannelClose._() : super._();

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId get channelId;
  @override

  /// The identifier of our channel counterparty.
  PublicKey get counterpartyNodeId;
  @override

  /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
  /// required to do so.
  int get amountSatoshis;
  @override
  @JsonKey(ignore: true)
  _$$LightningBalance_ClaimableOnChannelCloseImplCopyWith<
          _$LightningBalance_ClaimableOnChannelCloseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWith<
    $Res> implements $LightningBalanceCopyWith<$Res> {
  factory _$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWith(
          _$LightningBalance_ClaimableAwaitingConfirmationsImpl value,
          $Res Function(_$LightningBalance_ClaimableAwaitingConfirmationsImpl)
              then) =
      __$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChannelId channelId,
      PublicKey counterpartyNodeId,
      int amountSatoshis,
      int confirmationHeight});
}

/// @nodoc
class __$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWithImpl<$Res>
    extends _$LightningBalanceCopyWithImpl<$Res,
        _$LightningBalance_ClaimableAwaitingConfirmationsImpl>
    implements
        _$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWith<$Res> {
  __$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWithImpl(
      _$LightningBalance_ClaimableAwaitingConfirmationsImpl _value,
      $Res Function(_$LightningBalance_ClaimableAwaitingConfirmationsImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? counterpartyNodeId = null,
    Object? amountSatoshis = null,
    Object? confirmationHeight = null,
  }) {
    return _then(_$LightningBalance_ClaimableAwaitingConfirmationsImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      counterpartyNodeId: null == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
      confirmationHeight: null == confirmationHeight
          ? _value.confirmationHeight
          : confirmationHeight // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LightningBalance_ClaimableAwaitingConfirmationsImpl
    extends LightningBalance_ClaimableAwaitingConfirmations {
  const _$LightningBalance_ClaimableAwaitingConfirmationsImpl(
      {required this.channelId,
      required this.counterpartyNodeId,
      required this.amountSatoshis,
      required this.confirmationHeight})
      : super._();

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId channelId;

  /// The identifier of our channel counterparty.
  @override
  final PublicKey counterpartyNodeId;

  /// The amount available to claim, in satoshis, possibly excluding the on-chain fees which
  /// were spent in broadcasting the transaction.
  @override
  final int amountSatoshis;

  /// The height at which an [`Event::SpendableOutputs`] event will be generated for this
  /// amount.
  ///
  /// [`Event::SpendableOutputs`]: lightning::events::Event::SpendableOutputs
  @override
  final int confirmationHeight;

  @override
  String toString() {
    return 'LightningBalance.claimableAwaitingConfirmations(channelId: $channelId, counterpartyNodeId: $counterpartyNodeId, amountSatoshis: $amountSatoshis, confirmationHeight: $confirmationHeight)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LightningBalance_ClaimableAwaitingConfirmationsImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis) &&
            (identical(other.confirmationHeight, confirmationHeight) ||
                other.confirmationHeight == confirmationHeight));
  }

  @override
  int get hashCode => Object.hash(runtimeType, channelId, counterpartyNodeId,
      amountSatoshis, confirmationHeight);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWith<
          _$LightningBalance_ClaimableAwaitingConfirmationsImpl>
      get copyWith =>
          __$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWithImpl<
                  _$LightningBalance_ClaimableAwaitingConfirmationsImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        claimableOnChannelClose,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)
        claimableAwaitingConfirmations,
    required TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)
        contentiousClaimable,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)
        maybeTimeoutClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)
        maybePreimageClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        counterpartyRevokedOutputClaimable,
  }) {
    return claimableAwaitingConfirmations(
        channelId, counterpartyNodeId, amountSatoshis, confirmationHeight);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult? Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
  }) {
    return claimableAwaitingConfirmations?.call(
        channelId, counterpartyNodeId, amountSatoshis, confirmationHeight);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (claimableAwaitingConfirmations != null) {
      return claimableAwaitingConfirmations(
          channelId, counterpartyNodeId, amountSatoshis, confirmationHeight);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LightningBalance_ClaimableOnChannelClose value)
        claimableOnChannelClose,
    required TResult Function(
            LightningBalance_ClaimableAwaitingConfirmations value)
        claimableAwaitingConfirmations,
    required TResult Function(LightningBalance_ContentiousClaimable value)
        contentiousClaimable,
    required TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)
        maybeTimeoutClaimableHtlc,
    required TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)
        maybePreimageClaimableHtlc,
    required TResult Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)
        counterpartyRevokedOutputClaimable,
  }) {
    return claimableAwaitingConfirmations(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult? Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult? Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult? Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult? Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
  }) {
    return claimableAwaitingConfirmations?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult Function(LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (claimableAwaitingConfirmations != null) {
      return claimableAwaitingConfirmations(this);
    }
    return orElse();
  }
}

abstract class LightningBalance_ClaimableAwaitingConfirmations
    extends LightningBalance {
  const factory LightningBalance_ClaimableAwaitingConfirmations(
          {required final ChannelId channelId,
          required final PublicKey counterpartyNodeId,
          required final int amountSatoshis,
          required final int confirmationHeight}) =
      _$LightningBalance_ClaimableAwaitingConfirmationsImpl;
  const LightningBalance_ClaimableAwaitingConfirmations._() : super._();

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId get channelId;
  @override

  /// The identifier of our channel counterparty.
  PublicKey get counterpartyNodeId;
  @override

  /// The amount available to claim, in satoshis, possibly excluding the on-chain fees which
  /// were spent in broadcasting the transaction.
  int get amountSatoshis;

  /// The height at which an [`Event::SpendableOutputs`] event will be generated for this
  /// amount.
  ///
  /// [`Event::SpendableOutputs`]: lightning::events::Event::SpendableOutputs
  int get confirmationHeight;
  @override
  @JsonKey(ignore: true)
  _$$LightningBalance_ClaimableAwaitingConfirmationsImplCopyWith<
          _$LightningBalance_ClaimableAwaitingConfirmationsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LightningBalance_ContentiousClaimableImplCopyWith<$Res>
    implements $LightningBalanceCopyWith<$Res> {
  factory _$$LightningBalance_ContentiousClaimableImplCopyWith(
          _$LightningBalance_ContentiousClaimableImpl value,
          $Res Function(_$LightningBalance_ContentiousClaimableImpl) then) =
      __$$LightningBalance_ContentiousClaimableImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChannelId channelId,
      PublicKey counterpartyNodeId,
      int amountSatoshis,
      int timeoutHeight,
      PaymentHash paymentHash,
      PaymentPreimage paymentPreimage});
}

/// @nodoc
class __$$LightningBalance_ContentiousClaimableImplCopyWithImpl<$Res>
    extends _$LightningBalanceCopyWithImpl<$Res,
        _$LightningBalance_ContentiousClaimableImpl>
    implements _$$LightningBalance_ContentiousClaimableImplCopyWith<$Res> {
  __$$LightningBalance_ContentiousClaimableImplCopyWithImpl(
      _$LightningBalance_ContentiousClaimableImpl _value,
      $Res Function(_$LightningBalance_ContentiousClaimableImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? counterpartyNodeId = null,
    Object? amountSatoshis = null,
    Object? timeoutHeight = null,
    Object? paymentHash = null,
    Object? paymentPreimage = null,
  }) {
    return _then(_$LightningBalance_ContentiousClaimableImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      counterpartyNodeId: null == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
      timeoutHeight: null == timeoutHeight
          ? _value.timeoutHeight
          : timeoutHeight // ignore: cast_nullable_to_non_nullable
              as int,
      paymentHash: null == paymentHash
          ? _value.paymentHash
          : paymentHash // ignore: cast_nullable_to_non_nullable
              as PaymentHash,
      paymentPreimage: null == paymentPreimage
          ? _value.paymentPreimage
          : paymentPreimage // ignore: cast_nullable_to_non_nullable
              as PaymentPreimage,
    ));
  }
}

/// @nodoc

class _$LightningBalance_ContentiousClaimableImpl
    extends LightningBalance_ContentiousClaimable {
  const _$LightningBalance_ContentiousClaimableImpl(
      {required this.channelId,
      required this.counterpartyNodeId,
      required this.amountSatoshis,
      required this.timeoutHeight,
      required this.paymentHash,
      required this.paymentPreimage})
      : super._();

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId channelId;

  /// The identifier of our channel counterparty.
  @override
  final PublicKey counterpartyNodeId;

  /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
  /// required to do so.
  @override
  final int amountSatoshis;

  /// The height at which the counterparty may be able to claim the balance if we have not
  /// done so.
  @override
  final int timeoutHeight;

  /// The payment hash that locks this HTLC.
  @override
  final PaymentHash paymentHash;

  /// The preimage that can be used to claim this HTLC.
  @override
  final PaymentPreimage paymentPreimage;

  @override
  String toString() {
    return 'LightningBalance.contentiousClaimable(channelId: $channelId, counterpartyNodeId: $counterpartyNodeId, amountSatoshis: $amountSatoshis, timeoutHeight: $timeoutHeight, paymentHash: $paymentHash, paymentPreimage: $paymentPreimage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LightningBalance_ContentiousClaimableImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis) &&
            (identical(other.timeoutHeight, timeoutHeight) ||
                other.timeoutHeight == timeoutHeight) &&
            (identical(other.paymentHash, paymentHash) ||
                other.paymentHash == paymentHash) &&
            (identical(other.paymentPreimage, paymentPreimage) ||
                other.paymentPreimage == paymentPreimage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, channelId, counterpartyNodeId,
      amountSatoshis, timeoutHeight, paymentHash, paymentPreimage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LightningBalance_ContentiousClaimableImplCopyWith<
          _$LightningBalance_ContentiousClaimableImpl>
      get copyWith => __$$LightningBalance_ContentiousClaimableImplCopyWithImpl<
          _$LightningBalance_ContentiousClaimableImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        claimableOnChannelClose,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)
        claimableAwaitingConfirmations,
    required TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)
        contentiousClaimable,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)
        maybeTimeoutClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)
        maybePreimageClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        counterpartyRevokedOutputClaimable,
  }) {
    return contentiousClaimable(channelId, counterpartyNodeId, amountSatoshis,
        timeoutHeight, paymentHash, paymentPreimage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult? Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
  }) {
    return contentiousClaimable?.call(channelId, counterpartyNodeId,
        amountSatoshis, timeoutHeight, paymentHash, paymentPreimage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (contentiousClaimable != null) {
      return contentiousClaimable(channelId, counterpartyNodeId, amountSatoshis,
          timeoutHeight, paymentHash, paymentPreimage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LightningBalance_ClaimableOnChannelClose value)
        claimableOnChannelClose,
    required TResult Function(
            LightningBalance_ClaimableAwaitingConfirmations value)
        claimableAwaitingConfirmations,
    required TResult Function(LightningBalance_ContentiousClaimable value)
        contentiousClaimable,
    required TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)
        maybeTimeoutClaimableHtlc,
    required TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)
        maybePreimageClaimableHtlc,
    required TResult Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)
        counterpartyRevokedOutputClaimable,
  }) {
    return contentiousClaimable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult? Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult? Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult? Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult? Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
  }) {
    return contentiousClaimable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult Function(LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (contentiousClaimable != null) {
      return contentiousClaimable(this);
    }
    return orElse();
  }
}

abstract class LightningBalance_ContentiousClaimable extends LightningBalance {
  const factory LightningBalance_ContentiousClaimable(
          {required final ChannelId channelId,
          required final PublicKey counterpartyNodeId,
          required final int amountSatoshis,
          required final int timeoutHeight,
          required final PaymentHash paymentHash,
          required final PaymentPreimage paymentPreimage}) =
      _$LightningBalance_ContentiousClaimableImpl;
  const LightningBalance_ContentiousClaimable._() : super._();

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId get channelId;
  @override

  /// The identifier of our channel counterparty.
  PublicKey get counterpartyNodeId;
  @override

  /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
  /// required to do so.
  int get amountSatoshis;

  /// The height at which the counterparty may be able to claim the balance if we have not
  /// done so.
  int get timeoutHeight;

  /// The payment hash that locks this HTLC.
  PaymentHash get paymentHash;

  /// The preimage that can be used to claim this HTLC.
  PaymentPreimage get paymentPreimage;
  @override
  @JsonKey(ignore: true)
  _$$LightningBalance_ContentiousClaimableImplCopyWith<
          _$LightningBalance_ContentiousClaimableImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWith<$Res>
    implements $LightningBalanceCopyWith<$Res> {
  factory _$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWith(
          _$LightningBalance_MaybeTimeoutClaimableHTLCImpl value,
          $Res Function(_$LightningBalance_MaybeTimeoutClaimableHTLCImpl)
              then) =
      __$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChannelId channelId,
      PublicKey counterpartyNodeId,
      int amountSatoshis,
      int claimableHeight,
      PaymentHash paymentHash});
}

/// @nodoc
class __$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWithImpl<$Res>
    extends _$LightningBalanceCopyWithImpl<$Res,
        _$LightningBalance_MaybeTimeoutClaimableHTLCImpl>
    implements _$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWith<$Res> {
  __$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWithImpl(
      _$LightningBalance_MaybeTimeoutClaimableHTLCImpl _value,
      $Res Function(_$LightningBalance_MaybeTimeoutClaimableHTLCImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? counterpartyNodeId = null,
    Object? amountSatoshis = null,
    Object? claimableHeight = null,
    Object? paymentHash = null,
  }) {
    return _then(_$LightningBalance_MaybeTimeoutClaimableHTLCImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      counterpartyNodeId: null == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
      claimableHeight: null == claimableHeight
          ? _value.claimableHeight
          : claimableHeight // ignore: cast_nullable_to_non_nullable
              as int,
      paymentHash: null == paymentHash
          ? _value.paymentHash
          : paymentHash // ignore: cast_nullable_to_non_nullable
              as PaymentHash,
    ));
  }
}

/// @nodoc

class _$LightningBalance_MaybeTimeoutClaimableHTLCImpl
    extends LightningBalance_MaybeTimeoutClaimableHTLC {
  const _$LightningBalance_MaybeTimeoutClaimableHTLCImpl(
      {required this.channelId,
      required this.counterpartyNodeId,
      required this.amountSatoshis,
      required this.claimableHeight,
      required this.paymentHash})
      : super._();

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId channelId;

  /// The identifier of our channel counterparty.
  @override
  final PublicKey counterpartyNodeId;

  /// The amount potentially available to claim, in satoshis, excluding the on-chain fees
  /// which will be required to do so.
  @override
  final int amountSatoshis;

  /// The height at which we will be able to claim the balance if our counterparty has not
  /// done so.
  @override
  final int claimableHeight;

  /// The payment hash whose preimage our counterparty needs to claim this HTLC.
  @override
  final PaymentHash paymentHash;

  @override
  String toString() {
    return 'LightningBalance.maybeTimeoutClaimableHtlc(channelId: $channelId, counterpartyNodeId: $counterpartyNodeId, amountSatoshis: $amountSatoshis, claimableHeight: $claimableHeight, paymentHash: $paymentHash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LightningBalance_MaybeTimeoutClaimableHTLCImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis) &&
            (identical(other.claimableHeight, claimableHeight) ||
                other.claimableHeight == claimableHeight) &&
            (identical(other.paymentHash, paymentHash) ||
                other.paymentHash == paymentHash));
  }

  @override
  int get hashCode => Object.hash(runtimeType, channelId, counterpartyNodeId,
      amountSatoshis, claimableHeight, paymentHash);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWith<
          _$LightningBalance_MaybeTimeoutClaimableHTLCImpl>
      get copyWith =>
          __$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWithImpl<
                  _$LightningBalance_MaybeTimeoutClaimableHTLCImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        claimableOnChannelClose,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)
        claimableAwaitingConfirmations,
    required TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)
        contentiousClaimable,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)
        maybeTimeoutClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)
        maybePreimageClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        counterpartyRevokedOutputClaimable,
  }) {
    return maybeTimeoutClaimableHtlc(channelId, counterpartyNodeId,
        amountSatoshis, claimableHeight, paymentHash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult? Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
  }) {
    return maybeTimeoutClaimableHtlc?.call(channelId, counterpartyNodeId,
        amountSatoshis, claimableHeight, paymentHash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (maybeTimeoutClaimableHtlc != null) {
      return maybeTimeoutClaimableHtlc(channelId, counterpartyNodeId,
          amountSatoshis, claimableHeight, paymentHash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LightningBalance_ClaimableOnChannelClose value)
        claimableOnChannelClose,
    required TResult Function(
            LightningBalance_ClaimableAwaitingConfirmations value)
        claimableAwaitingConfirmations,
    required TResult Function(LightningBalance_ContentiousClaimable value)
        contentiousClaimable,
    required TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)
        maybeTimeoutClaimableHtlc,
    required TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)
        maybePreimageClaimableHtlc,
    required TResult Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)
        counterpartyRevokedOutputClaimable,
  }) {
    return maybeTimeoutClaimableHtlc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult? Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult? Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult? Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult? Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
  }) {
    return maybeTimeoutClaimableHtlc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult Function(LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (maybeTimeoutClaimableHtlc != null) {
      return maybeTimeoutClaimableHtlc(this);
    }
    return orElse();
  }
}

abstract class LightningBalance_MaybeTimeoutClaimableHTLC
    extends LightningBalance {
  const factory LightningBalance_MaybeTimeoutClaimableHTLC(
          {required final ChannelId channelId,
          required final PublicKey counterpartyNodeId,
          required final int amountSatoshis,
          required final int claimableHeight,
          required final PaymentHash paymentHash}) =
      _$LightningBalance_MaybeTimeoutClaimableHTLCImpl;
  const LightningBalance_MaybeTimeoutClaimableHTLC._() : super._();

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId get channelId;
  @override

  /// The identifier of our channel counterparty.
  PublicKey get counterpartyNodeId;
  @override

  /// The amount potentially available to claim, in satoshis, excluding the on-chain fees
  /// which will be required to do so.
  int get amountSatoshis;

  /// The height at which we will be able to claim the balance if our counterparty has not
  /// done so.
  int get claimableHeight;

  /// The payment hash whose preimage our counterparty needs to claim this HTLC.
  PaymentHash get paymentHash;
  @override
  @JsonKey(ignore: true)
  _$$LightningBalance_MaybeTimeoutClaimableHTLCImplCopyWith<
          _$LightningBalance_MaybeTimeoutClaimableHTLCImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWith<$Res>
    implements $LightningBalanceCopyWith<$Res> {
  factory _$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWith(
          _$LightningBalance_MaybePreimageClaimableHTLCImpl value,
          $Res Function(_$LightningBalance_MaybePreimageClaimableHTLCImpl)
              then) =
      __$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ChannelId channelId,
      PublicKey counterpartyNodeId,
      int amountSatoshis,
      int expiryHeight,
      PaymentHash paymentHash});
}

/// @nodoc
class __$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWithImpl<$Res>
    extends _$LightningBalanceCopyWithImpl<$Res,
        _$LightningBalance_MaybePreimageClaimableHTLCImpl>
    implements
        _$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWith<$Res> {
  __$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWithImpl(
      _$LightningBalance_MaybePreimageClaimableHTLCImpl _value,
      $Res Function(_$LightningBalance_MaybePreimageClaimableHTLCImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? counterpartyNodeId = null,
    Object? amountSatoshis = null,
    Object? expiryHeight = null,
    Object? paymentHash = null,
  }) {
    return _then(_$LightningBalance_MaybePreimageClaimableHTLCImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      counterpartyNodeId: null == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
      expiryHeight: null == expiryHeight
          ? _value.expiryHeight
          : expiryHeight // ignore: cast_nullable_to_non_nullable
              as int,
      paymentHash: null == paymentHash
          ? _value.paymentHash
          : paymentHash // ignore: cast_nullable_to_non_nullable
              as PaymentHash,
    ));
  }
}

/// @nodoc

class _$LightningBalance_MaybePreimageClaimableHTLCImpl
    extends LightningBalance_MaybePreimageClaimableHTLC {
  const _$LightningBalance_MaybePreimageClaimableHTLCImpl(
      {required this.channelId,
      required this.counterpartyNodeId,
      required this.amountSatoshis,
      required this.expiryHeight,
      required this.paymentHash})
      : super._();

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId channelId;

  /// The identifier of our channel counterparty.
  @override
  final PublicKey counterpartyNodeId;

  /// The amount potentially available to claim, in satoshis, excluding the on-chain fees
  /// which will be required to do so.
  @override
  final int amountSatoshis;

  /// The height at which our counterparty will be able to claim the balance if we have not
  /// yet received the preimage and claimed it ourselves.
  @override
  final int expiryHeight;

  /// The payment hash whose preimage we need to claim this HTLC.
  @override
  final PaymentHash paymentHash;

  @override
  String toString() {
    return 'LightningBalance.maybePreimageClaimableHtlc(channelId: $channelId, counterpartyNodeId: $counterpartyNodeId, amountSatoshis: $amountSatoshis, expiryHeight: $expiryHeight, paymentHash: $paymentHash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LightningBalance_MaybePreimageClaimableHTLCImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis) &&
            (identical(other.expiryHeight, expiryHeight) ||
                other.expiryHeight == expiryHeight) &&
            (identical(other.paymentHash, paymentHash) ||
                other.paymentHash == paymentHash));
  }

  @override
  int get hashCode => Object.hash(runtimeType, channelId, counterpartyNodeId,
      amountSatoshis, expiryHeight, paymentHash);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWith<
          _$LightningBalance_MaybePreimageClaimableHTLCImpl>
      get copyWith =>
          __$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWithImpl<
                  _$LightningBalance_MaybePreimageClaimableHTLCImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        claimableOnChannelClose,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)
        claimableAwaitingConfirmations,
    required TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)
        contentiousClaimable,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)
        maybeTimeoutClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)
        maybePreimageClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        counterpartyRevokedOutputClaimable,
  }) {
    return maybePreimageClaimableHtlc(channelId, counterpartyNodeId,
        amountSatoshis, expiryHeight, paymentHash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult? Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
  }) {
    return maybePreimageClaimableHtlc?.call(channelId, counterpartyNodeId,
        amountSatoshis, expiryHeight, paymentHash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (maybePreimageClaimableHtlc != null) {
      return maybePreimageClaimableHtlc(channelId, counterpartyNodeId,
          amountSatoshis, expiryHeight, paymentHash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LightningBalance_ClaimableOnChannelClose value)
        claimableOnChannelClose,
    required TResult Function(
            LightningBalance_ClaimableAwaitingConfirmations value)
        claimableAwaitingConfirmations,
    required TResult Function(LightningBalance_ContentiousClaimable value)
        contentiousClaimable,
    required TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)
        maybeTimeoutClaimableHtlc,
    required TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)
        maybePreimageClaimableHtlc,
    required TResult Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)
        counterpartyRevokedOutputClaimable,
  }) {
    return maybePreimageClaimableHtlc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult? Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult? Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult? Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult? Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
  }) {
    return maybePreimageClaimableHtlc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult Function(LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (maybePreimageClaimableHtlc != null) {
      return maybePreimageClaimableHtlc(this);
    }
    return orElse();
  }
}

abstract class LightningBalance_MaybePreimageClaimableHTLC
    extends LightningBalance {
  const factory LightningBalance_MaybePreimageClaimableHTLC(
          {required final ChannelId channelId,
          required final PublicKey counterpartyNodeId,
          required final int amountSatoshis,
          required final int expiryHeight,
          required final PaymentHash paymentHash}) =
      _$LightningBalance_MaybePreimageClaimableHTLCImpl;
  const LightningBalance_MaybePreimageClaimableHTLC._() : super._();

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId get channelId;
  @override

  /// The identifier of our channel counterparty.
  PublicKey get counterpartyNodeId;
  @override

  /// The amount potentially available to claim, in satoshis, excluding the on-chain fees
  /// which will be required to do so.
  int get amountSatoshis;

  /// The height at which our counterparty will be able to claim the balance if we have not
  /// yet received the preimage and claimed it ourselves.
  int get expiryHeight;

  /// The payment hash whose preimage we need to claim this HTLC.
  PaymentHash get paymentHash;
  @override
  @JsonKey(ignore: true)
  _$$LightningBalance_MaybePreimageClaimableHTLCImplCopyWith<
          _$LightningBalance_MaybePreimageClaimableHTLCImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWith<
    $Res> implements $LightningBalanceCopyWith<$Res> {
  factory _$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWith(
          _$LightningBalance_CounterpartyRevokedOutputClaimableImpl value,
          $Res Function(
                  _$LightningBalance_CounterpartyRevokedOutputClaimableImpl)
              then) =
      __$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call(
      {ChannelId channelId, PublicKey counterpartyNodeId, int amountSatoshis});
}

/// @nodoc
class __$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWithImpl<
        $Res>
    extends _$LightningBalanceCopyWithImpl<$Res,
        _$LightningBalance_CounterpartyRevokedOutputClaimableImpl>
    implements
        _$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWith<
            $Res> {
  __$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWithImpl(
      _$LightningBalance_CounterpartyRevokedOutputClaimableImpl _value,
      $Res Function(_$LightningBalance_CounterpartyRevokedOutputClaimableImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = null,
    Object? counterpartyNodeId = null,
    Object? amountSatoshis = null,
  }) {
    return _then(_$LightningBalance_CounterpartyRevokedOutputClaimableImpl(
      channelId: null == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId,
      counterpartyNodeId: null == counterpartyNodeId
          ? _value.counterpartyNodeId
          : counterpartyNodeId // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LightningBalance_CounterpartyRevokedOutputClaimableImpl
    extends LightningBalance_CounterpartyRevokedOutputClaimable {
  const _$LightningBalance_CounterpartyRevokedOutputClaimableImpl(
      {required this.channelId,
      required this.counterpartyNodeId,
      required this.amountSatoshis})
      : super._();

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId channelId;

  /// The identifier of our channel counterparty.
  @override
  final PublicKey counterpartyNodeId;

  /// The amount, in satoshis, of the output which we can claim.
  @override
  final int amountSatoshis;

  @override
  String toString() {
    return 'LightningBalance.counterpartyRevokedOutputClaimable(channelId: $channelId, counterpartyNodeId: $counterpartyNodeId, amountSatoshis: $amountSatoshis)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$LightningBalance_CounterpartyRevokedOutputClaimableImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.counterpartyNodeId, counterpartyNodeId) ||
                other.counterpartyNodeId == counterpartyNodeId) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, channelId, counterpartyNodeId, amountSatoshis);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWith<
          _$LightningBalance_CounterpartyRevokedOutputClaimableImpl>
      get copyWith =>
          __$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWithImpl<
                  _$LightningBalance_CounterpartyRevokedOutputClaimableImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        claimableOnChannelClose,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)
        claimableAwaitingConfirmations,
    required TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)
        contentiousClaimable,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)
        maybeTimeoutClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)
        maybePreimageClaimableHtlc,
    required TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)
        counterpartyRevokedOutputClaimable,
  }) {
    return counterpartyRevokedOutputClaimable(
        channelId, counterpartyNodeId, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult? Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult? Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
  }) {
    return counterpartyRevokedOutputClaimable?.call(
        channelId, counterpartyNodeId, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        claimableOnChannelClose,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int confirmationHeight)?
        claimableAwaitingConfirmations,
    TResult Function(
            ChannelId channelId,
            PublicKey counterpartyNodeId,
            int amountSatoshis,
            int timeoutHeight,
            PaymentHash paymentHash,
            PaymentPreimage paymentPreimage)?
        contentiousClaimable,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int claimableHeight, PaymentHash paymentHash)?
        maybeTimeoutClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis, int expiryHeight, PaymentHash paymentHash)?
        maybePreimageClaimableHtlc,
    TResult Function(ChannelId channelId, PublicKey counterpartyNodeId,
            int amountSatoshis)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (counterpartyRevokedOutputClaimable != null) {
      return counterpartyRevokedOutputClaimable(
          channelId, counterpartyNodeId, amountSatoshis);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LightningBalance_ClaimableOnChannelClose value)
        claimableOnChannelClose,
    required TResult Function(
            LightningBalance_ClaimableAwaitingConfirmations value)
        claimableAwaitingConfirmations,
    required TResult Function(LightningBalance_ContentiousClaimable value)
        contentiousClaimable,
    required TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)
        maybeTimeoutClaimableHtlc,
    required TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)
        maybePreimageClaimableHtlc,
    required TResult Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)
        counterpartyRevokedOutputClaimable,
  }) {
    return counterpartyRevokedOutputClaimable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult? Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult? Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult? Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult? Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult? Function(
            LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
  }) {
    return counterpartyRevokedOutputClaimable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LightningBalance_ClaimableOnChannelClose value)?
        claimableOnChannelClose,
    TResult Function(LightningBalance_ClaimableAwaitingConfirmations value)?
        claimableAwaitingConfirmations,
    TResult Function(LightningBalance_ContentiousClaimable value)?
        contentiousClaimable,
    TResult Function(LightningBalance_MaybeTimeoutClaimableHTLC value)?
        maybeTimeoutClaimableHtlc,
    TResult Function(LightningBalance_MaybePreimageClaimableHTLC value)?
        maybePreimageClaimableHtlc,
    TResult Function(LightningBalance_CounterpartyRevokedOutputClaimable value)?
        counterpartyRevokedOutputClaimable,
    required TResult orElse(),
  }) {
    if (counterpartyRevokedOutputClaimable != null) {
      return counterpartyRevokedOutputClaimable(this);
    }
    return orElse();
  }
}

abstract class LightningBalance_CounterpartyRevokedOutputClaimable
    extends LightningBalance {
  const factory LightningBalance_CounterpartyRevokedOutputClaimable(
          {required final ChannelId channelId,
          required final PublicKey counterpartyNodeId,
          required final int amountSatoshis}) =
      _$LightningBalance_CounterpartyRevokedOutputClaimableImpl;
  const LightningBalance_CounterpartyRevokedOutputClaimable._() : super._();

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId get channelId;
  @override

  /// The identifier of our channel counterparty.
  PublicKey get counterpartyNodeId;
  @override

  /// The amount, in satoshis, of the output which we can claim.
  int get amountSatoshis;
  @override
  @JsonKey(ignore: true)
  _$$LightningBalance_CounterpartyRevokedOutputClaimableImplCopyWith<
          _$LightningBalance_CounterpartyRevokedOutputClaimableImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MaxDustHTLCExposure {
  int get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) fixedLimitMsat,
    required TResult Function(int field0) feeRateMultiplier,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? fixedLimitMsat,
    TResult? Function(int field0)? feeRateMultiplier,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? fixedLimitMsat,
    TResult Function(int field0)? feeRateMultiplier,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MaxDustHTLCExposure_FixedLimitMsat value)
        fixedLimitMsat,
    required TResult Function(MaxDustHTLCExposure_FeeRateMultiplier value)
        feeRateMultiplier,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MaxDustHTLCExposure_FixedLimitMsat value)? fixedLimitMsat,
    TResult? Function(MaxDustHTLCExposure_FeeRateMultiplier value)?
        feeRateMultiplier,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MaxDustHTLCExposure_FixedLimitMsat value)? fixedLimitMsat,
    TResult Function(MaxDustHTLCExposure_FeeRateMultiplier value)?
        feeRateMultiplier,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MaxDustHTLCExposureCopyWith<MaxDustHTLCExposure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MaxDustHTLCExposureCopyWith<$Res> {
  factory $MaxDustHTLCExposureCopyWith(
          MaxDustHTLCExposure value, $Res Function(MaxDustHTLCExposure) then) =
      _$MaxDustHTLCExposureCopyWithImpl<$Res, MaxDustHTLCExposure>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class _$MaxDustHTLCExposureCopyWithImpl<$Res, $Val extends MaxDustHTLCExposure>
    implements $MaxDustHTLCExposureCopyWith<$Res> {
  _$MaxDustHTLCExposureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_value.copyWith(
      field0: null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWith<$Res>
    implements $MaxDustHTLCExposureCopyWith<$Res> {
  factory _$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWith(
          _$MaxDustHTLCExposure_FixedLimitMsatImpl value,
          $Res Function(_$MaxDustHTLCExposure_FixedLimitMsatImpl) then) =
      __$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWithImpl<$Res>
    extends _$MaxDustHTLCExposureCopyWithImpl<$Res,
        _$MaxDustHTLCExposure_FixedLimitMsatImpl>
    implements _$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWith<$Res> {
  __$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWithImpl(
      _$MaxDustHTLCExposure_FixedLimitMsatImpl _value,
      $Res Function(_$MaxDustHTLCExposure_FixedLimitMsatImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$MaxDustHTLCExposure_FixedLimitMsatImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$MaxDustHTLCExposure_FixedLimitMsatImpl
    extends MaxDustHTLCExposure_FixedLimitMsat {
  const _$MaxDustHTLCExposure_FixedLimitMsatImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'MaxDustHTLCExposure.fixedLimitMsat(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MaxDustHTLCExposure_FixedLimitMsatImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWith<
          _$MaxDustHTLCExposure_FixedLimitMsatImpl>
      get copyWith => __$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWithImpl<
          _$MaxDustHTLCExposure_FixedLimitMsatImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) fixedLimitMsat,
    required TResult Function(int field0) feeRateMultiplier,
  }) {
    return fixedLimitMsat(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? fixedLimitMsat,
    TResult? Function(int field0)? feeRateMultiplier,
  }) {
    return fixedLimitMsat?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? fixedLimitMsat,
    TResult Function(int field0)? feeRateMultiplier,
    required TResult orElse(),
  }) {
    if (fixedLimitMsat != null) {
      return fixedLimitMsat(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MaxDustHTLCExposure_FixedLimitMsat value)
        fixedLimitMsat,
    required TResult Function(MaxDustHTLCExposure_FeeRateMultiplier value)
        feeRateMultiplier,
  }) {
    return fixedLimitMsat(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MaxDustHTLCExposure_FixedLimitMsat value)? fixedLimitMsat,
    TResult? Function(MaxDustHTLCExposure_FeeRateMultiplier value)?
        feeRateMultiplier,
  }) {
    return fixedLimitMsat?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MaxDustHTLCExposure_FixedLimitMsat value)? fixedLimitMsat,
    TResult Function(MaxDustHTLCExposure_FeeRateMultiplier value)?
        feeRateMultiplier,
    required TResult orElse(),
  }) {
    if (fixedLimitMsat != null) {
      return fixedLimitMsat(this);
    }
    return orElse();
  }
}

abstract class MaxDustHTLCExposure_FixedLimitMsat extends MaxDustHTLCExposure {
  const factory MaxDustHTLCExposure_FixedLimitMsat(final int field0) =
      _$MaxDustHTLCExposure_FixedLimitMsatImpl;
  const MaxDustHTLCExposure_FixedLimitMsat._() : super._();

  @override
  int get field0;
  @override
  @JsonKey(ignore: true)
  _$$MaxDustHTLCExposure_FixedLimitMsatImplCopyWith<
          _$MaxDustHTLCExposure_FixedLimitMsatImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWith<$Res>
    implements $MaxDustHTLCExposureCopyWith<$Res> {
  factory _$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWith(
          _$MaxDustHTLCExposure_FeeRateMultiplierImpl value,
          $Res Function(_$MaxDustHTLCExposure_FeeRateMultiplierImpl) then) =
      __$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWithImpl<$Res>
    extends _$MaxDustHTLCExposureCopyWithImpl<$Res,
        _$MaxDustHTLCExposure_FeeRateMultiplierImpl>
    implements _$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWith<$Res> {
  __$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWithImpl(
      _$MaxDustHTLCExposure_FeeRateMultiplierImpl _value,
      $Res Function(_$MaxDustHTLCExposure_FeeRateMultiplierImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$MaxDustHTLCExposure_FeeRateMultiplierImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$MaxDustHTLCExposure_FeeRateMultiplierImpl
    extends MaxDustHTLCExposure_FeeRateMultiplier {
  const _$MaxDustHTLCExposure_FeeRateMultiplierImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'MaxDustHTLCExposure.feeRateMultiplier(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MaxDustHTLCExposure_FeeRateMultiplierImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWith<
          _$MaxDustHTLCExposure_FeeRateMultiplierImpl>
      get copyWith => __$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWithImpl<
          _$MaxDustHTLCExposure_FeeRateMultiplierImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) fixedLimitMsat,
    required TResult Function(int field0) feeRateMultiplier,
  }) {
    return feeRateMultiplier(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? fixedLimitMsat,
    TResult? Function(int field0)? feeRateMultiplier,
  }) {
    return feeRateMultiplier?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? fixedLimitMsat,
    TResult Function(int field0)? feeRateMultiplier,
    required TResult orElse(),
  }) {
    if (feeRateMultiplier != null) {
      return feeRateMultiplier(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MaxDustHTLCExposure_FixedLimitMsat value)
        fixedLimitMsat,
    required TResult Function(MaxDustHTLCExposure_FeeRateMultiplier value)
        feeRateMultiplier,
  }) {
    return feeRateMultiplier(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MaxDustHTLCExposure_FixedLimitMsat value)? fixedLimitMsat,
    TResult? Function(MaxDustHTLCExposure_FeeRateMultiplier value)?
        feeRateMultiplier,
  }) {
    return feeRateMultiplier?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MaxDustHTLCExposure_FixedLimitMsat value)? fixedLimitMsat,
    TResult Function(MaxDustHTLCExposure_FeeRateMultiplier value)?
        feeRateMultiplier,
    required TResult orElse(),
  }) {
    if (feeRateMultiplier != null) {
      return feeRateMultiplier(this);
    }
    return orElse();
  }
}

abstract class MaxDustHTLCExposure_FeeRateMultiplier
    extends MaxDustHTLCExposure {
  const factory MaxDustHTLCExposure_FeeRateMultiplier(final int field0) =
      _$MaxDustHTLCExposure_FeeRateMultiplierImpl;
  const MaxDustHTLCExposure_FeeRateMultiplier._() : super._();

  @override
  int get field0;
  @override
  @JsonKey(ignore: true)
  _$$MaxDustHTLCExposure_FeeRateMultiplierImplCopyWith<
          _$MaxDustHTLCExposure_FeeRateMultiplierImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PaymentKind {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() onchain,
    required TResult Function(
            PaymentHash hash, PaymentPreimage? preimage, PaymentSecret? secret)
        bolt11,
    required TResult Function(PaymentHash hash, PaymentPreimage? preimage,
            PaymentSecret? secret, LSPFeeLimits lspFeeLimits)
        bolt11Jit,
    required TResult Function(PaymentHash hash, PaymentPreimage? preimage)
        spontaneous,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? onchain,
    TResult? Function(
            PaymentHash hash, PaymentPreimage? preimage, PaymentSecret? secret)?
        bolt11,
    TResult? Function(PaymentHash hash, PaymentPreimage? preimage,
            PaymentSecret? secret, LSPFeeLimits lspFeeLimits)?
        bolt11Jit,
    TResult? Function(PaymentHash hash, PaymentPreimage? preimage)? spontaneous,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? onchain,
    TResult Function(
            PaymentHash hash, PaymentPreimage? preimage, PaymentSecret? secret)?
        bolt11,
    TResult Function(PaymentHash hash, PaymentPreimage? preimage,
            PaymentSecret? secret, LSPFeeLimits lspFeeLimits)?
        bolt11Jit,
    TResult Function(PaymentHash hash, PaymentPreimage? preimage)? spontaneous,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentKind_Onchain value) onchain,
    required TResult Function(PaymentKind_Bolt11 value) bolt11,
    required TResult Function(PaymentKind_Bolt11Jit value) bolt11Jit,
    required TResult Function(PaymentKind_Spontaneous value) spontaneous,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentKind_Onchain value)? onchain,
    TResult? Function(PaymentKind_Bolt11 value)? bolt11,
    TResult? Function(PaymentKind_Bolt11Jit value)? bolt11Jit,
    TResult? Function(PaymentKind_Spontaneous value)? spontaneous,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentKind_Onchain value)? onchain,
    TResult Function(PaymentKind_Bolt11 value)? bolt11,
    TResult Function(PaymentKind_Bolt11Jit value)? bolt11Jit,
    TResult Function(PaymentKind_Spontaneous value)? spontaneous,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentKindCopyWith<$Res> {
  factory $PaymentKindCopyWith(
          PaymentKind value, $Res Function(PaymentKind) then) =
      _$PaymentKindCopyWithImpl<$Res, PaymentKind>;
}

/// @nodoc
class _$PaymentKindCopyWithImpl<$Res, $Val extends PaymentKind>
    implements $PaymentKindCopyWith<$Res> {
  _$PaymentKindCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PaymentKind_OnchainImplCopyWith<$Res> {
  factory _$$PaymentKind_OnchainImplCopyWith(_$PaymentKind_OnchainImpl value,
          $Res Function(_$PaymentKind_OnchainImpl) then) =
      __$$PaymentKind_OnchainImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentKind_OnchainImplCopyWithImpl<$Res>
    extends _$PaymentKindCopyWithImpl<$Res, _$PaymentKind_OnchainImpl>
    implements _$$PaymentKind_OnchainImplCopyWith<$Res> {
  __$$PaymentKind_OnchainImplCopyWithImpl(_$PaymentKind_OnchainImpl _value,
      $Res Function(_$PaymentKind_OnchainImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentKind_OnchainImpl extends PaymentKind_Onchain {
  const _$PaymentKind_OnchainImpl() : super._();

  @override
  String toString() {
    return 'PaymentKind.onchain()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentKind_OnchainImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() onchain,
    required TResult Function(
            PaymentHash hash, PaymentPreimage? preimage, PaymentSecret? secret)
        bolt11,
    required TResult Function(PaymentHash hash, PaymentPreimage? preimage,
            PaymentSecret? secret, LSPFeeLimits lspFeeLimits)
        bolt11Jit,
    required TResult Function(PaymentHash hash, PaymentPreimage? preimage)
        spontaneous,
  }) {
    return onchain();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? onchain,
    TResult? Function(
            PaymentHash hash, PaymentPreimage? preimage, PaymentSecret? secret)?
        bolt11,
    TResult? Function(PaymentHash hash, PaymentPreimage? preimage,
            PaymentSecret? secret, LSPFeeLimits lspFeeLimits)?
        bolt11Jit,
    TResult? Function(PaymentHash hash, PaymentPreimage? preimage)? spontaneous,
  }) {
    return onchain?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? onchain,
    TResult Function(
            PaymentHash hash, PaymentPreimage? preimage, PaymentSecret? secret)?
        bolt11,
    TResult Function(PaymentHash hash, PaymentPreimage? preimage,
            PaymentSecret? secret, LSPFeeLimits lspFeeLimits)?
        bolt11Jit,
    TResult Function(PaymentHash hash, PaymentPreimage? preimage)? spontaneous,
    required TResult orElse(),
  }) {
    if (onchain != null) {
      return onchain();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentKind_Onchain value) onchain,
    required TResult Function(PaymentKind_Bolt11 value) bolt11,
    required TResult Function(PaymentKind_Bolt11Jit value) bolt11Jit,
    required TResult Function(PaymentKind_Spontaneous value) spontaneous,
  }) {
    return onchain(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentKind_Onchain value)? onchain,
    TResult? Function(PaymentKind_Bolt11 value)? bolt11,
    TResult? Function(PaymentKind_Bolt11Jit value)? bolt11Jit,
    TResult? Function(PaymentKind_Spontaneous value)? spontaneous,
  }) {
    return onchain?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentKind_Onchain value)? onchain,
    TResult Function(PaymentKind_Bolt11 value)? bolt11,
    TResult Function(PaymentKind_Bolt11Jit value)? bolt11Jit,
    TResult Function(PaymentKind_Spontaneous value)? spontaneous,
    required TResult orElse(),
  }) {
    if (onchain != null) {
      return onchain(this);
    }
    return orElse();
  }
}

abstract class PaymentKind_Onchain extends PaymentKind {
  const factory PaymentKind_Onchain() = _$PaymentKind_OnchainImpl;
  const PaymentKind_Onchain._() : super._();
}

/// @nodoc
abstract class _$$PaymentKind_Bolt11ImplCopyWith<$Res> {
  factory _$$PaymentKind_Bolt11ImplCopyWith(_$PaymentKind_Bolt11Impl value,
          $Res Function(_$PaymentKind_Bolt11Impl) then) =
      __$$PaymentKind_Bolt11ImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {PaymentHash hash, PaymentPreimage? preimage, PaymentSecret? secret});
}

/// @nodoc
class __$$PaymentKind_Bolt11ImplCopyWithImpl<$Res>
    extends _$PaymentKindCopyWithImpl<$Res, _$PaymentKind_Bolt11Impl>
    implements _$$PaymentKind_Bolt11ImplCopyWith<$Res> {
  __$$PaymentKind_Bolt11ImplCopyWithImpl(_$PaymentKind_Bolt11Impl _value,
      $Res Function(_$PaymentKind_Bolt11Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hash = null,
    Object? preimage = freezed,
    Object? secret = freezed,
  }) {
    return _then(_$PaymentKind_Bolt11Impl(
      hash: null == hash
          ? _value.hash
          : hash // ignore: cast_nullable_to_non_nullable
              as PaymentHash,
      preimage: freezed == preimage
          ? _value.preimage
          : preimage // ignore: cast_nullable_to_non_nullable
              as PaymentPreimage?,
      secret: freezed == secret
          ? _value.secret
          : secret // ignore: cast_nullable_to_non_nullable
              as PaymentSecret?,
    ));
  }
}

/// @nodoc

class _$PaymentKind_Bolt11Impl extends PaymentKind_Bolt11 {
  const _$PaymentKind_Bolt11Impl(
      {required this.hash, this.preimage, this.secret})
      : super._();

  /// The payment hash, i.e., the hash of the `preimage`.
  @override
  final PaymentHash hash;

  /// The pre-image used by the payment.
  @override
  final PaymentPreimage? preimage;

  /// The secret used by the payment.
  @override
  final PaymentSecret? secret;

  @override
  String toString() {
    return 'PaymentKind.bolt11(hash: $hash, preimage: $preimage, secret: $secret)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentKind_Bolt11Impl &&
            (identical(other.hash, hash) || other.hash == hash) &&
            (identical(other.preimage, preimage) ||
                other.preimage == preimage) &&
            (identical(other.secret, secret) || other.secret == secret));
  }

  @override
  int get hashCode => Object.hash(runtimeType, hash, preimage, secret);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentKind_Bolt11ImplCopyWith<_$PaymentKind_Bolt11Impl> get copyWith =>
      __$$PaymentKind_Bolt11ImplCopyWithImpl<_$PaymentKind_Bolt11Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() onchain,
    required TResult Function(
            PaymentHash hash, PaymentPreimage? preimage, PaymentSecret? secret)
        bolt11,
    required TResult Function(PaymentHash hash, PaymentPreimage? preimage,
            PaymentSecret? secret, LSPFeeLimits lspFeeLimits)
        bolt11Jit,
    required TResult Function(PaymentHash hash, PaymentPreimage? preimage)
        spontaneous,
  }) {
    return bolt11(hash, preimage, secret);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? onchain,
    TResult? Function(
            PaymentHash hash, PaymentPreimage? preimage, PaymentSecret? secret)?
        bolt11,
    TResult? Function(PaymentHash hash, PaymentPreimage? preimage,
            PaymentSecret? secret, LSPFeeLimits lspFeeLimits)?
        bolt11Jit,
    TResult? Function(PaymentHash hash, PaymentPreimage? preimage)? spontaneous,
  }) {
    return bolt11?.call(hash, preimage, secret);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? onchain,
    TResult Function(
            PaymentHash hash, PaymentPreimage? preimage, PaymentSecret? secret)?
        bolt11,
    TResult Function(PaymentHash hash, PaymentPreimage? preimage,
            PaymentSecret? secret, LSPFeeLimits lspFeeLimits)?
        bolt11Jit,
    TResult Function(PaymentHash hash, PaymentPreimage? preimage)? spontaneous,
    required TResult orElse(),
  }) {
    if (bolt11 != null) {
      return bolt11(hash, preimage, secret);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentKind_Onchain value) onchain,
    required TResult Function(PaymentKind_Bolt11 value) bolt11,
    required TResult Function(PaymentKind_Bolt11Jit value) bolt11Jit,
    required TResult Function(PaymentKind_Spontaneous value) spontaneous,
  }) {
    return bolt11(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentKind_Onchain value)? onchain,
    TResult? Function(PaymentKind_Bolt11 value)? bolt11,
    TResult? Function(PaymentKind_Bolt11Jit value)? bolt11Jit,
    TResult? Function(PaymentKind_Spontaneous value)? spontaneous,
  }) {
    return bolt11?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentKind_Onchain value)? onchain,
    TResult Function(PaymentKind_Bolt11 value)? bolt11,
    TResult Function(PaymentKind_Bolt11Jit value)? bolt11Jit,
    TResult Function(PaymentKind_Spontaneous value)? spontaneous,
    required TResult orElse(),
  }) {
    if (bolt11 != null) {
      return bolt11(this);
    }
    return orElse();
  }
}

abstract class PaymentKind_Bolt11 extends PaymentKind {
  const factory PaymentKind_Bolt11(
      {required final PaymentHash hash,
      final PaymentPreimage? preimage,
      final PaymentSecret? secret}) = _$PaymentKind_Bolt11Impl;
  const PaymentKind_Bolt11._() : super._();

  /// The payment hash, i.e., the hash of the `preimage`.
  PaymentHash get hash;

  /// The pre-image used by the payment.
  PaymentPreimage? get preimage;

  /// The secret used by the payment.
  PaymentSecret? get secret;
  @JsonKey(ignore: true)
  _$$PaymentKind_Bolt11ImplCopyWith<_$PaymentKind_Bolt11Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PaymentKind_Bolt11JitImplCopyWith<$Res> {
  factory _$$PaymentKind_Bolt11JitImplCopyWith(
          _$PaymentKind_Bolt11JitImpl value,
          $Res Function(_$PaymentKind_Bolt11JitImpl) then) =
      __$$PaymentKind_Bolt11JitImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {PaymentHash hash,
      PaymentPreimage? preimage,
      PaymentSecret? secret,
      LSPFeeLimits lspFeeLimits});
}

/// @nodoc
class __$$PaymentKind_Bolt11JitImplCopyWithImpl<$Res>
    extends _$PaymentKindCopyWithImpl<$Res, _$PaymentKind_Bolt11JitImpl>
    implements _$$PaymentKind_Bolt11JitImplCopyWith<$Res> {
  __$$PaymentKind_Bolt11JitImplCopyWithImpl(_$PaymentKind_Bolt11JitImpl _value,
      $Res Function(_$PaymentKind_Bolt11JitImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hash = null,
    Object? preimage = freezed,
    Object? secret = freezed,
    Object? lspFeeLimits = null,
  }) {
    return _then(_$PaymentKind_Bolt11JitImpl(
      hash: null == hash
          ? _value.hash
          : hash // ignore: cast_nullable_to_non_nullable
              as PaymentHash,
      preimage: freezed == preimage
          ? _value.preimage
          : preimage // ignore: cast_nullable_to_non_nullable
              as PaymentPreimage?,
      secret: freezed == secret
          ? _value.secret
          : secret // ignore: cast_nullable_to_non_nullable
              as PaymentSecret?,
      lspFeeLimits: null == lspFeeLimits
          ? _value.lspFeeLimits
          : lspFeeLimits // ignore: cast_nullable_to_non_nullable
              as LSPFeeLimits,
    ));
  }
}

/// @nodoc

class _$PaymentKind_Bolt11JitImpl extends PaymentKind_Bolt11Jit {
  const _$PaymentKind_Bolt11JitImpl(
      {required this.hash,
      this.preimage,
      this.secret,
      required this.lspFeeLimits})
      : super._();

  /// The payment hash, i.e., the hash of the `preimage`.
  @override
  final PaymentHash hash;

  /// The pre-image used by the payment.
  @override
  final PaymentPreimage? preimage;

  /// The secret used by the payment.
  @override
  final PaymentSecret? secret;

  /// Limits applying to how much fee we allow an LSP to deduct from the payment amount.
  ///
  /// Allowing them to deduct this fee from the first inbound payment will pay for the LSP's
  /// channel opening fees.
  ///
  @override
  final LSPFeeLimits lspFeeLimits;

  @override
  String toString() {
    return 'PaymentKind.bolt11Jit(hash: $hash, preimage: $preimage, secret: $secret, lspFeeLimits: $lspFeeLimits)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentKind_Bolt11JitImpl &&
            (identical(other.hash, hash) || other.hash == hash) &&
            (identical(other.preimage, preimage) ||
                other.preimage == preimage) &&
            (identical(other.secret, secret) || other.secret == secret) &&
            (identical(other.lspFeeLimits, lspFeeLimits) ||
                other.lspFeeLimits == lspFeeLimits));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, hash, preimage, secret, lspFeeLimits);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentKind_Bolt11JitImplCopyWith<_$PaymentKind_Bolt11JitImpl>
      get copyWith => __$$PaymentKind_Bolt11JitImplCopyWithImpl<
          _$PaymentKind_Bolt11JitImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() onchain,
    required TResult Function(
            PaymentHash hash, PaymentPreimage? preimage, PaymentSecret? secret)
        bolt11,
    required TResult Function(PaymentHash hash, PaymentPreimage? preimage,
            PaymentSecret? secret, LSPFeeLimits lspFeeLimits)
        bolt11Jit,
    required TResult Function(PaymentHash hash, PaymentPreimage? preimage)
        spontaneous,
  }) {
    return bolt11Jit(hash, preimage, secret, lspFeeLimits);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? onchain,
    TResult? Function(
            PaymentHash hash, PaymentPreimage? preimage, PaymentSecret? secret)?
        bolt11,
    TResult? Function(PaymentHash hash, PaymentPreimage? preimage,
            PaymentSecret? secret, LSPFeeLimits lspFeeLimits)?
        bolt11Jit,
    TResult? Function(PaymentHash hash, PaymentPreimage? preimage)? spontaneous,
  }) {
    return bolt11Jit?.call(hash, preimage, secret, lspFeeLimits);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? onchain,
    TResult Function(
            PaymentHash hash, PaymentPreimage? preimage, PaymentSecret? secret)?
        bolt11,
    TResult Function(PaymentHash hash, PaymentPreimage? preimage,
            PaymentSecret? secret, LSPFeeLimits lspFeeLimits)?
        bolt11Jit,
    TResult Function(PaymentHash hash, PaymentPreimage? preimage)? spontaneous,
    required TResult orElse(),
  }) {
    if (bolt11Jit != null) {
      return bolt11Jit(hash, preimage, secret, lspFeeLimits);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentKind_Onchain value) onchain,
    required TResult Function(PaymentKind_Bolt11 value) bolt11,
    required TResult Function(PaymentKind_Bolt11Jit value) bolt11Jit,
    required TResult Function(PaymentKind_Spontaneous value) spontaneous,
  }) {
    return bolt11Jit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentKind_Onchain value)? onchain,
    TResult? Function(PaymentKind_Bolt11 value)? bolt11,
    TResult? Function(PaymentKind_Bolt11Jit value)? bolt11Jit,
    TResult? Function(PaymentKind_Spontaneous value)? spontaneous,
  }) {
    return bolt11Jit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentKind_Onchain value)? onchain,
    TResult Function(PaymentKind_Bolt11 value)? bolt11,
    TResult Function(PaymentKind_Bolt11Jit value)? bolt11Jit,
    TResult Function(PaymentKind_Spontaneous value)? spontaneous,
    required TResult orElse(),
  }) {
    if (bolt11Jit != null) {
      return bolt11Jit(this);
    }
    return orElse();
  }
}

abstract class PaymentKind_Bolt11Jit extends PaymentKind {
  const factory PaymentKind_Bolt11Jit(
      {required final PaymentHash hash,
      final PaymentPreimage? preimage,
      final PaymentSecret? secret,
      required final LSPFeeLimits lspFeeLimits}) = _$PaymentKind_Bolt11JitImpl;
  const PaymentKind_Bolt11Jit._() : super._();

  /// The payment hash, i.e., the hash of the `preimage`.
  PaymentHash get hash;

  /// The pre-image used by the payment.
  PaymentPreimage? get preimage;

  /// The secret used by the payment.
  PaymentSecret? get secret;

  /// Limits applying to how much fee we allow an LSP to deduct from the payment amount.
  ///
  /// Allowing them to deduct this fee from the first inbound payment will pay for the LSP's
  /// channel opening fees.
  ///
  LSPFeeLimits get lspFeeLimits;
  @JsonKey(ignore: true)
  _$$PaymentKind_Bolt11JitImplCopyWith<_$PaymentKind_Bolt11JitImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PaymentKind_SpontaneousImplCopyWith<$Res> {
  factory _$$PaymentKind_SpontaneousImplCopyWith(
          _$PaymentKind_SpontaneousImpl value,
          $Res Function(_$PaymentKind_SpontaneousImpl) then) =
      __$$PaymentKind_SpontaneousImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PaymentHash hash, PaymentPreimage? preimage});
}

/// @nodoc
class __$$PaymentKind_SpontaneousImplCopyWithImpl<$Res>
    extends _$PaymentKindCopyWithImpl<$Res, _$PaymentKind_SpontaneousImpl>
    implements _$$PaymentKind_SpontaneousImplCopyWith<$Res> {
  __$$PaymentKind_SpontaneousImplCopyWithImpl(
      _$PaymentKind_SpontaneousImpl _value,
      $Res Function(_$PaymentKind_SpontaneousImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hash = null,
    Object? preimage = freezed,
  }) {
    return _then(_$PaymentKind_SpontaneousImpl(
      hash: null == hash
          ? _value.hash
          : hash // ignore: cast_nullable_to_non_nullable
              as PaymentHash,
      preimage: freezed == preimage
          ? _value.preimage
          : preimage // ignore: cast_nullable_to_non_nullable
              as PaymentPreimage?,
    ));
  }
}

/// @nodoc

class _$PaymentKind_SpontaneousImpl extends PaymentKind_Spontaneous {
  const _$PaymentKind_SpontaneousImpl({required this.hash, this.preimage})
      : super._();

  /// The payment hash, i.e., the hash of the `preimage`.
  @override
  final PaymentHash hash;

  /// The pre-image used by the payment.
  @override
  final PaymentPreimage? preimage;

  @override
  String toString() {
    return 'PaymentKind.spontaneous(hash: $hash, preimage: $preimage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentKind_SpontaneousImpl &&
            (identical(other.hash, hash) || other.hash == hash) &&
            (identical(other.preimage, preimage) ||
                other.preimage == preimage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, hash, preimage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentKind_SpontaneousImplCopyWith<_$PaymentKind_SpontaneousImpl>
      get copyWith => __$$PaymentKind_SpontaneousImplCopyWithImpl<
          _$PaymentKind_SpontaneousImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() onchain,
    required TResult Function(
            PaymentHash hash, PaymentPreimage? preimage, PaymentSecret? secret)
        bolt11,
    required TResult Function(PaymentHash hash, PaymentPreimage? preimage,
            PaymentSecret? secret, LSPFeeLimits lspFeeLimits)
        bolt11Jit,
    required TResult Function(PaymentHash hash, PaymentPreimage? preimage)
        spontaneous,
  }) {
    return spontaneous(hash, preimage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? onchain,
    TResult? Function(
            PaymentHash hash, PaymentPreimage? preimage, PaymentSecret? secret)?
        bolt11,
    TResult? Function(PaymentHash hash, PaymentPreimage? preimage,
            PaymentSecret? secret, LSPFeeLimits lspFeeLimits)?
        bolt11Jit,
    TResult? Function(PaymentHash hash, PaymentPreimage? preimage)? spontaneous,
  }) {
    return spontaneous?.call(hash, preimage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? onchain,
    TResult Function(
            PaymentHash hash, PaymentPreimage? preimage, PaymentSecret? secret)?
        bolt11,
    TResult Function(PaymentHash hash, PaymentPreimage? preimage,
            PaymentSecret? secret, LSPFeeLimits lspFeeLimits)?
        bolt11Jit,
    TResult Function(PaymentHash hash, PaymentPreimage? preimage)? spontaneous,
    required TResult orElse(),
  }) {
    if (spontaneous != null) {
      return spontaneous(hash, preimage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentKind_Onchain value) onchain,
    required TResult Function(PaymentKind_Bolt11 value) bolt11,
    required TResult Function(PaymentKind_Bolt11Jit value) bolt11Jit,
    required TResult Function(PaymentKind_Spontaneous value) spontaneous,
  }) {
    return spontaneous(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentKind_Onchain value)? onchain,
    TResult? Function(PaymentKind_Bolt11 value)? bolt11,
    TResult? Function(PaymentKind_Bolt11Jit value)? bolt11Jit,
    TResult? Function(PaymentKind_Spontaneous value)? spontaneous,
  }) {
    return spontaneous?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentKind_Onchain value)? onchain,
    TResult Function(PaymentKind_Bolt11 value)? bolt11,
    TResult Function(PaymentKind_Bolt11Jit value)? bolt11Jit,
    TResult Function(PaymentKind_Spontaneous value)? spontaneous,
    required TResult orElse(),
  }) {
    if (spontaneous != null) {
      return spontaneous(this);
    }
    return orElse();
  }
}

abstract class PaymentKind_Spontaneous extends PaymentKind {
  const factory PaymentKind_Spontaneous(
      {required final PaymentHash hash,
      final PaymentPreimage? preimage}) = _$PaymentKind_SpontaneousImpl;
  const PaymentKind_Spontaneous._() : super._();

  /// The payment hash, i.e., the hash of the `preimage`.
  PaymentHash get hash;

  /// The pre-image used by the payment.
  PaymentPreimage? get preimage;
  @JsonKey(ignore: true)
  _$$PaymentKind_SpontaneousImplCopyWith<_$PaymentKind_SpontaneousImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PendingSweepBalance {
  /// The identifier of the channel this balance belongs to.
  ChannelId? get channelId => throw _privateConstructorUsedError;

  /// The amount, in satoshis, of the output being swept.
  int get amountSatoshis => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId? channelId, int amountSatoshis)
        pendingBroadcast,
    required TResult Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)
        broadcastAwaitingConfirmation,
    required TResult Function(ChannelId? channelId, Txid latestSpendingTxid,
            String confirmationHash, int confirmationHeight, int amountSatoshis)
        awaitingThresholdConfirmations,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId? channelId, int amountSatoshis)?
        pendingBroadcast,
    TResult? Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)?
        broadcastAwaitingConfirmation,
    TResult? Function(
            ChannelId? channelId,
            Txid latestSpendingTxid,
            String confirmationHash,
            int confirmationHeight,
            int amountSatoshis)?
        awaitingThresholdConfirmations,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId? channelId, int amountSatoshis)?
        pendingBroadcast,
    TResult Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)?
        broadcastAwaitingConfirmation,
    TResult Function(
            ChannelId? channelId,
            Txid latestSpendingTxid,
            String confirmationHash,
            int confirmationHeight,
            int amountSatoshis)?
        awaitingThresholdConfirmations,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PendingSweepBalance_PendingBroadcast value)
        pendingBroadcast,
    required TResult Function(
            PendingSweepBalance_BroadcastAwaitingConfirmation value)
        broadcastAwaitingConfirmation,
    required TResult Function(
            PendingSweepBalance_AwaitingThresholdConfirmations value)
        awaitingThresholdConfirmations,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PendingSweepBalance_PendingBroadcast value)?
        pendingBroadcast,
    TResult? Function(PendingSweepBalance_BroadcastAwaitingConfirmation value)?
        broadcastAwaitingConfirmation,
    TResult? Function(PendingSweepBalance_AwaitingThresholdConfirmations value)?
        awaitingThresholdConfirmations,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PendingSweepBalance_PendingBroadcast value)?
        pendingBroadcast,
    TResult Function(PendingSweepBalance_BroadcastAwaitingConfirmation value)?
        broadcastAwaitingConfirmation,
    TResult Function(PendingSweepBalance_AwaitingThresholdConfirmations value)?
        awaitingThresholdConfirmations,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PendingSweepBalanceCopyWith<PendingSweepBalance> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PendingSweepBalanceCopyWith<$Res> {
  factory $PendingSweepBalanceCopyWith(
          PendingSweepBalance value, $Res Function(PendingSweepBalance) then) =
      _$PendingSweepBalanceCopyWithImpl<$Res, PendingSweepBalance>;
  @useResult
  $Res call({ChannelId? channelId, int amountSatoshis});
}

/// @nodoc
class _$PendingSweepBalanceCopyWithImpl<$Res, $Val extends PendingSweepBalance>
    implements $PendingSweepBalanceCopyWith<$Res> {
  _$PendingSweepBalanceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = freezed,
    Object? amountSatoshis = null,
  }) {
    return _then(_value.copyWith(
      channelId: freezed == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId?,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PendingSweepBalance_PendingBroadcastImplCopyWith<$Res>
    implements $PendingSweepBalanceCopyWith<$Res> {
  factory _$$PendingSweepBalance_PendingBroadcastImplCopyWith(
          _$PendingSweepBalance_PendingBroadcastImpl value,
          $Res Function(_$PendingSweepBalance_PendingBroadcastImpl) then) =
      __$$PendingSweepBalance_PendingBroadcastImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ChannelId? channelId, int amountSatoshis});
}

/// @nodoc
class __$$PendingSweepBalance_PendingBroadcastImplCopyWithImpl<$Res>
    extends _$PendingSweepBalanceCopyWithImpl<$Res,
        _$PendingSweepBalance_PendingBroadcastImpl>
    implements _$$PendingSweepBalance_PendingBroadcastImplCopyWith<$Res> {
  __$$PendingSweepBalance_PendingBroadcastImplCopyWithImpl(
      _$PendingSweepBalance_PendingBroadcastImpl _value,
      $Res Function(_$PendingSweepBalance_PendingBroadcastImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = freezed,
    Object? amountSatoshis = null,
  }) {
    return _then(_$PendingSweepBalance_PendingBroadcastImpl(
      channelId: freezed == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId?,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$PendingSweepBalance_PendingBroadcastImpl
    extends PendingSweepBalance_PendingBroadcast {
  const _$PendingSweepBalance_PendingBroadcastImpl(
      {this.channelId, required this.amountSatoshis})
      : super._();

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId? channelId;

  /// The amount, in satoshis, of the output being swept.
  @override
  final int amountSatoshis;

  @override
  String toString() {
    return 'PendingSweepBalance.pendingBroadcast(channelId: $channelId, amountSatoshis: $amountSatoshis)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PendingSweepBalance_PendingBroadcastImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis));
  }

  @override
  int get hashCode => Object.hash(runtimeType, channelId, amountSatoshis);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PendingSweepBalance_PendingBroadcastImplCopyWith<
          _$PendingSweepBalance_PendingBroadcastImpl>
      get copyWith => __$$PendingSweepBalance_PendingBroadcastImplCopyWithImpl<
          _$PendingSweepBalance_PendingBroadcastImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId? channelId, int amountSatoshis)
        pendingBroadcast,
    required TResult Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)
        broadcastAwaitingConfirmation,
    required TResult Function(ChannelId? channelId, Txid latestSpendingTxid,
            String confirmationHash, int confirmationHeight, int amountSatoshis)
        awaitingThresholdConfirmations,
  }) {
    return pendingBroadcast(channelId, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId? channelId, int amountSatoshis)?
        pendingBroadcast,
    TResult? Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)?
        broadcastAwaitingConfirmation,
    TResult? Function(
            ChannelId? channelId,
            Txid latestSpendingTxid,
            String confirmationHash,
            int confirmationHeight,
            int amountSatoshis)?
        awaitingThresholdConfirmations,
  }) {
    return pendingBroadcast?.call(channelId, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId? channelId, int amountSatoshis)?
        pendingBroadcast,
    TResult Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)?
        broadcastAwaitingConfirmation,
    TResult Function(
            ChannelId? channelId,
            Txid latestSpendingTxid,
            String confirmationHash,
            int confirmationHeight,
            int amountSatoshis)?
        awaitingThresholdConfirmations,
    required TResult orElse(),
  }) {
    if (pendingBroadcast != null) {
      return pendingBroadcast(channelId, amountSatoshis);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PendingSweepBalance_PendingBroadcast value)
        pendingBroadcast,
    required TResult Function(
            PendingSweepBalance_BroadcastAwaitingConfirmation value)
        broadcastAwaitingConfirmation,
    required TResult Function(
            PendingSweepBalance_AwaitingThresholdConfirmations value)
        awaitingThresholdConfirmations,
  }) {
    return pendingBroadcast(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PendingSweepBalance_PendingBroadcast value)?
        pendingBroadcast,
    TResult? Function(PendingSweepBalance_BroadcastAwaitingConfirmation value)?
        broadcastAwaitingConfirmation,
    TResult? Function(PendingSweepBalance_AwaitingThresholdConfirmations value)?
        awaitingThresholdConfirmations,
  }) {
    return pendingBroadcast?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PendingSweepBalance_PendingBroadcast value)?
        pendingBroadcast,
    TResult Function(PendingSweepBalance_BroadcastAwaitingConfirmation value)?
        broadcastAwaitingConfirmation,
    TResult Function(PendingSweepBalance_AwaitingThresholdConfirmations value)?
        awaitingThresholdConfirmations,
    required TResult orElse(),
  }) {
    if (pendingBroadcast != null) {
      return pendingBroadcast(this);
    }
    return orElse();
  }
}

abstract class PendingSweepBalance_PendingBroadcast
    extends PendingSweepBalance {
  const factory PendingSweepBalance_PendingBroadcast(
          {final ChannelId? channelId, required final int amountSatoshis}) =
      _$PendingSweepBalance_PendingBroadcastImpl;
  const PendingSweepBalance_PendingBroadcast._() : super._();

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId? get channelId;
  @override

  /// The amount, in satoshis, of the output being swept.
  int get amountSatoshis;
  @override
  @JsonKey(ignore: true)
  _$$PendingSweepBalance_PendingBroadcastImplCopyWith<
          _$PendingSweepBalance_PendingBroadcastImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWith<
    $Res> implements $PendingSweepBalanceCopyWith<$Res> {
  factory _$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWith(
          _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl value,
          $Res Function(_$PendingSweepBalance_BroadcastAwaitingConfirmationImpl)
              then) =
      __$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call(
      {ChannelId? channelId,
      int latestBroadcastHeight,
      Txid latestSpendingTxid,
      int amountSatoshis});
}

/// @nodoc
class __$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWithImpl<
        $Res>
    extends _$PendingSweepBalanceCopyWithImpl<$Res,
        _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl>
    implements
        _$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWith<$Res> {
  __$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWithImpl(
      _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl _value,
      $Res Function(_$PendingSweepBalance_BroadcastAwaitingConfirmationImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = freezed,
    Object? latestBroadcastHeight = null,
    Object? latestSpendingTxid = null,
    Object? amountSatoshis = null,
  }) {
    return _then(_$PendingSweepBalance_BroadcastAwaitingConfirmationImpl(
      channelId: freezed == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId?,
      latestBroadcastHeight: null == latestBroadcastHeight
          ? _value.latestBroadcastHeight
          : latestBroadcastHeight // ignore: cast_nullable_to_non_nullable
              as int,
      latestSpendingTxid: null == latestSpendingTxid
          ? _value.latestSpendingTxid
          : latestSpendingTxid // ignore: cast_nullable_to_non_nullable
              as Txid,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl
    extends PendingSweepBalance_BroadcastAwaitingConfirmation {
  const _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl(
      {this.channelId,
      required this.latestBroadcastHeight,
      required this.latestSpendingTxid,
      required this.amountSatoshis})
      : super._();

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId? channelId;

  /// The best height when we last broadcast a transaction spending the output being swept.
  @override
  final int latestBroadcastHeight;

  /// The identifier of the transaction spending the swept output we last broadcast.
  @override
  final Txid latestSpendingTxid;

  /// The amount, in satoshis, of the output being swept.
  @override
  final int amountSatoshis;

  @override
  String toString() {
    return 'PendingSweepBalance.broadcastAwaitingConfirmation(channelId: $channelId, latestBroadcastHeight: $latestBroadcastHeight, latestSpendingTxid: $latestSpendingTxid, amountSatoshis: $amountSatoshis)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.latestBroadcastHeight, latestBroadcastHeight) ||
                other.latestBroadcastHeight == latestBroadcastHeight) &&
            (identical(other.latestSpendingTxid, latestSpendingTxid) ||
                other.latestSpendingTxid == latestSpendingTxid) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis));
  }

  @override
  int get hashCode => Object.hash(runtimeType, channelId, latestBroadcastHeight,
      latestSpendingTxid, amountSatoshis);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWith<
          _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl>
      get copyWith =>
          __$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWithImpl<
                  _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId? channelId, int amountSatoshis)
        pendingBroadcast,
    required TResult Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)
        broadcastAwaitingConfirmation,
    required TResult Function(ChannelId? channelId, Txid latestSpendingTxid,
            String confirmationHash, int confirmationHeight, int amountSatoshis)
        awaitingThresholdConfirmations,
  }) {
    return broadcastAwaitingConfirmation(
        channelId, latestBroadcastHeight, latestSpendingTxid, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId? channelId, int amountSatoshis)?
        pendingBroadcast,
    TResult? Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)?
        broadcastAwaitingConfirmation,
    TResult? Function(
            ChannelId? channelId,
            Txid latestSpendingTxid,
            String confirmationHash,
            int confirmationHeight,
            int amountSatoshis)?
        awaitingThresholdConfirmations,
  }) {
    return broadcastAwaitingConfirmation?.call(
        channelId, latestBroadcastHeight, latestSpendingTxid, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId? channelId, int amountSatoshis)?
        pendingBroadcast,
    TResult Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)?
        broadcastAwaitingConfirmation,
    TResult Function(
            ChannelId? channelId,
            Txid latestSpendingTxid,
            String confirmationHash,
            int confirmationHeight,
            int amountSatoshis)?
        awaitingThresholdConfirmations,
    required TResult orElse(),
  }) {
    if (broadcastAwaitingConfirmation != null) {
      return broadcastAwaitingConfirmation(
          channelId, latestBroadcastHeight, latestSpendingTxid, amountSatoshis);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PendingSweepBalance_PendingBroadcast value)
        pendingBroadcast,
    required TResult Function(
            PendingSweepBalance_BroadcastAwaitingConfirmation value)
        broadcastAwaitingConfirmation,
    required TResult Function(
            PendingSweepBalance_AwaitingThresholdConfirmations value)
        awaitingThresholdConfirmations,
  }) {
    return broadcastAwaitingConfirmation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PendingSweepBalance_PendingBroadcast value)?
        pendingBroadcast,
    TResult? Function(PendingSweepBalance_BroadcastAwaitingConfirmation value)?
        broadcastAwaitingConfirmation,
    TResult? Function(PendingSweepBalance_AwaitingThresholdConfirmations value)?
        awaitingThresholdConfirmations,
  }) {
    return broadcastAwaitingConfirmation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PendingSweepBalance_PendingBroadcast value)?
        pendingBroadcast,
    TResult Function(PendingSweepBalance_BroadcastAwaitingConfirmation value)?
        broadcastAwaitingConfirmation,
    TResult Function(PendingSweepBalance_AwaitingThresholdConfirmations value)?
        awaitingThresholdConfirmations,
    required TResult orElse(),
  }) {
    if (broadcastAwaitingConfirmation != null) {
      return broadcastAwaitingConfirmation(this);
    }
    return orElse();
  }
}

abstract class PendingSweepBalance_BroadcastAwaitingConfirmation
    extends PendingSweepBalance {
  const factory PendingSweepBalance_BroadcastAwaitingConfirmation(
          {final ChannelId? channelId,
          required final int latestBroadcastHeight,
          required final Txid latestSpendingTxid,
          required final int amountSatoshis}) =
      _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl;
  const PendingSweepBalance_BroadcastAwaitingConfirmation._() : super._();

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId? get channelId;

  /// The best height when we last broadcast a transaction spending the output being swept.
  int get latestBroadcastHeight;

  /// The identifier of the transaction spending the swept output we last broadcast.
  Txid get latestSpendingTxid;
  @override

  /// The amount, in satoshis, of the output being swept.
  int get amountSatoshis;
  @override
  @JsonKey(ignore: true)
  _$$PendingSweepBalance_BroadcastAwaitingConfirmationImplCopyWith<
          _$PendingSweepBalance_BroadcastAwaitingConfirmationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWith<
    $Res> implements $PendingSweepBalanceCopyWith<$Res> {
  factory _$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWith(
          _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl value,
          $Res Function(
                  _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl)
              then) =
      __$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call(
      {ChannelId? channelId,
      Txid latestSpendingTxid,
      String confirmationHash,
      int confirmationHeight,
      int amountSatoshis});
}

/// @nodoc
class __$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWithImpl<
        $Res>
    extends _$PendingSweepBalanceCopyWithImpl<$Res,
        _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl>
    implements
        _$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWith<
            $Res> {
  __$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWithImpl(
      _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl _value,
      $Res Function(_$PendingSweepBalance_AwaitingThresholdConfirmationsImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channelId = freezed,
    Object? latestSpendingTxid = null,
    Object? confirmationHash = null,
    Object? confirmationHeight = null,
    Object? amountSatoshis = null,
  }) {
    return _then(_$PendingSweepBalance_AwaitingThresholdConfirmationsImpl(
      channelId: freezed == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as ChannelId?,
      latestSpendingTxid: null == latestSpendingTxid
          ? _value.latestSpendingTxid
          : latestSpendingTxid // ignore: cast_nullable_to_non_nullable
              as Txid,
      confirmationHash: null == confirmationHash
          ? _value.confirmationHash
          : confirmationHash // ignore: cast_nullable_to_non_nullable
              as String,
      confirmationHeight: null == confirmationHeight
          ? _value.confirmationHeight
          : confirmationHeight // ignore: cast_nullable_to_non_nullable
              as int,
      amountSatoshis: null == amountSatoshis
          ? _value.amountSatoshis
          : amountSatoshis // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl
    extends PendingSweepBalance_AwaitingThresholdConfirmations {
  const _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl(
      {this.channelId,
      required this.latestSpendingTxid,
      required this.confirmationHash,
      required this.confirmationHeight,
      required this.amountSatoshis})
      : super._();

  /// The identifier of the channel this balance belongs to.
  @override
  final ChannelId? channelId;

  /// The identifier of the confirmed transaction spending the swept output.
  @override
  final Txid latestSpendingTxid;

  /// The hash of the block in which the spending transaction was confirmed.
  @override
  final String confirmationHash;

  /// The height at which the spending transaction was confirmed.
  @override
  final int confirmationHeight;

  /// The amount, in satoshis, of the output being swept.
  @override
  final int amountSatoshis;

  @override
  String toString() {
    return 'PendingSweepBalance.awaitingThresholdConfirmations(channelId: $channelId, latestSpendingTxid: $latestSpendingTxid, confirmationHash: $confirmationHash, confirmationHeight: $confirmationHeight, amountSatoshis: $amountSatoshis)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.latestSpendingTxid, latestSpendingTxid) ||
                other.latestSpendingTxid == latestSpendingTxid) &&
            (identical(other.confirmationHash, confirmationHash) ||
                other.confirmationHash == confirmationHash) &&
            (identical(other.confirmationHeight, confirmationHeight) ||
                other.confirmationHeight == confirmationHeight) &&
            (identical(other.amountSatoshis, amountSatoshis) ||
                other.amountSatoshis == amountSatoshis));
  }

  @override
  int get hashCode => Object.hash(runtimeType, channelId, latestSpendingTxid,
      confirmationHash, confirmationHeight, amountSatoshis);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWith<
          _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl>
      get copyWith =>
          __$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWithImpl<
                  _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ChannelId? channelId, int amountSatoshis)
        pendingBroadcast,
    required TResult Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)
        broadcastAwaitingConfirmation,
    required TResult Function(ChannelId? channelId, Txid latestSpendingTxid,
            String confirmationHash, int confirmationHeight, int amountSatoshis)
        awaitingThresholdConfirmations,
  }) {
    return awaitingThresholdConfirmations(channelId, latestSpendingTxid,
        confirmationHash, confirmationHeight, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ChannelId? channelId, int amountSatoshis)?
        pendingBroadcast,
    TResult? Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)?
        broadcastAwaitingConfirmation,
    TResult? Function(
            ChannelId? channelId,
            Txid latestSpendingTxid,
            String confirmationHash,
            int confirmationHeight,
            int amountSatoshis)?
        awaitingThresholdConfirmations,
  }) {
    return awaitingThresholdConfirmations?.call(channelId, latestSpendingTxid,
        confirmationHash, confirmationHeight, amountSatoshis);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ChannelId? channelId, int amountSatoshis)?
        pendingBroadcast,
    TResult Function(ChannelId? channelId, int latestBroadcastHeight,
            Txid latestSpendingTxid, int amountSatoshis)?
        broadcastAwaitingConfirmation,
    TResult Function(
            ChannelId? channelId,
            Txid latestSpendingTxid,
            String confirmationHash,
            int confirmationHeight,
            int amountSatoshis)?
        awaitingThresholdConfirmations,
    required TResult orElse(),
  }) {
    if (awaitingThresholdConfirmations != null) {
      return awaitingThresholdConfirmations(channelId, latestSpendingTxid,
          confirmationHash, confirmationHeight, amountSatoshis);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PendingSweepBalance_PendingBroadcast value)
        pendingBroadcast,
    required TResult Function(
            PendingSweepBalance_BroadcastAwaitingConfirmation value)
        broadcastAwaitingConfirmation,
    required TResult Function(
            PendingSweepBalance_AwaitingThresholdConfirmations value)
        awaitingThresholdConfirmations,
  }) {
    return awaitingThresholdConfirmations(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PendingSweepBalance_PendingBroadcast value)?
        pendingBroadcast,
    TResult? Function(PendingSweepBalance_BroadcastAwaitingConfirmation value)?
        broadcastAwaitingConfirmation,
    TResult? Function(PendingSweepBalance_AwaitingThresholdConfirmations value)?
        awaitingThresholdConfirmations,
  }) {
    return awaitingThresholdConfirmations?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PendingSweepBalance_PendingBroadcast value)?
        pendingBroadcast,
    TResult Function(PendingSweepBalance_BroadcastAwaitingConfirmation value)?
        broadcastAwaitingConfirmation,
    TResult Function(PendingSweepBalance_AwaitingThresholdConfirmations value)?
        awaitingThresholdConfirmations,
    required TResult orElse(),
  }) {
    if (awaitingThresholdConfirmations != null) {
      return awaitingThresholdConfirmations(this);
    }
    return orElse();
  }
}

abstract class PendingSweepBalance_AwaitingThresholdConfirmations
    extends PendingSweepBalance {
  const factory PendingSweepBalance_AwaitingThresholdConfirmations(
          {final ChannelId? channelId,
          required final Txid latestSpendingTxid,
          required final String confirmationHash,
          required final int confirmationHeight,
          required final int amountSatoshis}) =
      _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl;
  const PendingSweepBalance_AwaitingThresholdConfirmations._() : super._();

  @override

  /// The identifier of the channel this balance belongs to.
  ChannelId? get channelId;

  /// The identifier of the confirmed transaction spending the swept output.
  Txid get latestSpendingTxid;

  /// The hash of the block in which the spending transaction was confirmed.
  String get confirmationHash;

  /// The height at which the spending transaction was confirmed.
  int get confirmationHeight;
  @override

  /// The amount, in satoshis, of the output being swept.
  int get amountSatoshis;
  @override
  @JsonKey(ignore: true)
  _$$PendingSweepBalance_AwaitingThresholdConfirmationsImplCopyWith<
          _$PendingSweepBalance_AwaitingThresholdConfirmationsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SocketAddress {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(U8Array4 addr, int port) tcpIpV4,
    required TResult Function(U8Array16 addr, int port) tcpIpV6,
    required TResult Function(U8Array12 field0) onionV2,
    required TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)
        onionV3,
    required TResult Function(String addr, int port) hostname,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(U8Array4 addr, int port)? tcpIpV4,
    TResult? Function(U8Array16 addr, int port)? tcpIpV6,
    TResult? Function(U8Array12 field0)? onionV2,
    TResult? Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult? Function(String addr, int port)? hostname,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(U8Array4 addr, int port)? tcpIpV4,
    TResult Function(U8Array16 addr, int port)? tcpIpV6,
    TResult Function(U8Array12 field0)? onionV2,
    TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult Function(String addr, int port)? hostname,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SocketAddress_TcpIpV4 value) tcpIpV4,
    required TResult Function(SocketAddress_TcpIpV6 value) tcpIpV6,
    required TResult Function(SocketAddress_OnionV2 value) onionV2,
    required TResult Function(SocketAddress_OnionV3 value) onionV3,
    required TResult Function(SocketAddress_Hostname value) hostname,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult? Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult? Function(SocketAddress_OnionV2 value)? onionV2,
    TResult? Function(SocketAddress_OnionV3 value)? onionV3,
    TResult? Function(SocketAddress_Hostname value)? hostname,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult Function(SocketAddress_OnionV2 value)? onionV2,
    TResult Function(SocketAddress_OnionV3 value)? onionV3,
    TResult Function(SocketAddress_Hostname value)? hostname,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SocketAddressCopyWith<$Res> {
  factory $SocketAddressCopyWith(
          SocketAddress value, $Res Function(SocketAddress) then) =
      _$SocketAddressCopyWithImpl<$Res, SocketAddress>;
}

/// @nodoc
class _$SocketAddressCopyWithImpl<$Res, $Val extends SocketAddress>
    implements $SocketAddressCopyWith<$Res> {
  _$SocketAddressCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SocketAddress_TcpIpV4ImplCopyWith<$Res> {
  factory _$$SocketAddress_TcpIpV4ImplCopyWith(
          _$SocketAddress_TcpIpV4Impl value,
          $Res Function(_$SocketAddress_TcpIpV4Impl) then) =
      __$$SocketAddress_TcpIpV4ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({U8Array4 addr, int port});
}

/// @nodoc
class __$$SocketAddress_TcpIpV4ImplCopyWithImpl<$Res>
    extends _$SocketAddressCopyWithImpl<$Res, _$SocketAddress_TcpIpV4Impl>
    implements _$$SocketAddress_TcpIpV4ImplCopyWith<$Res> {
  __$$SocketAddress_TcpIpV4ImplCopyWithImpl(_$SocketAddress_TcpIpV4Impl _value,
      $Res Function(_$SocketAddress_TcpIpV4Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? addr = null,
    Object? port = null,
  }) {
    return _then(_$SocketAddress_TcpIpV4Impl(
      addr: null == addr
          ? _value.addr
          : addr // ignore: cast_nullable_to_non_nullable
              as U8Array4,
      port: null == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SocketAddress_TcpIpV4Impl extends SocketAddress_TcpIpV4 {
  const _$SocketAddress_TcpIpV4Impl({required this.addr, required this.port})
      : super._();

  @override
  final U8Array4 addr;
  @override
  final int port;

  @override
  String toString() {
    return 'SocketAddress.tcpIpV4(addr: $addr, port: $port)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SocketAddress_TcpIpV4Impl &&
            const DeepCollectionEquality().equals(other.addr, addr) &&
            (identical(other.port, port) || other.port == port));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(addr), port);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SocketAddress_TcpIpV4ImplCopyWith<_$SocketAddress_TcpIpV4Impl>
      get copyWith => __$$SocketAddress_TcpIpV4ImplCopyWithImpl<
          _$SocketAddress_TcpIpV4Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(U8Array4 addr, int port) tcpIpV4,
    required TResult Function(U8Array16 addr, int port) tcpIpV6,
    required TResult Function(U8Array12 field0) onionV2,
    required TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)
        onionV3,
    required TResult Function(String addr, int port) hostname,
  }) {
    return tcpIpV4(addr, port);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(U8Array4 addr, int port)? tcpIpV4,
    TResult? Function(U8Array16 addr, int port)? tcpIpV6,
    TResult? Function(U8Array12 field0)? onionV2,
    TResult? Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult? Function(String addr, int port)? hostname,
  }) {
    return tcpIpV4?.call(addr, port);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(U8Array4 addr, int port)? tcpIpV4,
    TResult Function(U8Array16 addr, int port)? tcpIpV6,
    TResult Function(U8Array12 field0)? onionV2,
    TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult Function(String addr, int port)? hostname,
    required TResult orElse(),
  }) {
    if (tcpIpV4 != null) {
      return tcpIpV4(addr, port);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SocketAddress_TcpIpV4 value) tcpIpV4,
    required TResult Function(SocketAddress_TcpIpV6 value) tcpIpV6,
    required TResult Function(SocketAddress_OnionV2 value) onionV2,
    required TResult Function(SocketAddress_OnionV3 value) onionV3,
    required TResult Function(SocketAddress_Hostname value) hostname,
  }) {
    return tcpIpV4(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult? Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult? Function(SocketAddress_OnionV2 value)? onionV2,
    TResult? Function(SocketAddress_OnionV3 value)? onionV3,
    TResult? Function(SocketAddress_Hostname value)? hostname,
  }) {
    return tcpIpV4?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult Function(SocketAddress_OnionV2 value)? onionV2,
    TResult Function(SocketAddress_OnionV3 value)? onionV3,
    TResult Function(SocketAddress_Hostname value)? hostname,
    required TResult orElse(),
  }) {
    if (tcpIpV4 != null) {
      return tcpIpV4(this);
    }
    return orElse();
  }
}

abstract class SocketAddress_TcpIpV4 extends SocketAddress {
  const factory SocketAddress_TcpIpV4(
      {required final U8Array4 addr,
      required final int port}) = _$SocketAddress_TcpIpV4Impl;
  const SocketAddress_TcpIpV4._() : super._();

  U8Array4 get addr;
  int get port;
  @JsonKey(ignore: true)
  _$$SocketAddress_TcpIpV4ImplCopyWith<_$SocketAddress_TcpIpV4Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SocketAddress_TcpIpV6ImplCopyWith<$Res> {
  factory _$$SocketAddress_TcpIpV6ImplCopyWith(
          _$SocketAddress_TcpIpV6Impl value,
          $Res Function(_$SocketAddress_TcpIpV6Impl) then) =
      __$$SocketAddress_TcpIpV6ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({U8Array16 addr, int port});
}

/// @nodoc
class __$$SocketAddress_TcpIpV6ImplCopyWithImpl<$Res>
    extends _$SocketAddressCopyWithImpl<$Res, _$SocketAddress_TcpIpV6Impl>
    implements _$$SocketAddress_TcpIpV6ImplCopyWith<$Res> {
  __$$SocketAddress_TcpIpV6ImplCopyWithImpl(_$SocketAddress_TcpIpV6Impl _value,
      $Res Function(_$SocketAddress_TcpIpV6Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? addr = null,
    Object? port = null,
  }) {
    return _then(_$SocketAddress_TcpIpV6Impl(
      addr: null == addr
          ? _value.addr
          : addr // ignore: cast_nullable_to_non_nullable
              as U8Array16,
      port: null == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SocketAddress_TcpIpV6Impl extends SocketAddress_TcpIpV6 {
  const _$SocketAddress_TcpIpV6Impl({required this.addr, required this.port})
      : super._();

  @override
  final U8Array16 addr;
  @override
  final int port;

  @override
  String toString() {
    return 'SocketAddress.tcpIpV6(addr: $addr, port: $port)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SocketAddress_TcpIpV6Impl &&
            const DeepCollectionEquality().equals(other.addr, addr) &&
            (identical(other.port, port) || other.port == port));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(addr), port);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SocketAddress_TcpIpV6ImplCopyWith<_$SocketAddress_TcpIpV6Impl>
      get copyWith => __$$SocketAddress_TcpIpV6ImplCopyWithImpl<
          _$SocketAddress_TcpIpV6Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(U8Array4 addr, int port) tcpIpV4,
    required TResult Function(U8Array16 addr, int port) tcpIpV6,
    required TResult Function(U8Array12 field0) onionV2,
    required TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)
        onionV3,
    required TResult Function(String addr, int port) hostname,
  }) {
    return tcpIpV6(addr, port);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(U8Array4 addr, int port)? tcpIpV4,
    TResult? Function(U8Array16 addr, int port)? tcpIpV6,
    TResult? Function(U8Array12 field0)? onionV2,
    TResult? Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult? Function(String addr, int port)? hostname,
  }) {
    return tcpIpV6?.call(addr, port);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(U8Array4 addr, int port)? tcpIpV4,
    TResult Function(U8Array16 addr, int port)? tcpIpV6,
    TResult Function(U8Array12 field0)? onionV2,
    TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult Function(String addr, int port)? hostname,
    required TResult orElse(),
  }) {
    if (tcpIpV6 != null) {
      return tcpIpV6(addr, port);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SocketAddress_TcpIpV4 value) tcpIpV4,
    required TResult Function(SocketAddress_TcpIpV6 value) tcpIpV6,
    required TResult Function(SocketAddress_OnionV2 value) onionV2,
    required TResult Function(SocketAddress_OnionV3 value) onionV3,
    required TResult Function(SocketAddress_Hostname value) hostname,
  }) {
    return tcpIpV6(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult? Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult? Function(SocketAddress_OnionV2 value)? onionV2,
    TResult? Function(SocketAddress_OnionV3 value)? onionV3,
    TResult? Function(SocketAddress_Hostname value)? hostname,
  }) {
    return tcpIpV6?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult Function(SocketAddress_OnionV2 value)? onionV2,
    TResult Function(SocketAddress_OnionV3 value)? onionV3,
    TResult Function(SocketAddress_Hostname value)? hostname,
    required TResult orElse(),
  }) {
    if (tcpIpV6 != null) {
      return tcpIpV6(this);
    }
    return orElse();
  }
}

abstract class SocketAddress_TcpIpV6 extends SocketAddress {
  const factory SocketAddress_TcpIpV6(
      {required final U8Array16 addr,
      required final int port}) = _$SocketAddress_TcpIpV6Impl;
  const SocketAddress_TcpIpV6._() : super._();

  U8Array16 get addr;
  int get port;
  @JsonKey(ignore: true)
  _$$SocketAddress_TcpIpV6ImplCopyWith<_$SocketAddress_TcpIpV6Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SocketAddress_OnionV2ImplCopyWith<$Res> {
  factory _$$SocketAddress_OnionV2ImplCopyWith(
          _$SocketAddress_OnionV2Impl value,
          $Res Function(_$SocketAddress_OnionV2Impl) then) =
      __$$SocketAddress_OnionV2ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({U8Array12 field0});
}

/// @nodoc
class __$$SocketAddress_OnionV2ImplCopyWithImpl<$Res>
    extends _$SocketAddressCopyWithImpl<$Res, _$SocketAddress_OnionV2Impl>
    implements _$$SocketAddress_OnionV2ImplCopyWith<$Res> {
  __$$SocketAddress_OnionV2ImplCopyWithImpl(_$SocketAddress_OnionV2Impl _value,
      $Res Function(_$SocketAddress_OnionV2Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SocketAddress_OnionV2Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as U8Array12,
    ));
  }
}

/// @nodoc

class _$SocketAddress_OnionV2Impl extends SocketAddress_OnionV2 {
  const _$SocketAddress_OnionV2Impl(this.field0) : super._();

  @override
  final U8Array12 field0;

  @override
  String toString() {
    return 'SocketAddress.onionV2(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SocketAddress_OnionV2Impl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SocketAddress_OnionV2ImplCopyWith<_$SocketAddress_OnionV2Impl>
      get copyWith => __$$SocketAddress_OnionV2ImplCopyWithImpl<
          _$SocketAddress_OnionV2Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(U8Array4 addr, int port) tcpIpV4,
    required TResult Function(U8Array16 addr, int port) tcpIpV6,
    required TResult Function(U8Array12 field0) onionV2,
    required TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)
        onionV3,
    required TResult Function(String addr, int port) hostname,
  }) {
    return onionV2(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(U8Array4 addr, int port)? tcpIpV4,
    TResult? Function(U8Array16 addr, int port)? tcpIpV6,
    TResult? Function(U8Array12 field0)? onionV2,
    TResult? Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult? Function(String addr, int port)? hostname,
  }) {
    return onionV2?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(U8Array4 addr, int port)? tcpIpV4,
    TResult Function(U8Array16 addr, int port)? tcpIpV6,
    TResult Function(U8Array12 field0)? onionV2,
    TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult Function(String addr, int port)? hostname,
    required TResult orElse(),
  }) {
    if (onionV2 != null) {
      return onionV2(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SocketAddress_TcpIpV4 value) tcpIpV4,
    required TResult Function(SocketAddress_TcpIpV6 value) tcpIpV6,
    required TResult Function(SocketAddress_OnionV2 value) onionV2,
    required TResult Function(SocketAddress_OnionV3 value) onionV3,
    required TResult Function(SocketAddress_Hostname value) hostname,
  }) {
    return onionV2(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult? Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult? Function(SocketAddress_OnionV2 value)? onionV2,
    TResult? Function(SocketAddress_OnionV3 value)? onionV3,
    TResult? Function(SocketAddress_Hostname value)? hostname,
  }) {
    return onionV2?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult Function(SocketAddress_OnionV2 value)? onionV2,
    TResult Function(SocketAddress_OnionV3 value)? onionV3,
    TResult Function(SocketAddress_Hostname value)? hostname,
    required TResult orElse(),
  }) {
    if (onionV2 != null) {
      return onionV2(this);
    }
    return orElse();
  }
}

abstract class SocketAddress_OnionV2 extends SocketAddress {
  const factory SocketAddress_OnionV2(final U8Array12 field0) =
      _$SocketAddress_OnionV2Impl;
  const SocketAddress_OnionV2._() : super._();

  U8Array12 get field0;
  @JsonKey(ignore: true)
  _$$SocketAddress_OnionV2ImplCopyWith<_$SocketAddress_OnionV2Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SocketAddress_OnionV3ImplCopyWith<$Res> {
  factory _$$SocketAddress_OnionV3ImplCopyWith(
          _$SocketAddress_OnionV3Impl value,
          $Res Function(_$SocketAddress_OnionV3Impl) then) =
      __$$SocketAddress_OnionV3ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({U8Array32 ed25519Pubkey, int checksum, int version, int port});
}

/// @nodoc
class __$$SocketAddress_OnionV3ImplCopyWithImpl<$Res>
    extends _$SocketAddressCopyWithImpl<$Res, _$SocketAddress_OnionV3Impl>
    implements _$$SocketAddress_OnionV3ImplCopyWith<$Res> {
  __$$SocketAddress_OnionV3ImplCopyWithImpl(_$SocketAddress_OnionV3Impl _value,
      $Res Function(_$SocketAddress_OnionV3Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ed25519Pubkey = null,
    Object? checksum = null,
    Object? version = null,
    Object? port = null,
  }) {
    return _then(_$SocketAddress_OnionV3Impl(
      ed25519Pubkey: null == ed25519Pubkey
          ? _value.ed25519Pubkey
          : ed25519Pubkey // ignore: cast_nullable_to_non_nullable
              as U8Array32,
      checksum: null == checksum
          ? _value.checksum
          : checksum // ignore: cast_nullable_to_non_nullable
              as int,
      version: null == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as int,
      port: null == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SocketAddress_OnionV3Impl extends SocketAddress_OnionV3 {
  const _$SocketAddress_OnionV3Impl(
      {required this.ed25519Pubkey,
      required this.checksum,
      required this.version,
      required this.port})
      : super._();

  @override
  final U8Array32 ed25519Pubkey;
  @override
  final int checksum;
  @override
  final int version;
  @override
  final int port;

  @override
  String toString() {
    return 'SocketAddress.onionV3(ed25519Pubkey: $ed25519Pubkey, checksum: $checksum, version: $version, port: $port)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SocketAddress_OnionV3Impl &&
            const DeepCollectionEquality()
                .equals(other.ed25519Pubkey, ed25519Pubkey) &&
            (identical(other.checksum, checksum) ||
                other.checksum == checksum) &&
            (identical(other.version, version) || other.version == version) &&
            (identical(other.port, port) || other.port == port));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(ed25519Pubkey),
      checksum,
      version,
      port);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SocketAddress_OnionV3ImplCopyWith<_$SocketAddress_OnionV3Impl>
      get copyWith => __$$SocketAddress_OnionV3ImplCopyWithImpl<
          _$SocketAddress_OnionV3Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(U8Array4 addr, int port) tcpIpV4,
    required TResult Function(U8Array16 addr, int port) tcpIpV6,
    required TResult Function(U8Array12 field0) onionV2,
    required TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)
        onionV3,
    required TResult Function(String addr, int port) hostname,
  }) {
    return onionV3(ed25519Pubkey, checksum, version, port);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(U8Array4 addr, int port)? tcpIpV4,
    TResult? Function(U8Array16 addr, int port)? tcpIpV6,
    TResult? Function(U8Array12 field0)? onionV2,
    TResult? Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult? Function(String addr, int port)? hostname,
  }) {
    return onionV3?.call(ed25519Pubkey, checksum, version, port);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(U8Array4 addr, int port)? tcpIpV4,
    TResult Function(U8Array16 addr, int port)? tcpIpV6,
    TResult Function(U8Array12 field0)? onionV2,
    TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult Function(String addr, int port)? hostname,
    required TResult orElse(),
  }) {
    if (onionV3 != null) {
      return onionV3(ed25519Pubkey, checksum, version, port);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SocketAddress_TcpIpV4 value) tcpIpV4,
    required TResult Function(SocketAddress_TcpIpV6 value) tcpIpV6,
    required TResult Function(SocketAddress_OnionV2 value) onionV2,
    required TResult Function(SocketAddress_OnionV3 value) onionV3,
    required TResult Function(SocketAddress_Hostname value) hostname,
  }) {
    return onionV3(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult? Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult? Function(SocketAddress_OnionV2 value)? onionV2,
    TResult? Function(SocketAddress_OnionV3 value)? onionV3,
    TResult? Function(SocketAddress_Hostname value)? hostname,
  }) {
    return onionV3?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult Function(SocketAddress_OnionV2 value)? onionV2,
    TResult Function(SocketAddress_OnionV3 value)? onionV3,
    TResult Function(SocketAddress_Hostname value)? hostname,
    required TResult orElse(),
  }) {
    if (onionV3 != null) {
      return onionV3(this);
    }
    return orElse();
  }
}

abstract class SocketAddress_OnionV3 extends SocketAddress {
  const factory SocketAddress_OnionV3(
      {required final U8Array32 ed25519Pubkey,
      required final int checksum,
      required final int version,
      required final int port}) = _$SocketAddress_OnionV3Impl;
  const SocketAddress_OnionV3._() : super._();

  U8Array32 get ed25519Pubkey;
  int get checksum;
  int get version;
  int get port;
  @JsonKey(ignore: true)
  _$$SocketAddress_OnionV3ImplCopyWith<_$SocketAddress_OnionV3Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SocketAddress_HostnameImplCopyWith<$Res> {
  factory _$$SocketAddress_HostnameImplCopyWith(
          _$SocketAddress_HostnameImpl value,
          $Res Function(_$SocketAddress_HostnameImpl) then) =
      __$$SocketAddress_HostnameImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String addr, int port});
}

/// @nodoc
class __$$SocketAddress_HostnameImplCopyWithImpl<$Res>
    extends _$SocketAddressCopyWithImpl<$Res, _$SocketAddress_HostnameImpl>
    implements _$$SocketAddress_HostnameImplCopyWith<$Res> {
  __$$SocketAddress_HostnameImplCopyWithImpl(
      _$SocketAddress_HostnameImpl _value,
      $Res Function(_$SocketAddress_HostnameImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? addr = null,
    Object? port = null,
  }) {
    return _then(_$SocketAddress_HostnameImpl(
      addr: null == addr
          ? _value.addr
          : addr // ignore: cast_nullable_to_non_nullable
              as String,
      port: null == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SocketAddress_HostnameImpl extends SocketAddress_Hostname {
  const _$SocketAddress_HostnameImpl({required this.addr, required this.port})
      : super._();

  @override
  final String addr;
  @override
  final int port;

  @override
  String toString() {
    return 'SocketAddress.hostname(addr: $addr, port: $port)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SocketAddress_HostnameImpl &&
            (identical(other.addr, addr) || other.addr == addr) &&
            (identical(other.port, port) || other.port == port));
  }

  @override
  int get hashCode => Object.hash(runtimeType, addr, port);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SocketAddress_HostnameImplCopyWith<_$SocketAddress_HostnameImpl>
      get copyWith => __$$SocketAddress_HostnameImplCopyWithImpl<
          _$SocketAddress_HostnameImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(U8Array4 addr, int port) tcpIpV4,
    required TResult Function(U8Array16 addr, int port) tcpIpV6,
    required TResult Function(U8Array12 field0) onionV2,
    required TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)
        onionV3,
    required TResult Function(String addr, int port) hostname,
  }) {
    return hostname(addr, port);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(U8Array4 addr, int port)? tcpIpV4,
    TResult? Function(U8Array16 addr, int port)? tcpIpV6,
    TResult? Function(U8Array12 field0)? onionV2,
    TResult? Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult? Function(String addr, int port)? hostname,
  }) {
    return hostname?.call(addr, port);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(U8Array4 addr, int port)? tcpIpV4,
    TResult Function(U8Array16 addr, int port)? tcpIpV6,
    TResult Function(U8Array12 field0)? onionV2,
    TResult Function(
            U8Array32 ed25519Pubkey, int checksum, int version, int port)?
        onionV3,
    TResult Function(String addr, int port)? hostname,
    required TResult orElse(),
  }) {
    if (hostname != null) {
      return hostname(addr, port);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SocketAddress_TcpIpV4 value) tcpIpV4,
    required TResult Function(SocketAddress_TcpIpV6 value) tcpIpV6,
    required TResult Function(SocketAddress_OnionV2 value) onionV2,
    required TResult Function(SocketAddress_OnionV3 value) onionV3,
    required TResult Function(SocketAddress_Hostname value) hostname,
  }) {
    return hostname(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult? Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult? Function(SocketAddress_OnionV2 value)? onionV2,
    TResult? Function(SocketAddress_OnionV3 value)? onionV3,
    TResult? Function(SocketAddress_Hostname value)? hostname,
  }) {
    return hostname?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SocketAddress_TcpIpV4 value)? tcpIpV4,
    TResult Function(SocketAddress_TcpIpV6 value)? tcpIpV6,
    TResult Function(SocketAddress_OnionV2 value)? onionV2,
    TResult Function(SocketAddress_OnionV3 value)? onionV3,
    TResult Function(SocketAddress_Hostname value)? hostname,
    required TResult orElse(),
  }) {
    if (hostname != null) {
      return hostname(this);
    }
    return orElse();
  }
}

abstract class SocketAddress_Hostname extends SocketAddress {
  const factory SocketAddress_Hostname(
      {required final String addr,
      required final int port}) = _$SocketAddress_HostnameImpl;
  const SocketAddress_Hostname._() : super._();

  String get addr;
  int get port;
  @JsonKey(ignore: true)
  _$$SocketAddress_HostnameImplCopyWith<_$SocketAddress_HostnameImpl>
      get copyWith => throw _privateConstructorUsedError;
}
