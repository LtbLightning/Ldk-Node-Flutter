// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::bolt12::*;
use crate::api::builder::*;
use crate::api::node::*;
use crate::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.0.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 1761952349;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__bolt11__ldk_bolt_11_payment_claim_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::LdkBolt11Payment>,
    payment_hash: impl CstDecode<crate::api::types::PaymentHash>,
    claimable_amount_msat: impl CstDecode<u64>,
    preimage: impl CstDecode<crate::api::types::PaymentPreimage>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_claim_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            let api_claimable_amount_msat = claimable_amount_msat.cst_decode();
            let api_preimage = preimage.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::bolt11::LdkBolt11Payment::claim_for_hash(
                        &api_that,
                        api_payment_hash,
                        api_claimable_amount_msat,
                        api_preimage,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ldk_bolt_11_payment_fail_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::LdkBolt11Payment>,
    payment_hash: impl CstDecode<crate::api::types::PaymentHash>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_fail_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::bolt11::LdkBolt11Payment::fail_for_hash(
                        &api_that,
                        api_payment_hash,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ldk_bolt_11_payment_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::LdkBolt11Payment>,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::bolt11::LdkBolt11Payment::receive(
                        &api_that,
                        api_amount_msat,
                        api_description,
                        api_expiry_secs,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ldk_bolt_11_payment_receive_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::LdkBolt11Payment>,
    payment_hash: impl CstDecode<crate::api::types::PaymentHash>,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_receive_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::bolt11::LdkBolt11Payment::receive_for_hash(
                        &api_that,
                        api_payment_hash,
                        api_amount_msat,
                        api_description,
                        api_expiry_secs,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ldk_bolt_11_payment_receive_variable_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::LdkBolt11Payment>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_receive_variable_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::bolt11::LdkBolt11Payment::receive_variable_amount(
                        &api_that,
                        api_description,
                        api_expiry_secs,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ldk_bolt_11_payment_receive_variable_amount_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::LdkBolt11Payment>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    payment_hash: impl CstDecode<crate::api::types::PaymentHash>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_receive_variable_amount_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok =
                        crate::api::bolt11::LdkBolt11Payment::receive_variable_amount_for_hash(
                            &api_that,
                            api_description,
                            api_expiry_secs,
                            api_payment_hash,
                        )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ldk_bolt_11_payment_receive_variable_amount_via_jit_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::LdkBolt11Payment>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    max_proportional_lsp_fee_limit_ppm_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ldk_bolt_11_payment_receive_variable_amount_via_jit_channel", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { let api_that = that.cst_decode();let api_description = description.cst_decode();let api_expiry_secs = expiry_secs.cst_decode();let api_max_proportional_lsp_fee_limit_ppm_msat = max_proportional_lsp_fee_limit_ppm_msat.cst_decode(); move |context|  {
                    transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move ||  {
                         let output_ok = crate::api::bolt11::LdkBolt11Payment::receive_variable_amount_via_jit_channel(&api_that, api_description, api_expiry_secs, api_max_proportional_lsp_fee_limit_ppm_msat)?;  Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__bolt11__ldk_bolt_11_payment_receive_via_jit_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::LdkBolt11Payment>,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    max_total_lsp_fee_limit_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_receive_via_jit_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_max_total_lsp_fee_limit_msat = max_total_lsp_fee_limit_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::bolt11::LdkBolt11Payment::receive_via_jit_channel(
                        &api_that,
                        api_amount_msat,
                        api_description,
                        api_expiry_secs,
                        api_max_total_lsp_fee_limit_msat,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ldk_bolt_11_payment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::LdkBolt11Payment>,
    invoice: impl CstDecode<crate::api::bolt11::Bolt11Invoice>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok =
                        crate::api::bolt11::LdkBolt11Payment::send(&api_that, api_invoice)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ldk_bolt_11_payment_send_probes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::LdkBolt11Payment>,
    invoice: impl CstDecode<crate::api::bolt11::Bolt11Invoice>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_send_probes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok =
                        crate::api::bolt11::LdkBolt11Payment::send_probes(&api_that, api_invoice)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ldk_bolt_11_payment_send_probes_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::LdkBolt11Payment>,
    invoice: impl CstDecode<crate::api::bolt11::Bolt11Invoice>,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_send_probes_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::bolt11::LdkBolt11Payment::send_probes_using_amount(
                        &api_that,
                        api_invoice,
                        api_amount_msat,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ldk_bolt_11_payment_send_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::LdkBolt11Payment>,
    invoice: impl CstDecode<crate::api::bolt11::Bolt11Invoice>,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_send_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::bolt11::LdkBolt11Payment::send_using_amount(
                        &api_that,
                        api_invoice,
                        api_amount_msat,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt12__ldk_bolt_12_payment_initiate_refund_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt12::LdkBolt12Payment>,
    amount_msat: impl CstDecode<u64>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_12_payment_initiate_refund",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::bolt12::LdkBolt12Payment::initiate_refund(
                        &api_that,
                        api_amount_msat,
                        api_expiry_secs,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt12__ldk_bolt_12_payment_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt12::LdkBolt12Payment>,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_12_payment_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::bolt12::LdkBolt12Payment::receive(
                        &api_that,
                        api_amount_msat,
                        api_description,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt12__ldk_bolt_12_payment_receive_variable_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt12::LdkBolt12Payment>,
    description: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_12_payment_receive_variable_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::bolt12::LdkBolt12Payment::receive_variable_amount(
                        &api_that,
                        api_description,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt12__ldk_bolt_12_payment_request_refund_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt12::LdkBolt12Payment>,
    refund: impl CstDecode<crate::api::bolt12::Refund>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_12_payment_request_refund_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_refund = refund.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::bolt12::LdkBolt12Payment::request_refund_payment(
                        &api_that, api_refund,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt12__ldk_bolt_12_payment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt12::LdkBolt12Payment>,
    offer: impl CstDecode<crate::api::bolt12::Offer>,
    payer_note: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_12_payment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_offer = offer.cst_decode();
            let api_payer_note = payer_note.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::bolt12::LdkBolt12Payment::send(
                        &api_that,
                        api_offer,
                        api_payer_note,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt12__ldk_bolt_12_payment_send_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt12::LdkBolt12Payment>,
    offer: impl CstDecode<crate::api::bolt12::Offer>,
    payer_note: impl CstDecode<Option<String>>,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_12_payment_send_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_offer = offer.cst_decode();
            let api_payer_note = payer_note.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::bolt12::LdkBolt12Payment::send_using_amount(
                        &api_that,
                        api_offer,
                        api_payer_note,
                        api_amount_msat,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__builder__NodeBuilder_auto_accessor_get_builder_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NodeBuilder>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBuilder_auto_accessor_get_builder",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.builder.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__builder__NodeBuilder_auto_accessor_set_builder_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NodeBuilder>>,
    >,
    builder: impl CstDecode<RustOpaqueNom<ldk_node::Builder>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBuilder_auto_accessor_set_builder",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_builder = builder.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.builder = api_builder;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__builder__NodeBuilder_build_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<NodeBuilder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBuilder_build",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkBuilderError>((move || {
                    let output_ok = crate::api::builder::NodeBuilder::build(api_that)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__builder__NodeBuilder_build_with_fs_store_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<NodeBuilder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBuilder_build_with_fs_store",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkBuilderError>((move || {
                    let output_ok =
                        crate::api::builder::NodeBuilder::build_with_fs_store(api_that)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__builder__NodeBuilder_create_builder_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    config: impl CstDecode<crate::api::types::Config>,
    chain_data_source_config: impl CstDecode<Option<crate::api::types::ChainDataSourceConfig>>,
    entropy_source_config: impl CstDecode<Option<crate::api::types::EntropySourceConfig>>,
    gossip_source_config: impl CstDecode<Option<crate::api::types::GossipSourceConfig>>,
    liquidity_source_config: impl CstDecode<Option<crate::api::types::LiquiditySourceConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBuilder_create_builder",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_config = config.cst_decode();
            let api_chain_data_source_config = chain_data_source_config.cst_decode();
            let api_entropy_source_config = entropy_source_config.cst_decode();
            let api_gossip_source_config = gossip_source_config.cst_decode();
            let api_liquidity_source_config = liquidity_source_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkBuilderError>((move || {
                    let output_ok = crate::api::builder::NodeBuilder::create_builder(
                        api_config,
                        api_chain_data_source_config,
                        api_entropy_source_config,
                        api_gossip_source_config,
                        api_liquidity_source_config,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__builder__ldk_mnemonic_generate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_mnemonic_generate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::builder::LdkMnemonic::generate())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__graph__ldk_network_graph_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::graph::LdkNetworkGraph>,
    short_channel_id: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_network_graph_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_short_channel_id = short_channel_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::graph::LdkNetworkGraph::channel(
                            &api_that,
                            api_short_channel_id,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__graph__ldk_network_graph_list_channels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::graph::LdkNetworkGraph>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_network_graph_list_channels",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::graph::LdkNetworkGraph::list_channels(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__graph__ldk_network_graph_list_nodes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::graph::LdkNetworkGraph>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_network_graph_list_nodes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::graph::LdkNetworkGraph::list_nodes(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__graph__ldk_network_graph_node_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::graph::LdkNetworkGraph>,
    node_id: impl CstDecode<crate::api::graph::NodeId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_network_graph_node",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_node_id = node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok =
                        crate::api::graph::LdkNetworkGraph::node(&api_that, api_node_id)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_bolt11_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_bolt11_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::LdkNode::bolt11_payment(api_ptr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_bolt12_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_bolt12_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::LdkNode::bolt12_payment(api_ptr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_close_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    user_channel_id: impl CstDecode<crate::api::types::UserChannelId>,
    counterparty_node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_close_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::node::LdkNode::close_channel(
                        &api_that,
                        api_user_channel_id,
                        api_counterparty_node_id,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::LdkNode::config(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_connect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
    address: impl CstDecode<crate::api::types::SocketAddress>,
    persist: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_connect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_address = address.cst_decode();
            let api_persist = persist.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::node::LdkNode::connect(
                        &api_that,
                        api_node_id,
                        api_address,
                        api_persist,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_connect_open_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    socket_address: impl CstDecode<crate::api::types::SocketAddress>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
    channel_amount_sats: impl CstDecode<u64>,
    push_to_counterparty_msat: impl CstDecode<Option<u64>>,
    announce_channel: impl CstDecode<bool>,
    channel_config: impl CstDecode<Option<crate::api::types::ChannelConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_connect_open_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_socket_address = socket_address.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_channel_amount_sats = channel_amount_sats.cst_decode();
            let api_push_to_counterparty_msat = push_to_counterparty_msat.cst_decode();
            let api_announce_channel = announce_channel.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::node::LdkNode::connect_open_channel(
                        &api_that,
                        api_socket_address,
                        api_node_id,
                        api_channel_amount_sats,
                        api_push_to_counterparty_msat,
                        api_announce_channel,
                        api_channel_config,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_disconnect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    counterparty_node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_disconnect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok =
                        crate::api::node::LdkNode::disconnect(&api_that, api_counterparty_node_id)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_event_handled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_event_handled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::node::LdkNode::event_handled(&api_that);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_force_close_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    user_channel_id: impl CstDecode<crate::api::types::UserChannelId>,
    counterparty_node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_force_close_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::node::LdkNode::force_close_channel(
                        &api_that,
                        api_user_channel_id,
                        api_counterparty_node_id,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_list_balances_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_list_balances",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::node::LdkNode::list_balances(&api_that)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_list_channels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_list_channels",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::LdkNode::list_channels(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_list_payments_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_list_payments",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::LdkNode::list_payments(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_list_payments_with_filter_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    payment_direction: impl CstDecode<crate::api::types::PaymentDirection>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_list_payments_with_filter",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_direction = payment_direction.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::LdkNode::list_payments_with_filter(
                            &api_that,
                            api_payment_direction,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_list_peers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_list_peers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::LdkNode::list_peers(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_listening_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_listening_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::node::LdkNode::listening_addresses(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_network_graph_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_network_graph",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::LdkNode::network_graph(api_ptr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_next_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_next_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::LdkNode::next_event(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_next_event_async_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_next_event_async",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::node::LdkNode::next_event_async(&api_that).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_node_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_node_id",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::LdkNode::node_id(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_on_chain_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_on_chain_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::LdkNode::on_chain_payment(api_ptr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    payment_id: impl CstDecode<crate::api::types::PaymentId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_id = payment_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::node::LdkNode::payment(
                        &api_that,
                        api_payment_id,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_remove_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    payment_id: impl CstDecode<crate::api::types::PaymentId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_remove_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_id = payment_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok =
                        crate::api::node::LdkNode::remove_payment(&api_that, api_payment_id)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_sign_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    msg: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_sign_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_msg = msg.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::node::LdkNode::sign_message(&api_that, api_msg)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_spontaneous_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_spontaneous_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::node::LdkNode::spontaneous_payment(api_ptr),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::node::LdkNode::start(&api_that)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_status_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_status",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::LdkNode::status(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_stop_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_stop",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::node::LdkNode::stop(&api_that)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_sync_wallets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_sync_wallets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::node::LdkNode::sync_wallets(&api_that)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_update_channel_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    user_channel_id: impl CstDecode<crate::api::types::UserChannelId>,
    counterparty_node_id: impl CstDecode<crate::api::types::PublicKey>,
    channel_config: impl CstDecode<crate::api::types::ChannelConfig>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_update_channel_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::node::LdkNode::update_channel_config(
                        &api_that,
                        api_user_channel_id,
                        api_counterparty_node_id,
                        api_channel_config,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_verify_signature_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    msg: impl CstDecode<Vec<u8>>,
    sig: impl CstDecode<String>,
    public_key: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_verify_signature",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_msg = msg.cst_decode();
            let api_sig = sig.cst_decode();
            let api_public_key = public_key.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::node::LdkNode::verify_signature(
                        &api_that,
                        api_msg,
                        api_sig,
                        api_public_key,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ldk_node_wait_next_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_wait_next_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::LdkNode::wait_next_event(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__on_chain__ldk_on_chain_payment_new_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::on_chain::LdkOnChainPayment>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_on_chain_payment_new_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok =
                        crate::api::on_chain::LdkOnChainPayment::new_address(&api_that)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__on_chain__ldk_on_chain_payment_send_all_to_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::on_chain::LdkOnChainPayment>,
    address: impl CstDecode<crate::api::types::Address>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_on_chain_payment_send_all_to_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::on_chain::LdkOnChainPayment::send_all_to_address(
                        &api_that,
                        api_address,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__on_chain__ldk_on_chain_payment_send_to_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::on_chain::LdkOnChainPayment>,
    address: impl CstDecode<crate::api::types::Address>,
    amount_sats: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_on_chain_payment_send_to_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            let api_amount_sats = amount_sats.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::on_chain::LdkOnChainPayment::send_to_address(
                        &api_that,
                        api_address,
                        api_amount_sats,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__spontaneous__ldk_spontaneous_payment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::spontaneous::LdkSpontaneousPayment>,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_spontaneous_payment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_node_id = node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::spontaneous::LdkSpontaneousPayment::send(
                        &api_that,
                        api_amount_msat,
                        api_node_id,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__spontaneous__ldk_spontaneous_payment_send_probes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::spontaneous::LdkSpontaneousPayment>,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_spontaneous_payment_send_probes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_node_id = node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::LdkNodeError>((move || {
                    let output_ok = crate::api::spontaneous::LdkSpontaneousPayment::send_probes(
                        &api_that,
                        api_amount_msat,
                        api_node_id,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<crate::utils::error::LdkBuilderError> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::utils::error::LdkBuilderError {
        match self {
            0 => crate::utils::error::LdkBuilderError::SocketAddressParseError,
            1 => crate::utils::error::LdkBuilderError::InvalidSeedBytes,
            2 => crate::utils::error::LdkBuilderError::InvalidSeedFile,
            3 => crate::utils::error::LdkBuilderError::InvalidSystemTime,
            4 => crate::utils::error::LdkBuilderError::InvalidChannelMonitor,
            5 => crate::utils::error::LdkBuilderError::InvalidListeningAddress,
            6 => crate::utils::error::LdkBuilderError::ReadFailed,
            7 => crate::utils::error::LdkBuilderError::WriteFailed,
            8 => crate::utils::error::LdkBuilderError::StoragePathAccessFailed,
            9 => crate::utils::error::LdkBuilderError::KVStoreSetupFailed,
            10 => crate::utils::error::LdkBuilderError::WalletSetupFailed,
            11 => crate::utils::error::LdkBuilderError::LoggerSetupFailed,
            12 => crate::utils::error::LdkBuilderError::InvalidPublicKey,
            _ => unreachable!("Invalid variant for LdkBuilderError: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::LogLevel> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::LogLevel {
        match self {
            0 => crate::api::types::LogLevel::Gossip,
            1 => crate::api::types::LogLevel::Trace,
            2 => crate::api::types::LogLevel::Debug,
            3 => crate::api::types::LogLevel::Info,
            4 => crate::api::types::LogLevel::Warn,
            5 => crate::api::types::LogLevel::Error,
            _ => unreachable!("Invalid variant for LogLevel: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::Network> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Network {
        match self {
            0 => crate::api::types::Network::Bitcoin,
            1 => crate::api::types::Network::Testnet,
            2 => crate::api::types::Network::Signet,
            3 => crate::api::types::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::PaymentDirection> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::PaymentDirection {
        match self {
            0 => crate::api::types::PaymentDirection::Inbound,
            1 => crate::api::types::PaymentDirection::Outbound,
            _ => unreachable!("Invalid variant for PaymentDirection: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::PaymentFailureReason> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::PaymentFailureReason {
        match self {
            0 => crate::api::types::PaymentFailureReason::RecipientRejected,
            1 => crate::api::types::PaymentFailureReason::UserAbandoned,
            2 => crate::api::types::PaymentFailureReason::RetriesExhausted,
            3 => crate::api::types::PaymentFailureReason::PaymentExpired,
            4 => crate::api::types::PaymentFailureReason::RouteNotFound,
            5 => crate::api::types::PaymentFailureReason::UnexpectedError,
            _ => unreachable!("Invalid variant for PaymentFailureReason: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::PaymentStatus> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::PaymentStatus {
        match self {
            0 => crate::api::types::PaymentStatus::Pending,
            1 => crate::api::types::PaymentStatus::Succeeded,
            2 => crate::api::types::PaymentStatus::Failed,
            _ => unreachable!("Invalid variant for PaymentStatus: {}", self),
        }
    }
}
impl CstDecode<u16> for u16 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u16 {
        self
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl SseDecode for NodeBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NodeBuilder>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for RustOpaqueNom<Arc<ldk_node::payment::Bolt12Payment>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<Node> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NodeBuilder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<ldk_node::Builder> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<ldk_node::graph::NetworkGraph> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<ldk_node::payment::Bolt11Payment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<ldk_node::payment::OnchainPayment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<ldk_node::payment::SpontaneousPayment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::types::Address {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_s = <String>::sse_decode(deserializer);
        return crate::api::types::Address { s: var_s };
    }
}

impl SseDecode for crate::api::types::AnchorChannelsConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_trustedPeersNoReserve =
            <Vec<crate::api::types::PublicKey>>::sse_decode(deserializer);
        let mut var_perChannelReserveSats = <u64>::sse_decode(deserializer);
        return crate::api::types::AnchorChannelsConfig {
            trusted_peers_no_reserve: var_trustedPeersNoReserve,
            per_channel_reserve_sats: var_perChannelReserveSats,
        };
    }
}

impl SseDecode for crate::api::types::BalanceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_totalOnchainBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_spendableOnchainBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_totalLightningBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_lightningBalances =
            <Vec<crate::api::types::LightningBalance>>::sse_decode(deserializer);
        let mut var_pendingBalancesFromChannelClosures =
            <Vec<crate::api::types::PendingSweepBalance>>::sse_decode(deserializer);
        return crate::api::types::BalanceDetails {
            total_onchain_balance_sats: var_totalOnchainBalanceSats,
            spendable_onchain_balance_sats: var_spendableOnchainBalanceSats,
            total_lightning_balance_sats: var_totalLightningBalanceSats,
            lightning_balances: var_lightningBalances,
            pending_balances_from_channel_closures: var_pendingBalancesFromChannelClosures,
        };
    }
}

impl SseDecode for crate::api::types::BestBlock {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_blockHash = <String>::sse_decode(deserializer);
        let mut var_height = <u32>::sse_decode(deserializer);
        return crate::api::types::BestBlock {
            block_hash: var_blockHash,
            height: var_height,
        };
    }
}

impl SseDecode for crate::api::bolt11::Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_signedRawInvoice = <String>::sse_decode(deserializer);
        return crate::api::bolt11::Bolt11Invoice {
            signed_raw_invoice: var_signedRawInvoice,
        };
    }
}

impl SseDecode for crate::api::bolt12::Bolt12Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::bolt12::Bolt12Invoice { data: var_data };
    }
}

impl SseDecode for crate::utils::error::Bolt12ParseError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::utils::error::Bolt12ParseError::InvalidContinuation;
            }
            1 => {
                return crate::utils::error::Bolt12ParseError::InvalidBech32Hrp;
            }
            2 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::utils::error::Bolt12ParseError::Bech32(var_field0);
            }
            3 => {
                let mut var_field0 = <crate::utils::error::DecodeError>::sse_decode(deserializer);
                return crate::utils::error::Bolt12ParseError::Decode(var_field0);
            }
            4 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::utils::error::Bolt12ParseError::InvalidSemantics(var_field0);
            }
            5 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::utils::error::Bolt12ParseError::InvalidSignature(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::types::ChainDataSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::types::ChainDataSourceConfig::Esplora(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::ChannelConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_forwardingFeeProportionalMillionths = <u32>::sse_decode(deserializer);
        let mut var_forwardingFeeBaseMsat = <u32>::sse_decode(deserializer);
        let mut var_cltvExpiryDelta = <u16>::sse_decode(deserializer);
        let mut var_maxDustHtlcExposure =
            <Option<crate::api::types::MaxDustHTLCExposure>>::sse_decode(deserializer);
        let mut var_forceCloseAvoidanceMaxFeeSatoshis = <u64>::sse_decode(deserializer);
        let mut var_acceptUnderpayingHtlcs = <bool>::sse_decode(deserializer);
        return crate::api::types::ChannelConfig {
            forwarding_fee_proportional_millionths: var_forwardingFeeProportionalMillionths,
            forwarding_fee_base_msat: var_forwardingFeeBaseMsat,
            cltv_expiry_delta: var_cltvExpiryDelta,
            max_dust_htlc_exposure: var_maxDustHtlcExposure,
            force_close_avoidance_max_fee_satoshis: var_forceCloseAvoidanceMaxFeeSatoshis,
            accept_underpaying_htlcs: var_acceptUnderpayingHtlcs,
        };
    }
}

impl SseDecode for crate::api::types::ChannelDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
        let mut var_counterpartyNodeId = <crate::api::types::PublicKey>::sse_decode(deserializer);
        let mut var_fundingTxo = <Option<crate::api::types::OutPoint>>::sse_decode(deserializer);
        let mut var_channelValueSats = <u64>::sse_decode(deserializer);
        let mut var_unspendablePunishmentReserve = <Option<u64>>::sse_decode(deserializer);
        let mut var_userChannelId = <crate::api::types::UserChannelId>::sse_decode(deserializer);
        let mut var_feerateSatPer1000Weight = <u32>::sse_decode(deserializer);
        let mut var_outboundCapacityMsat = <u64>::sse_decode(deserializer);
        let mut var_inboundCapacityMsat = <u64>::sse_decode(deserializer);
        let mut var_confirmationsRequired = <Option<u32>>::sse_decode(deserializer);
        let mut var_confirmations = <Option<u32>>::sse_decode(deserializer);
        let mut var_isOutbound = <bool>::sse_decode(deserializer);
        let mut var_isChannelReady = <bool>::sse_decode(deserializer);
        let mut var_isUsable = <bool>::sse_decode(deserializer);
        let mut var_isPublic = <bool>::sse_decode(deserializer);
        let mut var_cltvExpiryDelta = <Option<u16>>::sse_decode(deserializer);
        let mut var_counterpartyUnspendablePunishmentReserve = <u64>::sse_decode(deserializer);
        let mut var_counterpartyOutboundHtlcMinimumMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_counterpartyOutboundHtlcMaximumMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_counterpartyForwardingInfoFeeBaseMsat = <Option<u32>>::sse_decode(deserializer);
        let mut var_counterpartyForwardingInfoFeeProportionalMillionths =
            <Option<u32>>::sse_decode(deserializer);
        let mut var_counterpartyForwardingInfoCltvExpiryDelta =
            <Option<u16>>::sse_decode(deserializer);
        let mut var_nextOutboundHtlcLimitMsat = <u64>::sse_decode(deserializer);
        let mut var_nextOutboundHtlcMinimumMsat = <u64>::sse_decode(deserializer);
        let mut var_forceCloseSpendDelay = <Option<u16>>::sse_decode(deserializer);
        let mut var_inboundHtlcMinimumMsat = <u64>::sse_decode(deserializer);
        let mut var_inboundHtlcMaximumMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_config = <crate::api::types::ChannelConfig>::sse_decode(deserializer);
        return crate::api::types::ChannelDetails {
            channel_id: var_channelId,
            counterparty_node_id: var_counterpartyNodeId,
            funding_txo: var_fundingTxo,
            channel_value_sats: var_channelValueSats,
            unspendable_punishment_reserve: var_unspendablePunishmentReserve,
            user_channel_id: var_userChannelId,
            feerate_sat_per_1000_weight: var_feerateSatPer1000Weight,
            outbound_capacity_msat: var_outboundCapacityMsat,
            inbound_capacity_msat: var_inboundCapacityMsat,
            confirmations_required: var_confirmationsRequired,
            confirmations: var_confirmations,
            is_outbound: var_isOutbound,
            is_channel_ready: var_isChannelReady,
            is_usable: var_isUsable,
            is_public: var_isPublic,
            cltv_expiry_delta: var_cltvExpiryDelta,
            counterparty_unspendable_punishment_reserve:
                var_counterpartyUnspendablePunishmentReserve,
            counterparty_outbound_htlc_minimum_msat: var_counterpartyOutboundHtlcMinimumMsat,
            counterparty_outbound_htlc_maximum_msat: var_counterpartyOutboundHtlcMaximumMsat,
            counterparty_forwarding_info_fee_base_msat: var_counterpartyForwardingInfoFeeBaseMsat,
            counterparty_forwarding_info_fee_proportional_millionths:
                var_counterpartyForwardingInfoFeeProportionalMillionths,
            counterparty_forwarding_info_cltv_expiry_delta:
                var_counterpartyForwardingInfoCltvExpiryDelta,
            next_outbound_htlc_limit_msat: var_nextOutboundHtlcLimitMsat,
            next_outbound_htlc_minimum_msat: var_nextOutboundHtlcMinimumMsat,
            force_close_spend_delay: var_forceCloseSpendDelay,
            inbound_htlc_minimum_msat: var_inboundHtlcMinimumMsat,
            inbound_htlc_maximum_msat: var_inboundHtlcMaximumMsat,
            config: var_config,
        };
    }
}

impl SseDecode for crate::api::types::ChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::ChannelId { data: var_data };
    }
}

impl SseDecode for crate::api::graph::ChannelInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nodeOne = <crate::api::graph::NodeId>::sse_decode(deserializer);
        let mut var_oneToTwo =
            <Option<crate::api::graph::ChannelUpdateInfo>>::sse_decode(deserializer);
        let mut var_nodeTwo = <crate::api::graph::NodeId>::sse_decode(deserializer);
        let mut var_twoToOne =
            <Option<crate::api::graph::ChannelUpdateInfo>>::sse_decode(deserializer);
        let mut var_capacitySats = <Option<u64>>::sse_decode(deserializer);
        return crate::api::graph::ChannelInfo {
            node_one: var_nodeOne,
            one_to_two: var_oneToTwo,
            node_two: var_nodeTwo,
            two_to_one: var_twoToOne,
            capacity_sats: var_capacitySats,
        };
    }
}

impl SseDecode for crate::api::graph::ChannelUpdateInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lastUpdate = <u32>::sse_decode(deserializer);
        let mut var_enabled = <bool>::sse_decode(deserializer);
        let mut var_cltvExpiryDelta = <u16>::sse_decode(deserializer);
        let mut var_htlcMinimumMsat = <u64>::sse_decode(deserializer);
        let mut var_htlcMaximumMsat = <u64>::sse_decode(deserializer);
        let mut var_fees = <crate::api::graph::RoutingFees>::sse_decode(deserializer);
        return crate::api::graph::ChannelUpdateInfo {
            last_update: var_lastUpdate,
            enabled: var_enabled,
            cltv_expiry_delta: var_cltvExpiryDelta,
            htlc_minimum_msat: var_htlcMinimumMsat,
            htlc_maximum_msat: var_htlcMaximumMsat,
            fees: var_fees,
        };
    }
}

impl SseDecode for crate::api::types::ClosureReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_peerMsg = <String>::sse_decode(deserializer);
                return crate::api::types::ClosureReason::CounterpartyForceClosed {
                    peer_msg: var_peerMsg,
                };
            }
            1 => {
                return crate::api::types::ClosureReason::HolderForceClosed;
            }
            2 => {
                return crate::api::types::ClosureReason::LegacyCooperativeClosure;
            }
            3 => {
                return crate::api::types::ClosureReason::CounterpartyInitiatedCooperativeClosure;
            }
            4 => {
                return crate::api::types::ClosureReason::LocallyInitiatedCooperativeClosure;
            }
            5 => {
                return crate::api::types::ClosureReason::CommitmentTxConfirmed;
            }
            6 => {
                return crate::api::types::ClosureReason::FundingTimedOut;
            }
            7 => {
                let mut var_err = <String>::sse_decode(deserializer);
                return crate::api::types::ClosureReason::ProcessingError { err: var_err };
            }
            8 => {
                return crate::api::types::ClosureReason::DisconnectedPeer;
            }
            9 => {
                return crate::api::types::ClosureReason::OutdatedChannelManager;
            }
            10 => {
                return crate::api::types::ClosureReason::CounterpartyCoopClosedUnfundedChannel;
            }
            11 => {
                return crate::api::types::ClosureReason::FundingBatchClosure;
            }
            12 => {
                return crate::api::types::ClosureReason::HTLCsTimedOut;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_storageDirPath = <String>::sse_decode(deserializer);
        let mut var_logDirPath = <Option<String>>::sse_decode(deserializer);
        let mut var_network = <crate::api::types::Network>::sse_decode(deserializer);
        let mut var_listeningAddresses =
            <Option<Vec<crate::api::types::SocketAddress>>>::sse_decode(deserializer);
        let mut var_defaultCltvExpiryDelta = <u32>::sse_decode(deserializer);
        let mut var_onchainWalletSyncIntervalSecs = <u64>::sse_decode(deserializer);
        let mut var_walletSyncIntervalSecs = <u64>::sse_decode(deserializer);
        let mut var_feeRateCacheUpdateIntervalSecs = <u64>::sse_decode(deserializer);
        let mut var_trustedPeers0Conf =
            <Vec<crate::api::types::PublicKey>>::sse_decode(deserializer);
        let mut var_probingLiquidityLimitMultiplier = <u64>::sse_decode(deserializer);
        let mut var_logLevel = <crate::api::types::LogLevel>::sse_decode(deserializer);
        let mut var_anchorChannelsConfig =
            <Option<crate::api::types::AnchorChannelsConfig>>::sse_decode(deserializer);
        return crate::api::types::Config {
            storage_dir_path: var_storageDirPath,
            log_dir_path: var_logDirPath,
            network: var_network,
            listening_addresses: var_listeningAddresses,
            default_cltv_expiry_delta: var_defaultCltvExpiryDelta,
            onchain_wallet_sync_interval_secs: var_onchainWalletSyncIntervalSecs,
            wallet_sync_interval_secs: var_walletSyncIntervalSecs,
            fee_rate_cache_update_interval_secs: var_feeRateCacheUpdateIntervalSecs,
            trusted_peers_0conf: var_trustedPeers0Conf,
            probing_liquidity_limit_multiplier: var_probingLiquidityLimitMultiplier,
            log_level: var_logLevel,
            anchor_channels_config: var_anchorChannelsConfig,
        };
    }
}

impl SseDecode for crate::utils::error::DecodeError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::utils::error::DecodeError::UnknownVersion;
            }
            1 => {
                return crate::utils::error::DecodeError::UnknownRequiredFeature;
            }
            2 => {
                return crate::utils::error::DecodeError::InvalidValue;
            }
            3 => {
                return crate::utils::error::DecodeError::ShortRead;
            }
            4 => {
                return crate::utils::error::DecodeError::BadLengthDescriptor;
            }
            5 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::utils::error::DecodeError::Io(var_field0);
            }
            6 => {
                return crate::utils::error::DecodeError::UnsupportedCompression;
            }
            7 => {
                return crate::utils::error::DecodeError::DangerousValue;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::EntropySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::types::EntropySourceConfig::SeedFile(var_field0);
            }
            1 => {
                let mut var_field0 = <[u8; 64]>::sse_decode(deserializer);
                return crate::api::types::EntropySourceConfig::SeedBytes(var_field0);
            }
            2 => {
                let mut var_mnemonic = <crate::api::builder::LdkMnemonic>::sse_decode(deserializer);
                let mut var_passphrase = <Option<String>>::sse_decode(deserializer);
                return crate::api::types::EntropySourceConfig::Bip39Mnemonic {
                    mnemonic: var_mnemonic,
                    passphrase: var_passphrase,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Event {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_paymentId = <crate::api::types::PaymentId>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_claimableAmountMsat = <u64>::sse_decode(deserializer);
                let mut var_claimDeadline = <Option<u32>>::sse_decode(deserializer);
                return crate::api::types::Event::PaymentClaimable {
                    payment_id: var_paymentId,
                    payment_hash: var_paymentHash,
                    claimable_amount_msat: var_claimableAmountMsat,
                    claim_deadline: var_claimDeadline,
                };
            }
            1 => {
                let mut var_paymentId =
                    <Option<crate::api::types::PaymentId>>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_feePaidMsat = <Option<u64>>::sse_decode(deserializer);
                return crate::api::types::Event::PaymentSuccessful {
                    payment_id: var_paymentId,
                    payment_hash: var_paymentHash,
                    fee_paid_msat: var_feePaidMsat,
                };
            }
            2 => {
                let mut var_paymentId =
                    <Option<crate::api::types::PaymentId>>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_reason =
                    <Option<crate::api::types::PaymentFailureReason>>::sse_decode(deserializer);
                return crate::api::types::Event::PaymentFailed {
                    payment_id: var_paymentId,
                    payment_hash: var_paymentHash,
                    reason: var_reason,
                };
            }
            3 => {
                let mut var_paymentId =
                    <Option<crate::api::types::PaymentId>>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_amountMsat = <u64>::sse_decode(deserializer);
                return crate::api::types::Event::PaymentReceived {
                    payment_id: var_paymentId,
                    payment_hash: var_paymentHash,
                    amount_msat: var_amountMsat,
                };
            }
            4 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_userChannelId =
                    <crate::api::types::UserChannelId>::sse_decode(deserializer);
                let mut var_formerTemporaryChannelId =
                    <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_fundingTxo = <crate::api::types::OutPoint>::sse_decode(deserializer);
                return crate::api::types::Event::ChannelPending {
                    channel_id: var_channelId,
                    user_channel_id: var_userChannelId,
                    former_temporary_channel_id: var_formerTemporaryChannelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    funding_txo: var_fundingTxo,
                };
            }
            5 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_userChannelId =
                    <crate::api::types::UserChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <Option<crate::api::types::PublicKey>>::sse_decode(deserializer);
                return crate::api::types::Event::ChannelReady {
                    channel_id: var_channelId,
                    user_channel_id: var_userChannelId,
                    counterparty_node_id: var_counterpartyNodeId,
                };
            }
            6 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_userChannelId =
                    <crate::api::types::UserChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <Option<crate::api::types::PublicKey>>::sse_decode(deserializer);
                let mut var_reason =
                    <Option<crate::api::types::ClosureReason>>::sse_decode(deserializer);
                return crate::api::types::Event::ChannelClosed {
                    channel_id: var_channelId,
                    user_channel_id: var_userChannelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    reason: var_reason,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::GossipSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::types::GossipSourceConfig::P2PNetwork;
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::types::GossipSourceConfig::RapidGossipSync(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::bolt11::LdkBolt11Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr =
            <RustOpaqueNom<ldk_node::payment::Bolt11Payment>>::sse_decode(deserializer);
        return crate::api::bolt11::LdkBolt11Payment { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::bolt12::LdkBolt12Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr =
            <RustOpaqueNom<Arc<ldk_node::payment::Bolt12Payment>>>::sse_decode(deserializer);
        return crate::api::bolt12::LdkBolt12Payment { ptr: var_ptr };
    }
}

impl SseDecode for crate::utils::error::LdkBuilderError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::utils::error::LdkBuilderError::SocketAddressParseError,
            1 => crate::utils::error::LdkBuilderError::InvalidSeedBytes,
            2 => crate::utils::error::LdkBuilderError::InvalidSeedFile,
            3 => crate::utils::error::LdkBuilderError::InvalidSystemTime,
            4 => crate::utils::error::LdkBuilderError::InvalidChannelMonitor,
            5 => crate::utils::error::LdkBuilderError::InvalidListeningAddress,
            6 => crate::utils::error::LdkBuilderError::ReadFailed,
            7 => crate::utils::error::LdkBuilderError::WriteFailed,
            8 => crate::utils::error::LdkBuilderError::StoragePathAccessFailed,
            9 => crate::utils::error::LdkBuilderError::KVStoreSetupFailed,
            10 => crate::utils::error::LdkBuilderError::WalletSetupFailed,
            11 => crate::utils::error::LdkBuilderError::LoggerSetupFailed,
            12 => crate::utils::error::LdkBuilderError::InvalidPublicKey,
            _ => unreachable!("Invalid variant for LdkBuilderError: {}", inner),
        };
    }
}

impl SseDecode for crate::api::builder::LdkMnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_seedPhrase = <String>::sse_decode(deserializer);
        return crate::api::builder::LdkMnemonic {
            seed_phrase: var_seedPhrase,
        };
    }
}

impl SseDecode for crate::api::graph::LdkNetworkGraph {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr = <RustOpaqueNom<ldk_node::graph::NetworkGraph>>::sse_decode(deserializer);
        return crate::api::graph::LdkNetworkGraph { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::node::LdkNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr = <RustOpaqueNom<Node>>::sse_decode(deserializer);
        return crate::api::node::LdkNode { ptr: var_ptr };
    }
}

impl SseDecode for crate::utils::error::LdkNodeError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::utils::error::LdkNodeError::InvalidTxid;
            }
            1 => {
                return crate::utils::error::LdkNodeError::AlreadyRunning;
            }
            2 => {
                return crate::utils::error::LdkNodeError::NotRunning;
            }
            3 => {
                return crate::utils::error::LdkNodeError::OnchainTxCreationFailed;
            }
            4 => {
                return crate::utils::error::LdkNodeError::ConnectionFailed;
            }
            5 => {
                return crate::utils::error::LdkNodeError::InvoiceCreationFailed;
            }
            6 => {
                return crate::utils::error::LdkNodeError::PaymentSendingFailed;
            }
            7 => {
                return crate::utils::error::LdkNodeError::ProbeSendingFailed;
            }
            8 => {
                return crate::utils::error::LdkNodeError::ChannelCreationFailed;
            }
            9 => {
                return crate::utils::error::LdkNodeError::ChannelClosingFailed;
            }
            10 => {
                return crate::utils::error::LdkNodeError::ChannelConfigUpdateFailed;
            }
            11 => {
                return crate::utils::error::LdkNodeError::PersistenceFailed;
            }
            12 => {
                return crate::utils::error::LdkNodeError::WalletOperationFailed;
            }
            13 => {
                return crate::utils::error::LdkNodeError::OnchainTxSigningFailed;
            }
            14 => {
                return crate::utils::error::LdkNodeError::MessageSigningFailed;
            }
            15 => {
                return crate::utils::error::LdkNodeError::TxSyncFailed;
            }
            16 => {
                return crate::utils::error::LdkNodeError::GossipUpdateFailed;
            }
            17 => {
                return crate::utils::error::LdkNodeError::InvalidAddress;
            }
            18 => {
                return crate::utils::error::LdkNodeError::InvalidSocketAddress;
            }
            19 => {
                return crate::utils::error::LdkNodeError::InvalidPublicKey;
            }
            20 => {
                return crate::utils::error::LdkNodeError::InvalidSecretKey;
            }
            21 => {
                return crate::utils::error::LdkNodeError::InvalidPaymentHash;
            }
            22 => {
                return crate::utils::error::LdkNodeError::InvalidPaymentPreimage;
            }
            23 => {
                return crate::utils::error::LdkNodeError::InvalidPaymentSecret;
            }
            24 => {
                return crate::utils::error::LdkNodeError::InvalidAmount;
            }
            25 => {
                return crate::utils::error::LdkNodeError::InvalidInvoice;
            }
            26 => {
                return crate::utils::error::LdkNodeError::InvalidChannelId;
            }
            27 => {
                return crate::utils::error::LdkNodeError::InvalidNetwork;
            }
            28 => {
                return crate::utils::error::LdkNodeError::DuplicatePayment;
            }
            29 => {
                return crate::utils::error::LdkNodeError::InsufficientFunds;
            }
            30 => {
                return crate::utils::error::LdkNodeError::FeerateEstimationUpdateFailed;
            }
            31 => {
                return crate::utils::error::LdkNodeError::LiquidityRequestFailed;
            }
            32 => {
                return crate::utils::error::LdkNodeError::LiquiditySourceUnavailable;
            }
            33 => {
                return crate::utils::error::LdkNodeError::LiquidityFeeTooHigh;
            }
            34 => {
                return crate::utils::error::LdkNodeError::InvalidPaymentId;
            }
            35 => {
                let mut var_field0 = <crate::utils::error::DecodeError>::sse_decode(deserializer);
                return crate::utils::error::LdkNodeError::Decode(var_field0);
            }
            36 => {
                let mut var_field0 =
                    <crate::utils::error::Bolt12ParseError>::sse_decode(deserializer);
                return crate::utils::error::LdkNodeError::Bolt12Parse(var_field0);
            }
            37 => {
                return crate::utils::error::LdkNodeError::InvoiceRequestCreationFailed;
            }
            38 => {
                return crate::utils::error::LdkNodeError::OfferCreationFailed;
            }
            39 => {
                return crate::utils::error::LdkNodeError::RefundCreationFailed;
            }
            40 => {
                return crate::utils::error::LdkNodeError::FeerateEstimationUpdateTimeout;
            }
            41 => {
                return crate::utils::error::LdkNodeError::WalletOperationTimeout;
            }
            42 => {
                return crate::utils::error::LdkNodeError::TxSyncTimeout;
            }
            43 => {
                return crate::utils::error::LdkNodeError::GossipUpdateTimeout;
            }
            44 => {
                return crate::utils::error::LdkNodeError::InvalidOfferId;
            }
            45 => {
                return crate::utils::error::LdkNodeError::InvalidNodeId;
            }
            46 => {
                return crate::utils::error::LdkNodeError::InvalidOffer;
            }
            47 => {
                return crate::utils::error::LdkNodeError::InvalidRefund;
            }
            48 => {
                return crate::utils::error::LdkNodeError::UnsupportedCurrency;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::on_chain::LdkOnChainPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr =
            <RustOpaqueNom<ldk_node::payment::OnchainPayment>>::sse_decode(deserializer);
        return crate::api::on_chain::LdkOnChainPayment { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::spontaneous::LdkSpontaneousPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr =
            <RustOpaqueNom<ldk_node::payment::SpontaneousPayment>>::sse_decode(deserializer);
        return crate::api::spontaneous::LdkSpontaneousPayment { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::types::LightningBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::ClaimableOnChannelClose {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            1 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_confirmationHeight = <u32>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::ClaimableAwaitingConfirmations {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    confirmation_height: var_confirmationHeight,
                };
            }
            2 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_timeoutHeight = <u32>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_paymentPreimage =
                    <crate::api::types::PaymentPreimage>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::ContentiousClaimable {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    timeout_height: var_timeoutHeight,
                    payment_hash: var_paymentHash,
                    payment_preimage: var_paymentPreimage,
                };
            }
            3 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_claimableHeight = <u32>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::MaybeTimeoutClaimableHTLC {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    claimable_height: var_claimableHeight,
                    payment_hash: var_paymentHash,
                };
            }
            4 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_expiryHeight = <u32>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::MaybePreimageClaimableHTLC {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    expiry_height: var_expiryHeight,
                    payment_hash: var_paymentHash,
                };
            }
            5 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::CounterpartyRevokedOutputClaimable {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::LiquiditySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lsps2Service = <(
            crate::api::types::SocketAddress,
            crate::api::types::PublicKey,
            Option<String>,
        )>::sse_decode(deserializer);
        return crate::api::types::LiquiditySourceConfig {
            lsps2_service: var_lsps2Service,
        };
    }
}

impl SseDecode for Vec<crate::api::types::ChannelDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::ChannelDetails>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::LightningBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::LightningBalance>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::graph::NodeId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::graph::NodeId>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::PaymentDetails>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::PeerDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::PeerDetails>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::PendingSweepBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::PendingSweepBalance>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::PublicKey>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::SocketAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::SocketAddress>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::types::LogLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::LogLevel::Gossip,
            1 => crate::api::types::LogLevel::Trace,
            2 => crate::api::types::LogLevel::Debug,
            3 => crate::api::types::LogLevel::Info,
            4 => crate::api::types::LogLevel::Warn,
            5 => crate::api::types::LogLevel::Error,
            _ => unreachable!("Invalid variant for LogLevel: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::LSPFeeLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_maxTotalOpeningFeeMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_maxProportionalOpeningFeePpmMsat = <Option<u64>>::sse_decode(deserializer);
        return crate::api::types::LSPFeeLimits {
            max_total_opening_fee_msat: var_maxTotalOpeningFeeMsat,
            max_proportional_opening_fee_ppm_msat: var_maxProportionalOpeningFeePpmMsat,
        };
    }
}

impl SseDecode for crate::api::types::MaxDustHTLCExposure {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <u64>::sse_decode(deserializer);
                return crate::api::types::MaxDustHTLCExposure::FixedLimitMsat(var_field0);
            }
            1 => {
                let mut var_field0 = <u64>::sse_decode(deserializer);
                return crate::api::types::MaxDustHTLCExposure::FeeRateMultiplier(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::Network::Bitcoin,
            1 => crate::api::types::Network::Testnet,
            2 => crate::api::types::Network::Signet,
            3 => crate::api::types::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", inner),
        };
    }
}

impl SseDecode for crate::api::graph::NodeAnnouncementInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lastUpdate = <u32>::sse_decode(deserializer);
        let mut var_alias = <String>::sse_decode(deserializer);
        let mut var_addresses = <Vec<crate::api::types::SocketAddress>>::sse_decode(deserializer);
        return crate::api::graph::NodeAnnouncementInfo {
            last_update: var_lastUpdate,
            alias: var_alias,
            addresses: var_addresses,
        };
    }
}

impl SseDecode for crate::api::graph::NodeId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_compressed = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::graph::NodeId {
            compressed: var_compressed,
        };
    }
}

impl SseDecode for crate::api::graph::NodeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_channels = <Vec<u64>>::sse_decode(deserializer);
        let mut var_announcementInfo =
            <Option<crate::api::graph::NodeAnnouncementInfo>>::sse_decode(deserializer);
        return crate::api::graph::NodeInfo {
            channels: var_channels,
            announcement_info: var_announcementInfo,
        };
    }
}

impl SseDecode for crate::api::types::NodeStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_isRunning = <bool>::sse_decode(deserializer);
        let mut var_isListening = <bool>::sse_decode(deserializer);
        let mut var_currentBestBlock = <crate::api::types::BestBlock>::sse_decode(deserializer);
        let mut var_latestWalletSyncTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestOnchainWalletSyncTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestFeeRateCacheUpdateTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestRgsSnapshotTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestNodeAnnouncementBroadcastTimestamp =
            <Option<u64>>::sse_decode(deserializer);
        return crate::api::types::NodeStatus {
            is_running: var_isRunning,
            is_listening: var_isListening,
            current_best_block: var_currentBestBlock,
            latest_wallet_sync_timestamp: var_latestWalletSyncTimestamp,
            latest_onchain_wallet_sync_timestamp: var_latestOnchainWalletSyncTimestamp,
            latest_fee_rate_cache_update_timestamp: var_latestFeeRateCacheUpdateTimestamp,
            latest_rgs_snapshot_timestamp: var_latestRgsSnapshotTimestamp,
            latest_node_announcement_broadcast_timestamp:
                var_latestNodeAnnouncementBroadcastTimestamp,
        };
    }
}

impl SseDecode for crate::api::bolt12::Offer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_s = <String>::sse_decode(deserializer);
        return crate::api::bolt12::Offer { s: var_s };
    }
}

impl SseDecode for crate::api::types::OfferId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::OfferId(var_field0);
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::AnchorChannelsConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::AnchorChannelsConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::ChainDataSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::ChainDataSourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::ChannelConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::ChannelConfig>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::ChannelId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::ChannelId>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::graph::ChannelInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::graph::ChannelInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::graph::ChannelUpdateInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::graph::ChannelUpdateInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::ClosureReason> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::ClosureReason>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::EntropySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::EntropySourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::Event> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::Event>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::GossipSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::GossipSourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::LiquiditySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::LiquiditySourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::MaxDustHTLCExposure> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::MaxDustHTLCExposure>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::graph::NodeAnnouncementInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::graph::NodeAnnouncementInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::graph::NodeInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::graph::NodeInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::OutPoint>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentDetails>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentFailureReason> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentFailureReason>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentHash> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentHash>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentId>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentPreimage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentPreimage>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentSecret> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentSecret>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PublicKey>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u16>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::api::types::SocketAddress>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::api::types::SocketAddress>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::types::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <crate::api::types::Txid>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        return crate::api::types::OutPoint {
            txid: var_txid,
            vout: var_vout,
        };
    }
}

impl SseDecode for crate::api::types::PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <crate::api::types::PaymentId>::sse_decode(deserializer);
        let mut var_kind = <crate::api::types::PaymentKind>::sse_decode(deserializer);
        let mut var_amountMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_direction = <crate::api::types::PaymentDirection>::sse_decode(deserializer);
        let mut var_status = <crate::api::types::PaymentStatus>::sse_decode(deserializer);
        let mut var_latestUpdateTimestamp = <u64>::sse_decode(deserializer);
        return crate::api::types::PaymentDetails {
            id: var_id,
            kind: var_kind,
            amount_msat: var_amountMsat,
            direction: var_direction,
            status: var_status,
            latest_update_timestamp: var_latestUpdateTimestamp,
        };
    }
}

impl SseDecode for crate::api::types::PaymentDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::PaymentDirection::Inbound,
            1 => crate::api::types::PaymentDirection::Outbound,
            _ => unreachable!("Invalid variant for PaymentDirection: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::PaymentFailureReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::PaymentFailureReason::RecipientRejected,
            1 => crate::api::types::PaymentFailureReason::UserAbandoned,
            2 => crate::api::types::PaymentFailureReason::RetriesExhausted,
            3 => crate::api::types::PaymentFailureReason::PaymentExpired,
            4 => crate::api::types::PaymentFailureReason::RouteNotFound,
            5 => crate::api::types::PaymentFailureReason::UnexpectedError,
            _ => unreachable!("Invalid variant for PaymentFailureReason: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::PaymentHash {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::PaymentHash { data: var_data };
    }
}

impl SseDecode for crate::api::types::PaymentId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::PaymentId(var_field0);
    }
}

impl SseDecode for crate::api::types::PaymentKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::types::PaymentKind::Onchain;
            }
            1 => {
                let mut var_hash = <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_preimage =
                    <Option<crate::api::types::PaymentPreimage>>::sse_decode(deserializer);
                let mut var_secret =
                    <Option<crate::api::types::PaymentSecret>>::sse_decode(deserializer);
                return crate::api::types::PaymentKind::Bolt11 {
                    hash: var_hash,
                    preimage: var_preimage,
                    secret: var_secret,
                };
            }
            2 => {
                let mut var_hash = <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_preimage =
                    <Option<crate::api::types::PaymentPreimage>>::sse_decode(deserializer);
                let mut var_secret =
                    <Option<crate::api::types::PaymentSecret>>::sse_decode(deserializer);
                let mut var_lspFeeLimits =
                    <crate::api::types::LSPFeeLimits>::sse_decode(deserializer);
                return crate::api::types::PaymentKind::Bolt11Jit {
                    hash: var_hash,
                    preimage: var_preimage,
                    secret: var_secret,
                    lsp_fee_limits: var_lspFeeLimits,
                };
            }
            3 => {
                let mut var_hash = <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_preimage =
                    <Option<crate::api::types::PaymentPreimage>>::sse_decode(deserializer);
                return crate::api::types::PaymentKind::Spontaneous {
                    hash: var_hash,
                    preimage: var_preimage,
                };
            }
            4 => {
                let mut var_hash =
                    <Option<crate::api::types::PaymentHash>>::sse_decode(deserializer);
                let mut var_preimage =
                    <Option<crate::api::types::PaymentPreimage>>::sse_decode(deserializer);
                let mut var_secret =
                    <Option<crate::api::types::PaymentSecret>>::sse_decode(deserializer);
                let mut var_offerId = <crate::api::types::OfferId>::sse_decode(deserializer);
                return crate::api::types::PaymentKind::Bolt12Offer {
                    hash: var_hash,
                    preimage: var_preimage,
                    secret: var_secret,
                    offer_id: var_offerId,
                };
            }
            5 => {
                let mut var_hash =
                    <Option<crate::api::types::PaymentHash>>::sse_decode(deserializer);
                let mut var_preimage =
                    <Option<crate::api::types::PaymentPreimage>>::sse_decode(deserializer);
                let mut var_secret =
                    <Option<crate::api::types::PaymentSecret>>::sse_decode(deserializer);
                return crate::api::types::PaymentKind::Bolt12Refund {
                    hash: var_hash,
                    preimage: var_preimage,
                    secret: var_secret,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::PaymentPreimage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::PaymentPreimage { data: var_data };
    }
}

impl SseDecode for crate::api::types::PaymentSecret {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::PaymentSecret { data: var_data };
    }
}

impl SseDecode for crate::api::types::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::PaymentStatus::Pending,
            1 => crate::api::types::PaymentStatus::Succeeded,
            2 => crate::api::types::PaymentStatus::Failed,
            _ => unreachable!("Invalid variant for PaymentStatus: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::PeerDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nodeId = <crate::api::types::PublicKey>::sse_decode(deserializer);
        let mut var_address = <crate::api::types::SocketAddress>::sse_decode(deserializer);
        let mut var_isConnected = <bool>::sse_decode(deserializer);
        return crate::api::types::PeerDetails {
            node_id: var_nodeId,
            address: var_address,
            is_connected: var_isConnected,
        };
    }
}

impl SseDecode for crate::api::types::PendingSweepBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_channelId =
                    <Option<crate::api::types::ChannelId>>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return crate::api::types::PendingSweepBalance::PendingBroadcast {
                    channel_id: var_channelId,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            1 => {
                let mut var_channelId =
                    <Option<crate::api::types::ChannelId>>::sse_decode(deserializer);
                let mut var_latestBroadcastHeight = <u32>::sse_decode(deserializer);
                let mut var_latestSpendingTxid =
                    <crate::api::types::Txid>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return crate::api::types::PendingSweepBalance::BroadcastAwaitingConfirmation {
                    channel_id: var_channelId,
                    latest_broadcast_height: var_latestBroadcastHeight,
                    latest_spending_txid: var_latestSpendingTxid,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            2 => {
                let mut var_channelId =
                    <Option<crate::api::types::ChannelId>>::sse_decode(deserializer);
                let mut var_latestSpendingTxid =
                    <crate::api::types::Txid>::sse_decode(deserializer);
                let mut var_confirmationHash = <String>::sse_decode(deserializer);
                let mut var_confirmationHeight = <u32>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return crate::api::types::PendingSweepBalance::AwaitingThresholdConfirmations {
                    channel_id: var_channelId,
                    latest_spending_txid: var_latestSpendingTxid,
                    confirmation_hash: var_confirmationHash,
                    confirmation_height: var_confirmationHeight,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::PublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hex = <String>::sse_decode(deserializer);
        return crate::api::types::PublicKey { hex: var_hex };
    }
}

impl SseDecode
    for (
        crate::api::types::SocketAddress,
        crate::api::types::PublicKey,
        Option<String>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <crate::api::types::SocketAddress>::sse_decode(deserializer);
        let mut var_field1 = <crate::api::types::PublicKey>::sse_decode(deserializer);
        let mut var_field2 = <Option<String>>::sse_decode(deserializer);
        return (var_field0, var_field1, var_field2);
    }
}

impl SseDecode for crate::api::bolt12::Refund {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_s = <String>::sse_decode(deserializer);
        return crate::api::bolt12::Refund { s: var_s };
    }
}

impl SseDecode for crate::api::graph::RoutingFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_baseMsat = <u32>::sse_decode(deserializer);
        let mut var_proportionalMillionths = <u32>::sse_decode(deserializer);
        return crate::api::graph::RoutingFees {
            base_msat: var_baseMsat,
            proportional_millionths: var_proportionalMillionths,
        };
    }
}

impl SseDecode for crate::api::types::SocketAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_addr = <[u8; 4]>::sse_decode(deserializer);
                let mut var_port = <u16>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::TcpIpV4 {
                    addr: var_addr,
                    port: var_port,
                };
            }
            1 => {
                let mut var_addr = <[u8; 16]>::sse_decode(deserializer);
                let mut var_port = <u16>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::TcpIpV6 {
                    addr: var_addr,
                    port: var_port,
                };
            }
            2 => {
                let mut var_field0 = <[u8; 12]>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::OnionV2(var_field0);
            }
            3 => {
                let mut var_ed25519Pubkey = <[u8; 32]>::sse_decode(deserializer);
                let mut var_checksum = <u16>::sse_decode(deserializer);
                let mut var_version = <u8>::sse_decode(deserializer);
                let mut var_port = <u16>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::OnionV3 {
                    ed25519_pubkey: var_ed25519Pubkey,
                    checksum: var_checksum,
                    version: var_version,
                    port: var_port,
                };
            }
            4 => {
                let mut var_addr = <String>::sse_decode(deserializer);
                let mut var_port = <u16>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::Hostname {
                    addr: var_addr,
                    port: var_port,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Txid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hash = <String>::sse_decode(deserializer);
        return crate::api::types::Txid { hash: var_hash };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for [u8; 12] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 16] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 32] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 4] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 64] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::api::types::UserChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::types::UserChannelId { data: var_data };
    }
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<NodeBuilder> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<NodeBuilder> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<NodeBuilder>> for NodeBuilder {
    fn into_into_dart(self) -> FrbWrapper<NodeBuilder> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Address {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.s.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Address {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Address> for crate::api::types::Address {
    fn into_into_dart(self) -> crate::api::types::Address {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::AnchorChannelsConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.trusted_peers_no_reserve.into_into_dart().into_dart(),
            self.per_channel_reserve_sats.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::AnchorChannelsConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::AnchorChannelsConfig>
    for crate::api::types::AnchorChannelsConfig
{
    fn into_into_dart(self) -> crate::api::types::AnchorChannelsConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BalanceDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.total_onchain_balance_sats.into_into_dart().into_dart(),
            self.spendable_onchain_balance_sats
                .into_into_dart()
                .into_dart(),
            self.total_lightning_balance_sats
                .into_into_dart()
                .into_dart(),
            self.lightning_balances.into_into_dart().into_dart(),
            self.pending_balances_from_channel_closures
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::BalanceDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BalanceDetails>
    for crate::api::types::BalanceDetails
{
    fn into_into_dart(self) -> crate::api::types::BalanceDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BestBlock {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.block_hash.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::BestBlock {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BestBlock>
    for crate::api::types::BestBlock
{
    fn into_into_dart(self) -> crate::api::types::BestBlock {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bolt11::Bolt11Invoice {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.signed_raw_invoice.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bolt11::Bolt11Invoice
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bolt11::Bolt11Invoice>
    for crate::api::bolt11::Bolt11Invoice
{
    fn into_into_dart(self) -> crate::api::bolt11::Bolt11Invoice {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bolt12::Bolt12Invoice {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bolt12::Bolt12Invoice
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bolt12::Bolt12Invoice>
    for crate::api::bolt12::Bolt12Invoice
{
    fn into_into_dart(self) -> crate::api::bolt12::Bolt12Invoice {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::utils::error::Bolt12ParseError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::utils::error::Bolt12ParseError::InvalidContinuation => {
                [0.into_dart()].into_dart()
            }
            crate::utils::error::Bolt12ParseError::InvalidBech32Hrp => [1.into_dart()].into_dart(),
            crate::utils::error::Bolt12ParseError::Bech32(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::utils::error::Bolt12ParseError::Decode(field0) => {
                [3.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::utils::error::Bolt12ParseError::InvalidSemantics(field0) => {
                [4.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::utils::error::Bolt12ParseError::InvalidSignature(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::utils::error::Bolt12ParseError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::utils::error::Bolt12ParseError>
    for crate::utils::error::Bolt12ParseError
{
    fn into_into_dart(self) -> crate::utils::error::Bolt12ParseError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChainDataSourceConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::ChainDataSourceConfig::Esplora(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChainDataSourceConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChainDataSourceConfig>
    for crate::api::types::ChainDataSourceConfig
{
    fn into_into_dart(self) -> crate::api::types::ChainDataSourceConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChannelConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.forwarding_fee_proportional_millionths
                .into_into_dart()
                .into_dart(),
            self.forwarding_fee_base_msat.into_into_dart().into_dart(),
            self.cltv_expiry_delta.into_into_dart().into_dart(),
            self.max_dust_htlc_exposure.into_into_dart().into_dart(),
            self.force_close_avoidance_max_fee_satoshis
                .into_into_dart()
                .into_dart(),
            self.accept_underpaying_htlcs.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChannelConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChannelConfig>
    for crate::api::types::ChannelConfig
{
    fn into_into_dart(self) -> crate::api::types::ChannelConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChannelDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.channel_id.into_into_dart().into_dart(),
            self.counterparty_node_id.into_into_dart().into_dart(),
            self.funding_txo.into_into_dart().into_dart(),
            self.channel_value_sats.into_into_dart().into_dart(),
            self.unspendable_punishment_reserve
                .into_into_dart()
                .into_dart(),
            self.user_channel_id.into_into_dart().into_dart(),
            self.feerate_sat_per_1000_weight
                .into_into_dart()
                .into_dart(),
            self.outbound_capacity_msat.into_into_dart().into_dart(),
            self.inbound_capacity_msat.into_into_dart().into_dart(),
            self.confirmations_required.into_into_dart().into_dart(),
            self.confirmations.into_into_dart().into_dart(),
            self.is_outbound.into_into_dart().into_dart(),
            self.is_channel_ready.into_into_dart().into_dart(),
            self.is_usable.into_into_dart().into_dart(),
            self.is_public.into_into_dart().into_dart(),
            self.cltv_expiry_delta.into_into_dart().into_dart(),
            self.counterparty_unspendable_punishment_reserve
                .into_into_dart()
                .into_dart(),
            self.counterparty_outbound_htlc_minimum_msat
                .into_into_dart()
                .into_dart(),
            self.counterparty_outbound_htlc_maximum_msat
                .into_into_dart()
                .into_dart(),
            self.counterparty_forwarding_info_fee_base_msat
                .into_into_dart()
                .into_dart(),
            self.counterparty_forwarding_info_fee_proportional_millionths
                .into_into_dart()
                .into_dart(),
            self.counterparty_forwarding_info_cltv_expiry_delta
                .into_into_dart()
                .into_dart(),
            self.next_outbound_htlc_limit_msat
                .into_into_dart()
                .into_dart(),
            self.next_outbound_htlc_minimum_msat
                .into_into_dart()
                .into_dart(),
            self.force_close_spend_delay.into_into_dart().into_dart(),
            self.inbound_htlc_minimum_msat.into_into_dart().into_dart(),
            self.inbound_htlc_maximum_msat.into_into_dart().into_dart(),
            self.config.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChannelDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChannelDetails>
    for crate::api::types::ChannelDetails
{
    fn into_into_dart(self) -> crate::api::types::ChannelDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChannelId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::ChannelId {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChannelId>
    for crate::api::types::ChannelId
{
    fn into_into_dart(self) -> crate::api::types::ChannelId {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::graph::ChannelInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.node_one.into_into_dart().into_dart(),
            self.one_to_two.into_into_dart().into_dart(),
            self.node_two.into_into_dart().into_dart(),
            self.two_to_one.into_into_dart().into_dart(),
            self.capacity_sats.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::graph::ChannelInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::graph::ChannelInfo>
    for crate::api::graph::ChannelInfo
{
    fn into_into_dart(self) -> crate::api::graph::ChannelInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::graph::ChannelUpdateInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.last_update.into_into_dart().into_dart(),
            self.enabled.into_into_dart().into_dart(),
            self.cltv_expiry_delta.into_into_dart().into_dart(),
            self.htlc_minimum_msat.into_into_dart().into_dart(),
            self.htlc_maximum_msat.into_into_dart().into_dart(),
            self.fees.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::graph::ChannelUpdateInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::graph::ChannelUpdateInfo>
    for crate::api::graph::ChannelUpdateInfo
{
    fn into_into_dart(self) -> crate::api::graph::ChannelUpdateInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ClosureReason {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::ClosureReason::CounterpartyForceClosed { peer_msg } => {
                [0.into_dart(), peer_msg.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::HolderForceClosed => [1.into_dart()].into_dart(),
            crate::api::types::ClosureReason::LegacyCooperativeClosure => {
                [2.into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::CounterpartyInitiatedCooperativeClosure => {
                [3.into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::LocallyInitiatedCooperativeClosure => {
                [4.into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::CommitmentTxConfirmed => [5.into_dart()].into_dart(),
            crate::api::types::ClosureReason::FundingTimedOut => [6.into_dart()].into_dart(),
            crate::api::types::ClosureReason::ProcessingError { err } => {
                [7.into_dart(), err.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::DisconnectedPeer => [8.into_dart()].into_dart(),
            crate::api::types::ClosureReason::OutdatedChannelManager => [9.into_dart()].into_dart(),
            crate::api::types::ClosureReason::CounterpartyCoopClosedUnfundedChannel => {
                [10.into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::FundingBatchClosure => [11.into_dart()].into_dart(),
            crate::api::types::ClosureReason::HTLCsTimedOut => [12.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ClosureReason
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ClosureReason>
    for crate::api::types::ClosureReason
{
    fn into_into_dart(self) -> crate::api::types::ClosureReason {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Config {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.storage_dir_path.into_into_dart().into_dart(),
            self.log_dir_path.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.listening_addresses.into_into_dart().into_dart(),
            self.default_cltv_expiry_delta.into_into_dart().into_dart(),
            self.onchain_wallet_sync_interval_secs
                .into_into_dart()
                .into_dart(),
            self.wallet_sync_interval_secs.into_into_dart().into_dart(),
            self.fee_rate_cache_update_interval_secs
                .into_into_dart()
                .into_dart(),
            self.trusted_peers_0conf.into_into_dart().into_dart(),
            self.probing_liquidity_limit_multiplier
                .into_into_dart()
                .into_dart(),
            self.log_level.into_into_dart().into_dart(),
            self.anchor_channels_config.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Config {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Config> for crate::api::types::Config {
    fn into_into_dart(self) -> crate::api::types::Config {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::utils::error::DecodeError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::utils::error::DecodeError::UnknownVersion => [0.into_dart()].into_dart(),
            crate::utils::error::DecodeError::UnknownRequiredFeature => [1.into_dart()].into_dart(),
            crate::utils::error::DecodeError::InvalidValue => [2.into_dart()].into_dart(),
            crate::utils::error::DecodeError::ShortRead => [3.into_dart()].into_dart(),
            crate::utils::error::DecodeError::BadLengthDescriptor => [4.into_dart()].into_dart(),
            crate::utils::error::DecodeError::Io(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::utils::error::DecodeError::UnsupportedCompression => [6.into_dart()].into_dart(),
            crate::utils::error::DecodeError::DangerousValue => [7.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::utils::error::DecodeError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::utils::error::DecodeError>
    for crate::utils::error::DecodeError
{
    fn into_into_dart(self) -> crate::utils::error::DecodeError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::EntropySourceConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::EntropySourceConfig::SeedFile(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::EntropySourceConfig::SeedBytes(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::EntropySourceConfig::Bip39Mnemonic {
                mnemonic,
                passphrase,
            } => [
                2.into_dart(),
                mnemonic.into_into_dart().into_dart(),
                passphrase.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::EntropySourceConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::EntropySourceConfig>
    for crate::api::types::EntropySourceConfig
{
    fn into_into_dart(self) -> crate::api::types::EntropySourceConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Event {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::Event::PaymentClaimable {
                payment_id,
                payment_hash,
                claimable_amount_msat,
                claim_deadline,
            } => [
                0.into_dart(),
                payment_id.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                claimable_amount_msat.into_into_dart().into_dart(),
                claim_deadline.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::PaymentSuccessful {
                payment_id,
                payment_hash,
                fee_paid_msat,
            } => [
                1.into_dart(),
                payment_id.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                fee_paid_msat.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::PaymentFailed {
                payment_id,
                payment_hash,
                reason,
            } => [
                2.into_dart(),
                payment_id.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                reason.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::PaymentReceived {
                payment_id,
                payment_hash,
                amount_msat,
            } => [
                3.into_dart(),
                payment_id.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                amount_msat.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::ChannelPending {
                channel_id,
                user_channel_id,
                former_temporary_channel_id,
                counterparty_node_id,
                funding_txo,
            } => [
                4.into_dart(),
                channel_id.into_into_dart().into_dart(),
                user_channel_id.into_into_dart().into_dart(),
                former_temporary_channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                funding_txo.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::ChannelReady {
                channel_id,
                user_channel_id,
                counterparty_node_id,
            } => [
                5.into_dart(),
                channel_id.into_into_dart().into_dart(),
                user_channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::ChannelClosed {
                channel_id,
                user_channel_id,
                counterparty_node_id,
                reason,
            } => [
                6.into_dart(),
                channel_id.into_into_dart().into_dart(),
                user_channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                reason.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Event {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Event> for crate::api::types::Event {
    fn into_into_dart(self) -> crate::api::types::Event {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::GossipSourceConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::GossipSourceConfig::P2PNetwork => [0.into_dart()].into_dart(),
            crate::api::types::GossipSourceConfig::RapidGossipSync(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::GossipSourceConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::GossipSourceConfig>
    for crate::api::types::GossipSourceConfig
{
    fn into_into_dart(self) -> crate::api::types::GossipSourceConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bolt11::LdkBolt11Payment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bolt11::LdkBolt11Payment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bolt11::LdkBolt11Payment>
    for crate::api::bolt11::LdkBolt11Payment
{
    fn into_into_dart(self) -> crate::api::bolt11::LdkBolt11Payment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bolt12::LdkBolt12Payment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bolt12::LdkBolt12Payment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bolt12::LdkBolt12Payment>
    for crate::api::bolt12::LdkBolt12Payment
{
    fn into_into_dart(self) -> crate::api::bolt12::LdkBolt12Payment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::utils::error::LdkBuilderError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::SocketAddressParseError => 0.into_dart(),
            Self::InvalidSeedBytes => 1.into_dart(),
            Self::InvalidSeedFile => 2.into_dart(),
            Self::InvalidSystemTime => 3.into_dart(),
            Self::InvalidChannelMonitor => 4.into_dart(),
            Self::InvalidListeningAddress => 5.into_dart(),
            Self::ReadFailed => 6.into_dart(),
            Self::WriteFailed => 7.into_dart(),
            Self::StoragePathAccessFailed => 8.into_dart(),
            Self::KVStoreSetupFailed => 9.into_dart(),
            Self::WalletSetupFailed => 10.into_dart(),
            Self::LoggerSetupFailed => 11.into_dart(),
            Self::InvalidPublicKey => 12.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::utils::error::LdkBuilderError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::utils::error::LdkBuilderError>
    for crate::utils::error::LdkBuilderError
{
    fn into_into_dart(self) -> crate::utils::error::LdkBuilderError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::builder::LdkMnemonic {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.seed_phrase.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::builder::LdkMnemonic
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::builder::LdkMnemonic>
    for crate::api::builder::LdkMnemonic
{
    fn into_into_dart(self) -> crate::api::builder::LdkMnemonic {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::graph::LdkNetworkGraph {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::graph::LdkNetworkGraph
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::graph::LdkNetworkGraph>
    for crate::api::graph::LdkNetworkGraph
{
    fn into_into_dart(self) -> crate::api::graph::LdkNetworkGraph {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::node::LdkNode {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::node::LdkNode {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::node::LdkNode> for crate::api::node::LdkNode {
    fn into_into_dart(self) -> crate::api::node::LdkNode {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::utils::error::LdkNodeError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::utils::error::LdkNodeError::InvalidTxid => [0.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::AlreadyRunning => [1.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::NotRunning => [2.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::OnchainTxCreationFailed => {
                [3.into_dart()].into_dart()
            }
            crate::utils::error::LdkNodeError::ConnectionFailed => [4.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InvoiceCreationFailed => [5.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::PaymentSendingFailed => [6.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::ProbeSendingFailed => [7.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::ChannelCreationFailed => [8.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::ChannelClosingFailed => [9.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::ChannelConfigUpdateFailed => {
                [10.into_dart()].into_dart()
            }
            crate::utils::error::LdkNodeError::PersistenceFailed => [11.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::WalletOperationFailed => {
                [12.into_dart()].into_dart()
            }
            crate::utils::error::LdkNodeError::OnchainTxSigningFailed => {
                [13.into_dart()].into_dart()
            }
            crate::utils::error::LdkNodeError::MessageSigningFailed => [14.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::TxSyncFailed => [15.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::GossipUpdateFailed => [16.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InvalidAddress => [17.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InvalidSocketAddress => [18.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InvalidPublicKey => [19.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InvalidSecretKey => [20.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InvalidPaymentHash => [21.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InvalidPaymentPreimage => {
                [22.into_dart()].into_dart()
            }
            crate::utils::error::LdkNodeError::InvalidPaymentSecret => [23.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InvalidAmount => [24.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InvalidInvoice => [25.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InvalidChannelId => [26.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InvalidNetwork => [27.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::DuplicatePayment => [28.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InsufficientFunds => [29.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::FeerateEstimationUpdateFailed => {
                [30.into_dart()].into_dart()
            }
            crate::utils::error::LdkNodeError::LiquidityRequestFailed => {
                [31.into_dart()].into_dart()
            }
            crate::utils::error::LdkNodeError::LiquiditySourceUnavailable => {
                [32.into_dart()].into_dart()
            }
            crate::utils::error::LdkNodeError::LiquidityFeeTooHigh => [33.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InvalidPaymentId => [34.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::Decode(field0) => {
                [35.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::utils::error::LdkNodeError::Bolt12Parse(field0) => {
                [36.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::utils::error::LdkNodeError::InvoiceRequestCreationFailed => {
                [37.into_dart()].into_dart()
            }
            crate::utils::error::LdkNodeError::OfferCreationFailed => [38.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::RefundCreationFailed => [39.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::FeerateEstimationUpdateTimeout => {
                [40.into_dart()].into_dart()
            }
            crate::utils::error::LdkNodeError::WalletOperationTimeout => {
                [41.into_dart()].into_dart()
            }
            crate::utils::error::LdkNodeError::TxSyncTimeout => [42.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::GossipUpdateTimeout => [43.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InvalidOfferId => [44.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InvalidNodeId => [45.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InvalidOffer => [46.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::InvalidRefund => [47.into_dart()].into_dart(),
            crate::utils::error::LdkNodeError::UnsupportedCurrency => [48.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::utils::error::LdkNodeError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::utils::error::LdkNodeError>
    for crate::utils::error::LdkNodeError
{
    fn into_into_dart(self) -> crate::utils::error::LdkNodeError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::on_chain::LdkOnChainPayment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::on_chain::LdkOnChainPayment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::on_chain::LdkOnChainPayment>
    for crate::api::on_chain::LdkOnChainPayment
{
    fn into_into_dart(self) -> crate::api::on_chain::LdkOnChainPayment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::spontaneous::LdkSpontaneousPayment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::spontaneous::LdkSpontaneousPayment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::spontaneous::LdkSpontaneousPayment>
    for crate::api::spontaneous::LdkSpontaneousPayment
{
    fn into_into_dart(self) -> crate::api::spontaneous::LdkSpontaneousPayment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LightningBalance {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::LightningBalance::ClaimableOnChannelClose {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
            } => [
                0.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::LightningBalance::ClaimableAwaitingConfirmations {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                confirmation_height,
            } => [
                1.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                confirmation_height.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::LightningBalance::ContentiousClaimable {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                timeout_height,
                payment_hash,
                payment_preimage,
            } => [
                2.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                timeout_height.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                payment_preimage.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::LightningBalance::MaybeTimeoutClaimableHTLC {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                claimable_height,
                payment_hash,
            } => [
                3.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                claimable_height.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::LightningBalance::MaybePreimageClaimableHTLC {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                expiry_height,
                payment_hash,
            } => [
                4.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                expiry_height.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::LightningBalance::CounterpartyRevokedOutputClaimable {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
            } => [
                5.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::LightningBalance
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LightningBalance>
    for crate::api::types::LightningBalance
{
    fn into_into_dart(self) -> crate::api::types::LightningBalance {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LiquiditySourceConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.lsps2_service.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::LiquiditySourceConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LiquiditySourceConfig>
    for crate::api::types::LiquiditySourceConfig
{
    fn into_into_dart(self) -> crate::api::types::LiquiditySourceConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LogLevel {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Gossip => 0.into_dart(),
            Self::Trace => 1.into_dart(),
            Self::Debug => 2.into_dart(),
            Self::Info => 3.into_dart(),
            Self::Warn => 4.into_dart(),
            Self::Error => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::LogLevel {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LogLevel>
    for crate::api::types::LogLevel
{
    fn into_into_dart(self) -> crate::api::types::LogLevel {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LSPFeeLimits {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.max_total_opening_fee_msat.into_into_dart().into_dart(),
            self.max_proportional_opening_fee_ppm_msat
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::LSPFeeLimits
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LSPFeeLimits>
    for crate::api::types::LSPFeeLimits
{
    fn into_into_dart(self) -> crate::api::types::LSPFeeLimits {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::MaxDustHTLCExposure {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::MaxDustHTLCExposure::FixedLimitMsat(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::MaxDustHTLCExposure::FeeRateMultiplier(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::MaxDustHTLCExposure
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::MaxDustHTLCExposure>
    for crate::api::types::MaxDustHTLCExposure
{
    fn into_into_dart(self) -> crate::api::types::MaxDustHTLCExposure {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Network {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Bitcoin => 0.into_dart(),
            Self::Testnet => 1.into_dart(),
            Self::Signet => 2.into_dart(),
            Self::Regtest => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Network {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Network> for crate::api::types::Network {
    fn into_into_dart(self) -> crate::api::types::Network {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::graph::NodeAnnouncementInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.last_update.into_into_dart().into_dart(),
            self.alias.into_into_dart().into_dart(),
            self.addresses.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::graph::NodeAnnouncementInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::graph::NodeAnnouncementInfo>
    for crate::api::graph::NodeAnnouncementInfo
{
    fn into_into_dart(self) -> crate::api::graph::NodeAnnouncementInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::graph::NodeId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.compressed.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::graph::NodeId {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::graph::NodeId> for crate::api::graph::NodeId {
    fn into_into_dart(self) -> crate::api::graph::NodeId {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::graph::NodeInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.channels.into_into_dart().into_dart(),
            self.announcement_info.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::graph::NodeInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::graph::NodeInfo>
    for crate::api::graph::NodeInfo
{
    fn into_into_dart(self) -> crate::api::graph::NodeInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::NodeStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.is_running.into_into_dart().into_dart(),
            self.is_listening.into_into_dart().into_dart(),
            self.current_best_block.into_into_dart().into_dart(),
            self.latest_wallet_sync_timestamp
                .into_into_dart()
                .into_dart(),
            self.latest_onchain_wallet_sync_timestamp
                .into_into_dart()
                .into_dart(),
            self.latest_fee_rate_cache_update_timestamp
                .into_into_dart()
                .into_dart(),
            self.latest_rgs_snapshot_timestamp
                .into_into_dart()
                .into_dart(),
            self.latest_node_announcement_broadcast_timestamp
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::NodeStatus {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::NodeStatus>
    for crate::api::types::NodeStatus
{
    fn into_into_dart(self) -> crate::api::types::NodeStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bolt12::Offer {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.s.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::bolt12::Offer {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bolt12::Offer> for crate::api::bolt12::Offer {
    fn into_into_dart(self) -> crate::api::bolt12::Offer {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::OfferId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::OfferId {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::OfferId> for crate::api::types::OfferId {
    fn into_into_dart(self) -> crate::api::types::OfferId {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::OutPoint {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.vout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::OutPoint {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::OutPoint>
    for crate::api::types::OutPoint
{
    fn into_into_dart(self) -> crate::api::types::OutPoint {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.amount_msat.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.latest_update_timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentDetails>
    for crate::api::types::PaymentDetails
{
    fn into_into_dart(self) -> crate::api::types::PaymentDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentDirection {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Inbound => 0.into_dart(),
            Self::Outbound => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentDirection
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentDirection>
    for crate::api::types::PaymentDirection
{
    fn into_into_dart(self) -> crate::api::types::PaymentDirection {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentFailureReason {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::RecipientRejected => 0.into_dart(),
            Self::UserAbandoned => 1.into_dart(),
            Self::RetriesExhausted => 2.into_dart(),
            Self::PaymentExpired => 3.into_dart(),
            Self::RouteNotFound => 4.into_dart(),
            Self::UnexpectedError => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentFailureReason
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentFailureReason>
    for crate::api::types::PaymentFailureReason
{
    fn into_into_dart(self) -> crate::api::types::PaymentFailureReason {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentHash {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentHash
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentHash>
    for crate::api::types::PaymentHash
{
    fn into_into_dart(self) -> crate::api::types::PaymentHash {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::PaymentId {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentId>
    for crate::api::types::PaymentId
{
    fn into_into_dart(self) -> crate::api::types::PaymentId {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentKind {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::PaymentKind::Onchain => [0.into_dart()].into_dart(),
            crate::api::types::PaymentKind::Bolt11 {
                hash,
                preimage,
                secret,
            } => [
                1.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
                secret.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::PaymentKind::Bolt11Jit {
                hash,
                preimage,
                secret,
                lsp_fee_limits,
            } => [
                2.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
                secret.into_into_dart().into_dart(),
                lsp_fee_limits.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::PaymentKind::Spontaneous { hash, preimage } => [
                3.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::PaymentKind::Bolt12Offer {
                hash,
                preimage,
                secret,
                offer_id,
            } => [
                4.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
                secret.into_into_dart().into_dart(),
                offer_id.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::PaymentKind::Bolt12Refund {
                hash,
                preimage,
                secret,
            } => [
                5.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
                secret.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentKind
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentKind>
    for crate::api::types::PaymentKind
{
    fn into_into_dart(self) -> crate::api::types::PaymentKind {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentPreimage {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentPreimage
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentPreimage>
    for crate::api::types::PaymentPreimage
{
    fn into_into_dart(self) -> crate::api::types::PaymentPreimage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentSecret {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentSecret
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentSecret>
    for crate::api::types::PaymentSecret
{
    fn into_into_dart(self) -> crate::api::types::PaymentSecret {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Pending => 0.into_dart(),
            Self::Succeeded => 1.into_dart(),
            Self::Failed => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentStatus
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentStatus>
    for crate::api::types::PaymentStatus
{
    fn into_into_dart(self) -> crate::api::types::PaymentStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PeerDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.node_id.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
            self.is_connected.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PeerDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PeerDetails>
    for crate::api::types::PeerDetails
{
    fn into_into_dart(self) -> crate::api::types::PeerDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PendingSweepBalance {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::PendingSweepBalance::PendingBroadcast {
                channel_id,
                amount_satoshis,
            } => [
                0.into_dart(),
                channel_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::PendingSweepBalance::BroadcastAwaitingConfirmation {
                channel_id,
                latest_broadcast_height,
                latest_spending_txid,
                amount_satoshis,
            } => [
                1.into_dart(),
                channel_id.into_into_dart().into_dart(),
                latest_broadcast_height.into_into_dart().into_dart(),
                latest_spending_txid.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::PendingSweepBalance::AwaitingThresholdConfirmations {
                channel_id,
                latest_spending_txid,
                confirmation_hash,
                confirmation_height,
                amount_satoshis,
            } => [
                2.into_dart(),
                channel_id.into_into_dart().into_dart(),
                latest_spending_txid.into_into_dart().into_dart(),
                confirmation_hash.into_into_dart().into_dart(),
                confirmation_height.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PendingSweepBalance
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PendingSweepBalance>
    for crate::api::types::PendingSweepBalance
{
    fn into_into_dart(self) -> crate::api::types::PendingSweepBalance {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PublicKey {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.hex.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::PublicKey {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PublicKey>
    for crate::api::types::PublicKey
{
    fn into_into_dart(self) -> crate::api::types::PublicKey {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bolt12::Refund {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.s.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::bolt12::Refund {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bolt12::Refund> for crate::api::bolt12::Refund {
    fn into_into_dart(self) -> crate::api::bolt12::Refund {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::graph::RoutingFees {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.base_msat.into_into_dart().into_dart(),
            self.proportional_millionths.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::graph::RoutingFees
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::graph::RoutingFees>
    for crate::api::graph::RoutingFees
{
    fn into_into_dart(self) -> crate::api::graph::RoutingFees {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SocketAddress {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::SocketAddress::TcpIpV4 { addr, port } => [
                0.into_dart(),
                addr.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::SocketAddress::TcpIpV6 { addr, port } => [
                1.into_dart(),
                addr.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::SocketAddress::OnionV2(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::SocketAddress::OnionV3 {
                ed25519_pubkey,
                checksum,
                version,
                port,
            } => [
                3.into_dart(),
                ed25519_pubkey.into_into_dart().into_dart(),
                checksum.into_into_dart().into_dart(),
                version.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::SocketAddress::Hostname { addr, port } => [
                4.into_dart(),
                addr.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::SocketAddress
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SocketAddress>
    for crate::api::types::SocketAddress
{
    fn into_into_dart(self) -> crate::api::types::SocketAddress {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Txid {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.hash.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Txid {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Txid> for crate::api::types::Txid {
    fn into_into_dart(self) -> crate::api::types::Txid {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::UserChannelId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::UserChannelId
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::UserChannelId>
    for crate::api::types::UserChannelId
{
    fn into_into_dart(self) -> crate::api::types::UserChannelId {
        self
    }
}

impl SseEncode for NodeBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NodeBuilder>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for RustOpaqueNom<Arc<ldk_node::payment::Bolt12Payment>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<Node> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NodeBuilder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<ldk_node::Builder> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<ldk_node::graph::NetworkGraph> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<ldk_node::payment::Bolt11Payment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<ldk_node::payment::OnchainPayment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<ldk_node::payment::SpontaneousPayment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::types::Address {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.s, serializer);
    }
}

impl SseEncode for crate::api::types::AnchorChannelsConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::api::types::PublicKey>>::sse_encode(self.trusted_peers_no_reserve, serializer);
        <u64>::sse_encode(self.per_channel_reserve_sats, serializer);
    }
}

impl SseEncode for crate::api::types::BalanceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.total_onchain_balance_sats, serializer);
        <u64>::sse_encode(self.spendable_onchain_balance_sats, serializer);
        <u64>::sse_encode(self.total_lightning_balance_sats, serializer);
        <Vec<crate::api::types::LightningBalance>>::sse_encode(self.lightning_balances, serializer);
        <Vec<crate::api::types::PendingSweepBalance>>::sse_encode(
            self.pending_balances_from_channel_closures,
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::BestBlock {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.block_hash, serializer);
        <u32>::sse_encode(self.height, serializer);
    }
}

impl SseEncode for crate::api::bolt11::Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.signed_raw_invoice, serializer);
    }
}

impl SseEncode for crate::api::bolt12::Bolt12Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::utils::error::Bolt12ParseError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::utils::error::Bolt12ParseError::InvalidContinuation => {
                <i32>::sse_encode(0, serializer);
            }
            crate::utils::error::Bolt12ParseError::InvalidBech32Hrp => {
                <i32>::sse_encode(1, serializer);
            }
            crate::utils::error::Bolt12ParseError::Bech32(field0) => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::utils::error::Bolt12ParseError::Decode(field0) => {
                <i32>::sse_encode(3, serializer);
                <crate::utils::error::DecodeError>::sse_encode(field0, serializer);
            }
            crate::utils::error::Bolt12ParseError::InvalidSemantics(field0) => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::utils::error::Bolt12ParseError::InvalidSignature(field0) => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::types::ChainDataSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::ChainDataSourceConfig::Esplora(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::ChannelConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.forwarding_fee_proportional_millionths, serializer);
        <u32>::sse_encode(self.forwarding_fee_base_msat, serializer);
        <u16>::sse_encode(self.cltv_expiry_delta, serializer);
        <Option<crate::api::types::MaxDustHTLCExposure>>::sse_encode(
            self.max_dust_htlc_exposure,
            serializer,
        );
        <u64>::sse_encode(self.force_close_avoidance_max_fee_satoshis, serializer);
        <bool>::sse_encode(self.accept_underpaying_htlcs, serializer);
    }
}

impl SseEncode for crate::api::types::ChannelDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::ChannelId>::sse_encode(self.channel_id, serializer);
        <crate::api::types::PublicKey>::sse_encode(self.counterparty_node_id, serializer);
        <Option<crate::api::types::OutPoint>>::sse_encode(self.funding_txo, serializer);
        <u64>::sse_encode(self.channel_value_sats, serializer);
        <Option<u64>>::sse_encode(self.unspendable_punishment_reserve, serializer);
        <crate::api::types::UserChannelId>::sse_encode(self.user_channel_id, serializer);
        <u32>::sse_encode(self.feerate_sat_per_1000_weight, serializer);
        <u64>::sse_encode(self.outbound_capacity_msat, serializer);
        <u64>::sse_encode(self.inbound_capacity_msat, serializer);
        <Option<u32>>::sse_encode(self.confirmations_required, serializer);
        <Option<u32>>::sse_encode(self.confirmations, serializer);
        <bool>::sse_encode(self.is_outbound, serializer);
        <bool>::sse_encode(self.is_channel_ready, serializer);
        <bool>::sse_encode(self.is_usable, serializer);
        <bool>::sse_encode(self.is_public, serializer);
        <Option<u16>>::sse_encode(self.cltv_expiry_delta, serializer);
        <u64>::sse_encode(self.counterparty_unspendable_punishment_reserve, serializer);
        <Option<u64>>::sse_encode(self.counterparty_outbound_htlc_minimum_msat, serializer);
        <Option<u64>>::sse_encode(self.counterparty_outbound_htlc_maximum_msat, serializer);
        <Option<u32>>::sse_encode(self.counterparty_forwarding_info_fee_base_msat, serializer);
        <Option<u32>>::sse_encode(
            self.counterparty_forwarding_info_fee_proportional_millionths,
            serializer,
        );
        <Option<u16>>::sse_encode(
            self.counterparty_forwarding_info_cltv_expiry_delta,
            serializer,
        );
        <u64>::sse_encode(self.next_outbound_htlc_limit_msat, serializer);
        <u64>::sse_encode(self.next_outbound_htlc_minimum_msat, serializer);
        <Option<u16>>::sse_encode(self.force_close_spend_delay, serializer);
        <u64>::sse_encode(self.inbound_htlc_minimum_msat, serializer);
        <Option<u64>>::sse_encode(self.inbound_htlc_maximum_msat, serializer);
        <crate::api::types::ChannelConfig>::sse_encode(self.config, serializer);
    }
}

impl SseEncode for crate::api::types::ChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::api::graph::ChannelInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::graph::NodeId>::sse_encode(self.node_one, serializer);
        <Option<crate::api::graph::ChannelUpdateInfo>>::sse_encode(self.one_to_two, serializer);
        <crate::api::graph::NodeId>::sse_encode(self.node_two, serializer);
        <Option<crate::api::graph::ChannelUpdateInfo>>::sse_encode(self.two_to_one, serializer);
        <Option<u64>>::sse_encode(self.capacity_sats, serializer);
    }
}

impl SseEncode for crate::api::graph::ChannelUpdateInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.last_update, serializer);
        <bool>::sse_encode(self.enabled, serializer);
        <u16>::sse_encode(self.cltv_expiry_delta, serializer);
        <u64>::sse_encode(self.htlc_minimum_msat, serializer);
        <u64>::sse_encode(self.htlc_maximum_msat, serializer);
        <crate::api::graph::RoutingFees>::sse_encode(self.fees, serializer);
    }
}

impl SseEncode for crate::api::types::ClosureReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::ClosureReason::CounterpartyForceClosed { peer_msg } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(peer_msg, serializer);
            }
            crate::api::types::ClosureReason::HolderForceClosed => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::types::ClosureReason::LegacyCooperativeClosure => {
                <i32>::sse_encode(2, serializer);
            }
            crate::api::types::ClosureReason::CounterpartyInitiatedCooperativeClosure => {
                <i32>::sse_encode(3, serializer);
            }
            crate::api::types::ClosureReason::LocallyInitiatedCooperativeClosure => {
                <i32>::sse_encode(4, serializer);
            }
            crate::api::types::ClosureReason::CommitmentTxConfirmed => {
                <i32>::sse_encode(5, serializer);
            }
            crate::api::types::ClosureReason::FundingTimedOut => {
                <i32>::sse_encode(6, serializer);
            }
            crate::api::types::ClosureReason::ProcessingError { err } => {
                <i32>::sse_encode(7, serializer);
                <String>::sse_encode(err, serializer);
            }
            crate::api::types::ClosureReason::DisconnectedPeer => {
                <i32>::sse_encode(8, serializer);
            }
            crate::api::types::ClosureReason::OutdatedChannelManager => {
                <i32>::sse_encode(9, serializer);
            }
            crate::api::types::ClosureReason::CounterpartyCoopClosedUnfundedChannel => {
                <i32>::sse_encode(10, serializer);
            }
            crate::api::types::ClosureReason::FundingBatchClosure => {
                <i32>::sse_encode(11, serializer);
            }
            crate::api::types::ClosureReason::HTLCsTimedOut => {
                <i32>::sse_encode(12, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.storage_dir_path, serializer);
        <Option<String>>::sse_encode(self.log_dir_path, serializer);
        <crate::api::types::Network>::sse_encode(self.network, serializer);
        <Option<Vec<crate::api::types::SocketAddress>>>::sse_encode(
            self.listening_addresses,
            serializer,
        );
        <u32>::sse_encode(self.default_cltv_expiry_delta, serializer);
        <u64>::sse_encode(self.onchain_wallet_sync_interval_secs, serializer);
        <u64>::sse_encode(self.wallet_sync_interval_secs, serializer);
        <u64>::sse_encode(self.fee_rate_cache_update_interval_secs, serializer);
        <Vec<crate::api::types::PublicKey>>::sse_encode(self.trusted_peers_0conf, serializer);
        <u64>::sse_encode(self.probing_liquidity_limit_multiplier, serializer);
        <crate::api::types::LogLevel>::sse_encode(self.log_level, serializer);
        <Option<crate::api::types::AnchorChannelsConfig>>::sse_encode(
            self.anchor_channels_config,
            serializer,
        );
    }
}

impl SseEncode for crate::utils::error::DecodeError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::utils::error::DecodeError::UnknownVersion => {
                <i32>::sse_encode(0, serializer);
            }
            crate::utils::error::DecodeError::UnknownRequiredFeature => {
                <i32>::sse_encode(1, serializer);
            }
            crate::utils::error::DecodeError::InvalidValue => {
                <i32>::sse_encode(2, serializer);
            }
            crate::utils::error::DecodeError::ShortRead => {
                <i32>::sse_encode(3, serializer);
            }
            crate::utils::error::DecodeError::BadLengthDescriptor => {
                <i32>::sse_encode(4, serializer);
            }
            crate::utils::error::DecodeError::Io(field0) => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::utils::error::DecodeError::UnsupportedCompression => {
                <i32>::sse_encode(6, serializer);
            }
            crate::utils::error::DecodeError::DangerousValue => {
                <i32>::sse_encode(7, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::EntropySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::EntropySourceConfig::SeedFile(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::types::EntropySourceConfig::SeedBytes(field0) => {
                <i32>::sse_encode(1, serializer);
                <[u8; 64]>::sse_encode(field0, serializer);
            }
            crate::api::types::EntropySourceConfig::Bip39Mnemonic {
                mnemonic,
                passphrase,
            } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::builder::LdkMnemonic>::sse_encode(mnemonic, serializer);
                <Option<String>>::sse_encode(passphrase, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::Event {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::Event::PaymentClaimable {
                payment_id,
                payment_hash,
                claimable_amount_msat,
                claim_deadline,
            } => {
                <i32>::sse_encode(0, serializer);
                <crate::api::types::PaymentId>::sse_encode(payment_id, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
                <u64>::sse_encode(claimable_amount_msat, serializer);
                <Option<u32>>::sse_encode(claim_deadline, serializer);
            }
            crate::api::types::Event::PaymentSuccessful {
                payment_id,
                payment_hash,
                fee_paid_msat,
            } => {
                <i32>::sse_encode(1, serializer);
                <Option<crate::api::types::PaymentId>>::sse_encode(payment_id, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
                <Option<u64>>::sse_encode(fee_paid_msat, serializer);
            }
            crate::api::types::Event::PaymentFailed {
                payment_id,
                payment_hash,
                reason,
            } => {
                <i32>::sse_encode(2, serializer);
                <Option<crate::api::types::PaymentId>>::sse_encode(payment_id, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
                <Option<crate::api::types::PaymentFailureReason>>::sse_encode(reason, serializer);
            }
            crate::api::types::Event::PaymentReceived {
                payment_id,
                payment_hash,
                amount_msat,
            } => {
                <i32>::sse_encode(3, serializer);
                <Option<crate::api::types::PaymentId>>::sse_encode(payment_id, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
                <u64>::sse_encode(amount_msat, serializer);
            }
            crate::api::types::Event::ChannelPending {
                channel_id,
                user_channel_id,
                former_temporary_channel_id,
                counterparty_node_id,
                funding_txo,
            } => {
                <i32>::sse_encode(4, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::UserChannelId>::sse_encode(user_channel_id, serializer);
                <crate::api::types::ChannelId>::sse_encode(former_temporary_channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <crate::api::types::OutPoint>::sse_encode(funding_txo, serializer);
            }
            crate::api::types::Event::ChannelReady {
                channel_id,
                user_channel_id,
                counterparty_node_id,
            } => {
                <i32>::sse_encode(5, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::UserChannelId>::sse_encode(user_channel_id, serializer);
                <Option<crate::api::types::PublicKey>>::sse_encode(
                    counterparty_node_id,
                    serializer,
                );
            }
            crate::api::types::Event::ChannelClosed {
                channel_id,
                user_channel_id,
                counterparty_node_id,
                reason,
            } => {
                <i32>::sse_encode(6, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::UserChannelId>::sse_encode(user_channel_id, serializer);
                <Option<crate::api::types::PublicKey>>::sse_encode(
                    counterparty_node_id,
                    serializer,
                );
                <Option<crate::api::types::ClosureReason>>::sse_encode(reason, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::GossipSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::GossipSourceConfig::P2PNetwork => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::types::GossipSourceConfig::RapidGossipSync(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::bolt11::LdkBolt11Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<ldk_node::payment::Bolt11Payment>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::bolt12::LdkBolt12Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<Arc<ldk_node::payment::Bolt12Payment>>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::utils::error::LdkBuilderError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::utils::error::LdkBuilderError::SocketAddressParseError => 0,
                crate::utils::error::LdkBuilderError::InvalidSeedBytes => 1,
                crate::utils::error::LdkBuilderError::InvalidSeedFile => 2,
                crate::utils::error::LdkBuilderError::InvalidSystemTime => 3,
                crate::utils::error::LdkBuilderError::InvalidChannelMonitor => 4,
                crate::utils::error::LdkBuilderError::InvalidListeningAddress => 5,
                crate::utils::error::LdkBuilderError::ReadFailed => 6,
                crate::utils::error::LdkBuilderError::WriteFailed => 7,
                crate::utils::error::LdkBuilderError::StoragePathAccessFailed => 8,
                crate::utils::error::LdkBuilderError::KVStoreSetupFailed => 9,
                crate::utils::error::LdkBuilderError::WalletSetupFailed => 10,
                crate::utils::error::LdkBuilderError::LoggerSetupFailed => 11,
                crate::utils::error::LdkBuilderError::InvalidPublicKey => 12,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::builder::LdkMnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.seed_phrase, serializer);
    }
}

impl SseEncode for crate::api::graph::LdkNetworkGraph {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<ldk_node::graph::NetworkGraph>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::node::LdkNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<Node>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::utils::error::LdkNodeError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::utils::error::LdkNodeError::InvalidTxid => {
                <i32>::sse_encode(0, serializer);
            }
            crate::utils::error::LdkNodeError::AlreadyRunning => {
                <i32>::sse_encode(1, serializer);
            }
            crate::utils::error::LdkNodeError::NotRunning => {
                <i32>::sse_encode(2, serializer);
            }
            crate::utils::error::LdkNodeError::OnchainTxCreationFailed => {
                <i32>::sse_encode(3, serializer);
            }
            crate::utils::error::LdkNodeError::ConnectionFailed => {
                <i32>::sse_encode(4, serializer);
            }
            crate::utils::error::LdkNodeError::InvoiceCreationFailed => {
                <i32>::sse_encode(5, serializer);
            }
            crate::utils::error::LdkNodeError::PaymentSendingFailed => {
                <i32>::sse_encode(6, serializer);
            }
            crate::utils::error::LdkNodeError::ProbeSendingFailed => {
                <i32>::sse_encode(7, serializer);
            }
            crate::utils::error::LdkNodeError::ChannelCreationFailed => {
                <i32>::sse_encode(8, serializer);
            }
            crate::utils::error::LdkNodeError::ChannelClosingFailed => {
                <i32>::sse_encode(9, serializer);
            }
            crate::utils::error::LdkNodeError::ChannelConfigUpdateFailed => {
                <i32>::sse_encode(10, serializer);
            }
            crate::utils::error::LdkNodeError::PersistenceFailed => {
                <i32>::sse_encode(11, serializer);
            }
            crate::utils::error::LdkNodeError::WalletOperationFailed => {
                <i32>::sse_encode(12, serializer);
            }
            crate::utils::error::LdkNodeError::OnchainTxSigningFailed => {
                <i32>::sse_encode(13, serializer);
            }
            crate::utils::error::LdkNodeError::MessageSigningFailed => {
                <i32>::sse_encode(14, serializer);
            }
            crate::utils::error::LdkNodeError::TxSyncFailed => {
                <i32>::sse_encode(15, serializer);
            }
            crate::utils::error::LdkNodeError::GossipUpdateFailed => {
                <i32>::sse_encode(16, serializer);
            }
            crate::utils::error::LdkNodeError::InvalidAddress => {
                <i32>::sse_encode(17, serializer);
            }
            crate::utils::error::LdkNodeError::InvalidSocketAddress => {
                <i32>::sse_encode(18, serializer);
            }
            crate::utils::error::LdkNodeError::InvalidPublicKey => {
                <i32>::sse_encode(19, serializer);
            }
            crate::utils::error::LdkNodeError::InvalidSecretKey => {
                <i32>::sse_encode(20, serializer);
            }
            crate::utils::error::LdkNodeError::InvalidPaymentHash => {
                <i32>::sse_encode(21, serializer);
            }
            crate::utils::error::LdkNodeError::InvalidPaymentPreimage => {
                <i32>::sse_encode(22, serializer);
            }
            crate::utils::error::LdkNodeError::InvalidPaymentSecret => {
                <i32>::sse_encode(23, serializer);
            }
            crate::utils::error::LdkNodeError::InvalidAmount => {
                <i32>::sse_encode(24, serializer);
            }
            crate::utils::error::LdkNodeError::InvalidInvoice => {
                <i32>::sse_encode(25, serializer);
            }
            crate::utils::error::LdkNodeError::InvalidChannelId => {
                <i32>::sse_encode(26, serializer);
            }
            crate::utils::error::LdkNodeError::InvalidNetwork => {
                <i32>::sse_encode(27, serializer);
            }
            crate::utils::error::LdkNodeError::DuplicatePayment => {
                <i32>::sse_encode(28, serializer);
            }
            crate::utils::error::LdkNodeError::InsufficientFunds => {
                <i32>::sse_encode(29, serializer);
            }
            crate::utils::error::LdkNodeError::FeerateEstimationUpdateFailed => {
                <i32>::sse_encode(30, serializer);
            }
            crate::utils::error::LdkNodeError::LiquidityRequestFailed => {
                <i32>::sse_encode(31, serializer);
            }
            crate::utils::error::LdkNodeError::LiquiditySourceUnavailable => {
                <i32>::sse_encode(32, serializer);
            }
            crate::utils::error::LdkNodeError::LiquidityFeeTooHigh => {
                <i32>::sse_encode(33, serializer);
            }
            crate::utils::error::LdkNodeError::InvalidPaymentId => {
                <i32>::sse_encode(34, serializer);
            }
            crate::utils::error::LdkNodeError::Decode(field0) => {
                <i32>::sse_encode(35, serializer);
                <crate::utils::error::DecodeError>::sse_encode(field0, serializer);
            }
            crate::utils::error::LdkNodeError::Bolt12Parse(field0) => {
                <i32>::sse_encode(36, serializer);
                <crate::utils::error::Bolt12ParseError>::sse_encode(field0, serializer);
            }
            crate::utils::error::LdkNodeError::InvoiceRequestCreationFailed => {
                <i32>::sse_encode(37, serializer);
            }
            crate::utils::error::LdkNodeError::OfferCreationFailed => {
                <i32>::sse_encode(38, serializer);
            }
            crate::utils::error::LdkNodeError::RefundCreationFailed => {
                <i32>::sse_encode(39, serializer);
            }
            crate::utils::error::LdkNodeError::FeerateEstimationUpdateTimeout => {
                <i32>::sse_encode(40, serializer);
            }
            crate::utils::error::LdkNodeError::WalletOperationTimeout => {
                <i32>::sse_encode(41, serializer);
            }
            crate::utils::error::LdkNodeError::TxSyncTimeout => {
                <i32>::sse_encode(42, serializer);
            }
            crate::utils::error::LdkNodeError::GossipUpdateTimeout => {
                <i32>::sse_encode(43, serializer);
            }
            crate::utils::error::LdkNodeError::InvalidOfferId => {
                <i32>::sse_encode(44, serializer);
            }
            crate::utils::error::LdkNodeError::InvalidNodeId => {
                <i32>::sse_encode(45, serializer);
            }
            crate::utils::error::LdkNodeError::InvalidOffer => {
                <i32>::sse_encode(46, serializer);
            }
            crate::utils::error::LdkNodeError::InvalidRefund => {
                <i32>::sse_encode(47, serializer);
            }
            crate::utils::error::LdkNodeError::UnsupportedCurrency => {
                <i32>::sse_encode(48, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::on_chain::LdkOnChainPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<ldk_node::payment::OnchainPayment>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::spontaneous::LdkSpontaneousPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<ldk_node::payment::SpontaneousPayment>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::types::LightningBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::LightningBalance::ClaimableOnChannelClose {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
            } => {
                <i32>::sse_encode(0, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
            crate::api::types::LightningBalance::ClaimableAwaitingConfirmations {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                confirmation_height,
            } => {
                <i32>::sse_encode(1, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u32>::sse_encode(confirmation_height, serializer);
            }
            crate::api::types::LightningBalance::ContentiousClaimable {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                timeout_height,
                payment_hash,
                payment_preimage,
            } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u32>::sse_encode(timeout_height, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
                <crate::api::types::PaymentPreimage>::sse_encode(payment_preimage, serializer);
            }
            crate::api::types::LightningBalance::MaybeTimeoutClaimableHTLC {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                claimable_height,
                payment_hash,
            } => {
                <i32>::sse_encode(3, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u32>::sse_encode(claimable_height, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
            }
            crate::api::types::LightningBalance::MaybePreimageClaimableHTLC {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                expiry_height,
                payment_hash,
            } => {
                <i32>::sse_encode(4, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u32>::sse_encode(expiry_height, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
            }
            crate::api::types::LightningBalance::CounterpartyRevokedOutputClaimable {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
            } => {
                <i32>::sse_encode(5, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::LiquiditySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <(
            crate::api::types::SocketAddress,
            crate::api::types::PublicKey,
            Option<String>,
        )>::sse_encode(self.lsps2_service, serializer);
    }
}

impl SseEncode for Vec<crate::api::types::ChannelDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::ChannelDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::LightningBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::LightningBalance>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::graph::NodeId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::graph::NodeId>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::PaymentDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::PeerDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::PeerDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::PendingSweepBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::PendingSweepBalance>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::PublicKey>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::SocketAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::SocketAddress>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::types::LogLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::LogLevel::Gossip => 0,
                crate::api::types::LogLevel::Trace => 1,
                crate::api::types::LogLevel::Debug => 2,
                crate::api::types::LogLevel::Info => 3,
                crate::api::types::LogLevel::Warn => 4,
                crate::api::types::LogLevel::Error => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::LSPFeeLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.max_total_opening_fee_msat, serializer);
        <Option<u64>>::sse_encode(self.max_proportional_opening_fee_ppm_msat, serializer);
    }
}

impl SseEncode for crate::api::types::MaxDustHTLCExposure {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::MaxDustHTLCExposure::FixedLimitMsat(field0) => {
                <i32>::sse_encode(0, serializer);
                <u64>::sse_encode(field0, serializer);
            }
            crate::api::types::MaxDustHTLCExposure::FeeRateMultiplier(field0) => {
                <i32>::sse_encode(1, serializer);
                <u64>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::Network::Bitcoin => 0,
                crate::api::types::Network::Testnet => 1,
                crate::api::types::Network::Signet => 2,
                crate::api::types::Network::Regtest => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::graph::NodeAnnouncementInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.last_update, serializer);
        <String>::sse_encode(self.alias, serializer);
        <Vec<crate::api::types::SocketAddress>>::sse_encode(self.addresses, serializer);
    }
}

impl SseEncode for crate::api::graph::NodeId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.compressed, serializer);
    }
}

impl SseEncode for crate::api::graph::NodeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u64>>::sse_encode(self.channels, serializer);
        <Option<crate::api::graph::NodeAnnouncementInfo>>::sse_encode(
            self.announcement_info,
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::NodeStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_running, serializer);
        <bool>::sse_encode(self.is_listening, serializer);
        <crate::api::types::BestBlock>::sse_encode(self.current_best_block, serializer);
        <Option<u64>>::sse_encode(self.latest_wallet_sync_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_onchain_wallet_sync_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_fee_rate_cache_update_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_rgs_snapshot_timestamp, serializer);
        <Option<u64>>::sse_encode(
            self.latest_node_announcement_broadcast_timestamp,
            serializer,
        );
    }
}

impl SseEncode for crate::api::bolt12::Offer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.s, serializer);
    }
}

impl SseEncode for crate::api::types::OfferId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::AnchorChannelsConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::AnchorChannelsConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::ChainDataSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::ChainDataSourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::ChannelConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::ChannelConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::ChannelId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::ChannelId>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::graph::ChannelInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::graph::ChannelInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::graph::ChannelUpdateInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::graph::ChannelUpdateInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::ClosureReason> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::ClosureReason>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::EntropySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::EntropySourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::Event> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::Event>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::GossipSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::GossipSourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::LiquiditySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::LiquiditySourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::MaxDustHTLCExposure> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::MaxDustHTLCExposure>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::graph::NodeAnnouncementInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::graph::NodeAnnouncementInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::graph::NodeInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::graph::NodeInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::OutPoint>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentDetails>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentFailureReason> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentFailureReason>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentHash> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentHash>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentId>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentPreimage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentPreimage>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentSecret> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentSecret>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PublicKey>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u16>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::api::types::SocketAddress>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::api::types::SocketAddress>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::types::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::Txid>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::PaymentId>::sse_encode(self.id, serializer);
        <crate::api::types::PaymentKind>::sse_encode(self.kind, serializer);
        <Option<u64>>::sse_encode(self.amount_msat, serializer);
        <crate::api::types::PaymentDirection>::sse_encode(self.direction, serializer);
        <crate::api::types::PaymentStatus>::sse_encode(self.status, serializer);
        <u64>::sse_encode(self.latest_update_timestamp, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::PaymentDirection::Inbound => 0,
                crate::api::types::PaymentDirection::Outbound => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::PaymentFailureReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::PaymentFailureReason::RecipientRejected => 0,
                crate::api::types::PaymentFailureReason::UserAbandoned => 1,
                crate::api::types::PaymentFailureReason::RetriesExhausted => 2,
                crate::api::types::PaymentFailureReason::PaymentExpired => 3,
                crate::api::types::PaymentFailureReason::RouteNotFound => 4,
                crate::api::types::PaymentFailureReason::UnexpectedError => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::PaymentHash {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::PaymentKind::Onchain => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::types::PaymentKind::Bolt11 {
                hash,
                preimage,
                secret,
            } => {
                <i32>::sse_encode(1, serializer);
                <crate::api::types::PaymentHash>::sse_encode(hash, serializer);
                <Option<crate::api::types::PaymentPreimage>>::sse_encode(preimage, serializer);
                <Option<crate::api::types::PaymentSecret>>::sse_encode(secret, serializer);
            }
            crate::api::types::PaymentKind::Bolt11Jit {
                hash,
                preimage,
                secret,
                lsp_fee_limits,
            } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::types::PaymentHash>::sse_encode(hash, serializer);
                <Option<crate::api::types::PaymentPreimage>>::sse_encode(preimage, serializer);
                <Option<crate::api::types::PaymentSecret>>::sse_encode(secret, serializer);
                <crate::api::types::LSPFeeLimits>::sse_encode(lsp_fee_limits, serializer);
            }
            crate::api::types::PaymentKind::Spontaneous { hash, preimage } => {
                <i32>::sse_encode(3, serializer);
                <crate::api::types::PaymentHash>::sse_encode(hash, serializer);
                <Option<crate::api::types::PaymentPreimage>>::sse_encode(preimage, serializer);
            }
            crate::api::types::PaymentKind::Bolt12Offer {
                hash,
                preimage,
                secret,
                offer_id,
            } => {
                <i32>::sse_encode(4, serializer);
                <Option<crate::api::types::PaymentHash>>::sse_encode(hash, serializer);
                <Option<crate::api::types::PaymentPreimage>>::sse_encode(preimage, serializer);
                <Option<crate::api::types::PaymentSecret>>::sse_encode(secret, serializer);
                <crate::api::types::OfferId>::sse_encode(offer_id, serializer);
            }
            crate::api::types::PaymentKind::Bolt12Refund {
                hash,
                preimage,
                secret,
            } => {
                <i32>::sse_encode(5, serializer);
                <Option<crate::api::types::PaymentHash>>::sse_encode(hash, serializer);
                <Option<crate::api::types::PaymentPreimage>>::sse_encode(preimage, serializer);
                <Option<crate::api::types::PaymentSecret>>::sse_encode(secret, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::PaymentPreimage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentSecret {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::PaymentStatus::Pending => 0,
                crate::api::types::PaymentStatus::Succeeded => 1,
                crate::api::types::PaymentStatus::Failed => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::PeerDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::PublicKey>::sse_encode(self.node_id, serializer);
        <crate::api::types::SocketAddress>::sse_encode(self.address, serializer);
        <bool>::sse_encode(self.is_connected, serializer);
    }
}

impl SseEncode for crate::api::types::PendingSweepBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::PendingSweepBalance::PendingBroadcast {
                channel_id,
                amount_satoshis,
            } => {
                <i32>::sse_encode(0, serializer);
                <Option<crate::api::types::ChannelId>>::sse_encode(channel_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
            crate::api::types::PendingSweepBalance::BroadcastAwaitingConfirmation {
                channel_id,
                latest_broadcast_height,
                latest_spending_txid,
                amount_satoshis,
            } => {
                <i32>::sse_encode(1, serializer);
                <Option<crate::api::types::ChannelId>>::sse_encode(channel_id, serializer);
                <u32>::sse_encode(latest_broadcast_height, serializer);
                <crate::api::types::Txid>::sse_encode(latest_spending_txid, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
            crate::api::types::PendingSweepBalance::AwaitingThresholdConfirmations {
                channel_id,
                latest_spending_txid,
                confirmation_hash,
                confirmation_height,
                amount_satoshis,
            } => {
                <i32>::sse_encode(2, serializer);
                <Option<crate::api::types::ChannelId>>::sse_encode(channel_id, serializer);
                <crate::api::types::Txid>::sse_encode(latest_spending_txid, serializer);
                <String>::sse_encode(confirmation_hash, serializer);
                <u32>::sse_encode(confirmation_height, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::PublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.hex, serializer);
    }
}

impl SseEncode
    for (
        crate::api::types::SocketAddress,
        crate::api::types::PublicKey,
        Option<String>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::SocketAddress>::sse_encode(self.0, serializer);
        <crate::api::types::PublicKey>::sse_encode(self.1, serializer);
        <Option<String>>::sse_encode(self.2, serializer);
    }
}

impl SseEncode for crate::api::bolt12::Refund {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.s, serializer);
    }
}

impl SseEncode for crate::api::graph::RoutingFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.base_msat, serializer);
        <u32>::sse_encode(self.proportional_millionths, serializer);
    }
}

impl SseEncode for crate::api::types::SocketAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::SocketAddress::TcpIpV4 { addr, port } => {
                <i32>::sse_encode(0, serializer);
                <[u8; 4]>::sse_encode(addr, serializer);
                <u16>::sse_encode(port, serializer);
            }
            crate::api::types::SocketAddress::TcpIpV6 { addr, port } => {
                <i32>::sse_encode(1, serializer);
                <[u8; 16]>::sse_encode(addr, serializer);
                <u16>::sse_encode(port, serializer);
            }
            crate::api::types::SocketAddress::OnionV2(field0) => {
                <i32>::sse_encode(2, serializer);
                <[u8; 12]>::sse_encode(field0, serializer);
            }
            crate::api::types::SocketAddress::OnionV3 {
                ed25519_pubkey,
                checksum,
                version,
                port,
            } => {
                <i32>::sse_encode(3, serializer);
                <[u8; 32]>::sse_encode(ed25519_pubkey, serializer);
                <u16>::sse_encode(checksum, serializer);
                <u8>::sse_encode(version, serializer);
                <u16>::sse_encode(port, serializer);
            }
            crate::api::types::SocketAddress::Hostname { addr, port } => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(addr, serializer);
                <u16>::sse_encode(port, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::Txid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.hash, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for [u8; 12] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 16] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 32] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 4] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 64] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::api::types::UserChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
#[path = "frb_generated.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use io::*;
