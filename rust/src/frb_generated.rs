// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.31.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding
)]

// Section: imports

use crate::api::node::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::transform_result_dco;
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.0.0-dev.31";

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire_NodeBuilder_build_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<NodeBuilder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBuilder_build",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || crate::api::node::NodeBuilder::build(api_that))())
            }
        },
    )
}
fn wire_NodeBuilder_build_with_fs_store_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<NodeBuilder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBuilder_build_with_fs_store",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBuilder::build_with_fs_store(api_that)
                })())
            }
        },
    )
}
fn wire_NodeBuilder_create_builder_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    config: impl CstDecode<crate::api::types::Config>,
    chain_data_source_config: impl CstDecode<Option<crate::api::types::ChainDataSourceConfig>>,
    entropy_source_config: impl CstDecode<Option<crate::api::types::EntropySourceConfig>>,
    gossip_source_config: impl CstDecode<Option<crate::api::types::GossipSourceConfig>>,
    liquidity_source_config: impl CstDecode<Option<crate::api::types::LiquiditySourceConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NodeBuilder_create_builder",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_config = config.cst_decode();
            let api_chain_data_source_config = chain_data_source_config.cst_decode();
            let api_entropy_source_config = entropy_source_config.cst_decode();
            let api_gossip_source_config = gossip_source_config.cst_decode();
            let api_liquidity_source_config = liquidity_source_config.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::NodeBuilder::create_builder(
                        api_config,
                        api_chain_data_source_config,
                        api_entropy_source_config,
                        api_gossip_source_config,
                        api_liquidity_source_config,
                    )
                })())
            }
        },
    )
}
fn wire_ldk_bolt_11_payment_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkBolt11Payment>,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkBolt11Payment::receive(
                        &api_that,
                        api_amount_msat,
                        api_description,
                        api_expiry_secs,
                    )
                })())
            }
        },
    )
}
fn wire_ldk_bolt_11_payment_receive_variable_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkBolt11Payment>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_receive_variable_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkBolt11Payment::receive_variable_amount(
                        &api_that,
                        api_description,
                        api_expiry_secs,
                    )
                })())
            }
        },
    )
}
fn wire_ldk_bolt_11_payment_receive_variable_amount_via_jit_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkBolt11Payment>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    max_proportional_lsp_fee_limit_ppm_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_receive_variable_amount_via_jit_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_max_proportional_lsp_fee_limit_ppm_msat =
                max_proportional_lsp_fee_limit_ppm_msat.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkBolt11Payment::receive_variable_amount_via_jit_channel(
                        &api_that,
                        api_description,
                        api_expiry_secs,
                        api_max_proportional_lsp_fee_limit_ppm_msat,
                    )
                })())
            }
        },
    )
}
fn wire_ldk_bolt_11_payment_receive_via_jit_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkBolt11Payment>,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    max_total_lsp_fee_limit_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_receive_via_jit_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_max_total_lsp_fee_limit_msat = max_total_lsp_fee_limit_msat.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkBolt11Payment::receive_via_jit_channel(
                        &api_that,
                        api_amount_msat,
                        api_description,
                        api_expiry_secs,
                        api_max_total_lsp_fee_limit_msat,
                    )
                })())
            }
        },
    )
}
fn wire_ldk_bolt_11_payment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkBolt11Payment>,
    invoice: impl CstDecode<crate::api::types::Bolt11Invoice>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkBolt11Payment::send(&api_that, api_invoice)
                })())
            }
        },
    )
}
fn wire_ldk_bolt_11_payment_send_probes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkBolt11Payment>,
    invoice: impl CstDecode<crate::api::types::Bolt11Invoice>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_send_probes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkBolt11Payment::send_probes(&api_that, api_invoice)
                })())
            }
        },
    )
}
fn wire_ldk_bolt_11_payment_send_probes_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkBolt11Payment>,
    invoice: impl CstDecode<crate::api::types::Bolt11Invoice>,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_send_probes_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkBolt11Payment::send_probes_using_amount(
                        &api_that,
                        api_invoice,
                        api_amount_msat,
                    )
                })())
            }
        },
    )
}
fn wire_ldk_bolt_11_payment_send_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkBolt11Payment>,
    invoice: impl CstDecode<crate::api::types::Bolt11Invoice>,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_bolt_11_payment_send_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkBolt11Payment::send_using_amount(
                        &api_that,
                        api_invoice,
                        api_amount_msat,
                    )
                })())
            }
        },
    )
}
fn wire_ldk_mnemonic_generate_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_mnemonic_generate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::LdkMnemonic::generate())
                })())
            }
        },
    )
}
fn wire_ldk_node_bolt11_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_bolt11_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::LdkNode::bolt11_payment(api_ptr))
                })())
            }
        },
    )
}
fn wire_ldk_node_close_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    user_channel_id: impl CstDecode<crate::api::types::UserChannelId>,
    counterparty_node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_close_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkNode::close_channel(
                        &api_that,
                        api_user_channel_id,
                        api_counterparty_node_id,
                    )
                })())
            }
        },
    )
}
fn wire_ldk_node_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::LdkNode::config(&api_that))
                })())
            }
        },
    )
}
fn wire_ldk_node_connect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
    address: impl CstDecode<crate::api::types::SocketAddress>,
    persist: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_connect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_address = address.cst_decode();
            let api_persist = persist.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkNode::connect(
                        &api_that,
                        api_node_id,
                        api_address,
                        api_persist,
                    )
                })())
            }
        },
    )
}
fn wire_ldk_node_connect_open_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    socket_address: impl CstDecode<crate::api::types::SocketAddress>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
    channel_amount_sats: impl CstDecode<u64>,
    push_to_counterparty_msat: impl CstDecode<Option<u64>>,
    announce_channel: impl CstDecode<bool>,
    channel_config: impl CstDecode<Option<crate::api::types::ChannelConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_connect_open_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_socket_address = socket_address.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_channel_amount_sats = channel_amount_sats.cst_decode();
            let api_push_to_counterparty_msat = push_to_counterparty_msat.cst_decode();
            let api_announce_channel = announce_channel.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkNode::connect_open_channel(
                        &api_that,
                        api_socket_address,
                        api_node_id,
                        api_channel_amount_sats,
                        api_push_to_counterparty_msat,
                        api_announce_channel,
                        api_channel_config,
                    )
                })())
            }
        },
    )
}
fn wire_ldk_node_disconnect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    counterparty_node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_disconnect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkNode::disconnect(&api_that, api_counterparty_node_id)
                })())
            }
        },
    )
}
fn wire_ldk_node_event_handled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_event_handled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::LdkNode::event_handled(&api_that))
                })())
            }
        },
    )
}
fn wire_ldk_node_list_balances_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_list_balances",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkNode::list_balances(&api_that)
                })())
            }
        },
    )
}
fn wire_ldk_node_list_channels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_list_channels",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::LdkNode::list_channels(&api_that))
                })())
            }
        },
    )
}
fn wire_ldk_node_list_payments_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_list_payments",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::LdkNode::list_payments(&api_that))
                })())
            }
        },
    )
}
fn wire_ldk_node_list_payments_with_filter_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    payment_direction: impl CstDecode<crate::api::types::PaymentDirection>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_list_payments_with_filter",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_direction = payment_direction.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::LdkNode::list_payments_with_filter(
                        &api_that,
                        api_payment_direction,
                    ))
                })())
            }
        },
    )
}
fn wire_ldk_node_list_peers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_list_peers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::LdkNode::list_peers(&api_that))
                })())
            }
        },
    )
}
fn wire_ldk_node_listening_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_listening_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::LdkNode::listening_addresses(&api_that))
                })())
            }
        },
    )
}
fn wire_ldk_node_next_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_next_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::LdkNode::next_event(&api_that))
                })())
            }
        },
    )
}
fn wire_ldk_node_next_event_async_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_next_event_async",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco(
                    (move || async move {
                        Result::<_, ()>::Ok(
                            crate::api::node::LdkNode::next_event_async(&api_that).await,
                        )
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire_ldk_node_node_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_node_id",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::LdkNode::node_id(&api_that))
                })())
            }
        },
    )
}
fn wire_ldk_node_on_chain_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_on_chain_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::LdkNode::on_chain_payment(api_ptr))
                })())
            }
        },
    )
}
fn wire_ldk_node_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    payment_id: impl CstDecode<crate::api::types::PaymentId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_id = payment_id.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::LdkNode::payment(
                        &api_that,
                        api_payment_id,
                    ))
                })())
            }
        },
    )
}
fn wire_ldk_node_remove_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    payment_id: impl CstDecode<crate::api::types::PaymentId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_remove_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_id = payment_id.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkNode::remove_payment(&api_that, api_payment_id)
                })())
            }
        },
    )
}
fn wire_ldk_node_sign_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    msg: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_sign_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_msg = msg.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkNode::sign_message(&api_that, api_msg)
                })())
            }
        },
    )
}
fn wire_ldk_node_spontaneous_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_spontaneous_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::LdkNode::spontaneous_payment(api_ptr))
                })())
            }
        },
    )
}
fn wire_ldk_node_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || crate::api::node::LdkNode::start(&api_that))())
            }
        },
    )
}
fn wire_ldk_node_status_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_status",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::LdkNode::status(&api_that))
                })())
            }
        },
    )
}
fn wire_ldk_node_stop_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_stop",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || crate::api::node::LdkNode::stop(&api_that))())
            }
        },
    )
}
fn wire_ldk_node_sync_wallets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_sync_wallets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || crate::api::node::LdkNode::sync_wallets(&api_that))())
            }
        },
    )
}
fn wire_ldk_node_update_channel_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    user_channel_id: impl CstDecode<crate::api::types::UserChannelId>,
    counterparty_node_id: impl CstDecode<crate::api::types::PublicKey>,
    channel_config: impl CstDecode<crate::api::types::ChannelConfig>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_update_channel_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkNode::update_channel_config(
                        &api_that,
                        api_user_channel_id,
                        api_counterparty_node_id,
                        api_channel_config,
                    )
                })())
            }
        },
    )
}
fn wire_ldk_node_verify_signature_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
    msg: impl CstDecode<Vec<u8>>,
    sig: impl CstDecode<String>,
    public_key: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_verify_signature",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_msg = msg.cst_decode();
            let api_sig = sig.cst_decode();
            let api_public_key = public_key.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkNode::verify_signature(
                        &api_that,
                        api_msg,
                        api_sig,
                        api_public_key,
                    )
                })())
            }
        },
    )
}
fn wire_ldk_node_wait_next_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_node_wait_next_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::node::LdkNode::wait_next_event(&api_that))
                })())
            }
        },
    )
}
fn wire_ldk_on_chain_payment_new_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkOnChainPayment>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_on_chain_payment_new_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkOnChainPayment::new_address(&api_that)
                })())
            }
        },
    )
}
fn wire_ldk_on_chain_payment_send_all_to_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkOnChainPayment>,
    address: impl CstDecode<crate::api::types::Address>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_on_chain_payment_send_all_to_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkOnChainPayment::send_all_to_address(&api_that, api_address)
                })())
            }
        },
    )
}
fn wire_ldk_on_chain_payment_send_to_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkOnChainPayment>,
    address: impl CstDecode<crate::api::types::Address>,
    amount_sats: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_on_chain_payment_send_to_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            let api_amount_sats = amount_sats.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkOnChainPayment::send_to_address(
                        &api_that,
                        api_address,
                        api_amount_sats,
                    )
                })())
            }
        },
    )
}
fn wire_ldk_spontaneous_payment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkSpontaneousPayment>,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_spontaneous_payment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_node_id = node_id.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkSpontaneousPayment::send(
                        &api_that,
                        api_amount_msat,
                        api_node_id,
                    )
                })())
            }
        },
    )
}
fn wire_ldk_spontaneous_payment_send_probes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::LdkSpontaneousPayment>,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ldk_spontaneous_payment_send_probes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_node_id = node_id.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::node::LdkSpontaneousPayment::send_probes(
                        &api_that,
                        api_amount_msat,
                        api_node_id,
                    )
                })())
            }
        },
    )
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<crate::api::error::BuilderException> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::BuilderException {
        match self {
            0 => crate::api::error::BuilderException::SocketAddressParseError,
            1 => crate::api::error::BuilderException::InvalidSeedBytes,
            2 => crate::api::error::BuilderException::InvalidSeedFile,
            3 => crate::api::error::BuilderException::InvalidSystemTime,
            4 => crate::api::error::BuilderException::InvalidChannelMonitor,
            5 => crate::api::error::BuilderException::InvalidListeningAddress,
            6 => crate::api::error::BuilderException::ReadFailed,
            7 => crate::api::error::BuilderException::WriteFailed,
            8 => crate::api::error::BuilderException::StoragePathAccessFailed,
            9 => crate::api::error::BuilderException::KVStoreSetupFailed,
            10 => crate::api::error::BuilderException::WalletSetupFailed,
            11 => crate::api::error::BuilderException::LoggerSetupFailed,
            12 => crate::api::error::BuilderException::InvalidPublicKey,
            _ => unreachable!("Invalid variant for BuilderException: {}", self),
        }
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<crate::api::types::LogLevel> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::LogLevel {
        match self {
            0 => crate::api::types::LogLevel::Gossip,
            1 => crate::api::types::LogLevel::Trace,
            2 => crate::api::types::LogLevel::Debug,
            3 => crate::api::types::LogLevel::Info,
            4 => crate::api::types::LogLevel::Warn,
            5 => crate::api::types::LogLevel::Error,
            _ => unreachable!("Invalid variant for LogLevel: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::Network> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Network {
        match self {
            0 => crate::api::types::Network::Bitcoin,
            1 => crate::api::types::Network::Testnet,
            2 => crate::api::types::Network::Signet,
            3 => crate::api::types::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", self),
        }
    }
}
impl CstDecode<crate::api::error::NodeException> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::error::NodeException {
        match self {
            0 => crate::api::error::NodeException::InvalidTxid,
            1 => crate::api::error::NodeException::AlreadyRunning,
            2 => crate::api::error::NodeException::NotRunning,
            3 => crate::api::error::NodeException::OnchainTxCreationFailed,
            4 => crate::api::error::NodeException::ConnectionFailed,
            5 => crate::api::error::NodeException::InvoiceCreationFailed,
            6 => crate::api::error::NodeException::PaymentSendingFailed,
            7 => crate::api::error::NodeException::ProbeSendingFailed,
            8 => crate::api::error::NodeException::ChannelCreationFailed,
            9 => crate::api::error::NodeException::ChannelClosingFailed,
            10 => crate::api::error::NodeException::ChannelConfigUpdateFailed,
            11 => crate::api::error::NodeException::PersistenceFailed,
            12 => crate::api::error::NodeException::WalletOperationFailed,
            13 => crate::api::error::NodeException::OnchainTxSigningFailed,
            14 => crate::api::error::NodeException::MessageSigningFailed,
            15 => crate::api::error::NodeException::TxSyncFailed,
            16 => crate::api::error::NodeException::GossipUpdateFailed,
            17 => crate::api::error::NodeException::InvalidAddress,
            18 => crate::api::error::NodeException::InvalidSocketAddress,
            19 => crate::api::error::NodeException::InvalidPublicKey,
            20 => crate::api::error::NodeException::InvalidSecretKey,
            21 => crate::api::error::NodeException::InvalidPaymentHash,
            22 => crate::api::error::NodeException::InvalidPaymentPreimage,
            23 => crate::api::error::NodeException::InvalidPaymentSecret,
            24 => crate::api::error::NodeException::InvalidAmount,
            25 => crate::api::error::NodeException::InvalidInvoice,
            26 => crate::api::error::NodeException::InvalidChannelId,
            27 => crate::api::error::NodeException::InvalidNetwork,
            28 => crate::api::error::NodeException::DuplicatePayment,
            29 => crate::api::error::NodeException::InsufficientFunds,
            30 => crate::api::error::NodeException::FeerateEstimationUpdateFailed,
            31 => crate::api::error::NodeException::LiquidityRequestFailed,
            32 => crate::api::error::NodeException::LiquiditySourceUnavailable,
            33 => crate::api::error::NodeException::LiquidityFeeTooHigh,
            34 => crate::api::error::NodeException::InvalidPaymentId,
            35 => crate::api::error::NodeException::DecodeError,
            _ => unreachable!("Invalid variant for NodeException: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::PaymentDirection> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::PaymentDirection {
        match self {
            0 => crate::api::types::PaymentDirection::Inbound,
            1 => crate::api::types::PaymentDirection::Outbound,
            _ => unreachable!("Invalid variant for PaymentDirection: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::PaymentFailureReason> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::PaymentFailureReason {
        match self {
            0 => crate::api::types::PaymentFailureReason::RecipientRejected,
            1 => crate::api::types::PaymentFailureReason::UserAbandoned,
            2 => crate::api::types::PaymentFailureReason::RetriesExhausted,
            3 => crate::api::types::PaymentFailureReason::PaymentExpired,
            4 => crate::api::types::PaymentFailureReason::RouteNotFound,
            5 => crate::api::types::PaymentFailureReason::UnexpectedError,
            _ => unreachable!("Invalid variant for PaymentFailureReason: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::PaymentStatus> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::PaymentStatus {
        match self {
            0 => crate::api::types::PaymentStatus::Pending,
            1 => crate::api::types::PaymentStatus::Succeeded,
            2 => crate::api::types::PaymentStatus::Failed,
            _ => unreachable!("Invalid variant for PaymentStatus: {}", self),
        }
    }
}
impl CstDecode<u16> for u16 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u16 {
        self
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl SseDecode for NodeBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::rust_async::RwLock<NodeBuilder>,
        >>::sse_decode(deserializer);
        return inner.rust_auto_opaque_decode_owned();
    }
}

impl SseDecode for RustOpaqueNom<Node> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<NodeBuilder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<ldk_node::payment::Bolt11Payment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<ldk_node::payment::OnchainPayment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<ldk_node::payment::SpontaneousPayment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::types::Address {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_s = <String>::sse_decode(deserializer);
        return crate::api::types::Address { s: var_s };
    }
}

impl SseDecode for crate::api::types::BalanceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_totalOnchainBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_spendableOnchainBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_totalLightningBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_lightningBalances =
            <Vec<crate::api::types::LightningBalance>>::sse_decode(deserializer);
        let mut var_pendingBalancesFromChannelClosures =
            <Vec<crate::api::types::PendingSweepBalance>>::sse_decode(deserializer);
        return crate::api::types::BalanceDetails {
            total_onchain_balance_sats: var_totalOnchainBalanceSats,
            spendable_onchain_balance_sats: var_spendableOnchainBalanceSats,
            total_lightning_balance_sats: var_totalLightningBalanceSats,
            lightning_balances: var_lightningBalances,
            pending_balances_from_channel_closures: var_pendingBalancesFromChannelClosures,
        };
    }
}

impl SseDecode for crate::api::types::BestBlock {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_blockHash = <String>::sse_decode(deserializer);
        let mut var_height = <u32>::sse_decode(deserializer);
        return crate::api::types::BestBlock {
            block_hash: var_blockHash,
            height: var_height,
        };
    }
}

impl SseDecode for crate::api::types::Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_signedRawInvoice = <String>::sse_decode(deserializer);
        return crate::api::types::Bolt11Invoice {
            signed_raw_invoice: var_signedRawInvoice,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::error::BuilderException {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::error::BuilderException::SocketAddressParseError,
            1 => crate::api::error::BuilderException::InvalidSeedBytes,
            2 => crate::api::error::BuilderException::InvalidSeedFile,
            3 => crate::api::error::BuilderException::InvalidSystemTime,
            4 => crate::api::error::BuilderException::InvalidChannelMonitor,
            5 => crate::api::error::BuilderException::InvalidListeningAddress,
            6 => crate::api::error::BuilderException::ReadFailed,
            7 => crate::api::error::BuilderException::WriteFailed,
            8 => crate::api::error::BuilderException::StoragePathAccessFailed,
            9 => crate::api::error::BuilderException::KVStoreSetupFailed,
            10 => crate::api::error::BuilderException::WalletSetupFailed,
            11 => crate::api::error::BuilderException::LoggerSetupFailed,
            12 => crate::api::error::BuilderException::InvalidPublicKey,
            _ => unreachable!("Invalid variant for BuilderException: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::ChainDataSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::types::ChainDataSourceConfig::Esplora(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::ChannelConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_forwardingFeeProportionalMillionths = <u32>::sse_decode(deserializer);
        let mut var_forwardingFeeBaseMsat = <u32>::sse_decode(deserializer);
        let mut var_cltvExpiryDelta = <u16>::sse_decode(deserializer);
        let mut var_maxDustHtlcExposure =
            <Option<crate::api::types::MaxDustHTLCExposure>>::sse_decode(deserializer);
        let mut var_forceCloseAvoidanceMaxFeeSatoshis = <u64>::sse_decode(deserializer);
        let mut var_acceptUnderpayingHtlcs = <bool>::sse_decode(deserializer);
        return crate::api::types::ChannelConfig {
            forwarding_fee_proportional_millionths: var_forwardingFeeProportionalMillionths,
            forwarding_fee_base_msat: var_forwardingFeeBaseMsat,
            cltv_expiry_delta: var_cltvExpiryDelta,
            max_dust_htlc_exposure: var_maxDustHtlcExposure,
            force_close_avoidance_max_fee_satoshis: var_forceCloseAvoidanceMaxFeeSatoshis,
            accept_underpaying_htlcs: var_acceptUnderpayingHtlcs,
        };
    }
}

impl SseDecode for crate::api::types::ChannelDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
        let mut var_counterpartyNodeId = <crate::api::types::PublicKey>::sse_decode(deserializer);
        let mut var_fundingTxo = <Option<crate::api::types::OutPoint>>::sse_decode(deserializer);
        let mut var_channelValueSats = <u64>::sse_decode(deserializer);
        let mut var_unspendablePunishmentReserve = <Option<u64>>::sse_decode(deserializer);
        let mut var_userChannelId = <crate::api::types::UserChannelId>::sse_decode(deserializer);
        let mut var_feerateSatPer1000Weight = <u32>::sse_decode(deserializer);
        let mut var_outboundCapacityMsat = <u64>::sse_decode(deserializer);
        let mut var_inboundCapacityMsat = <u64>::sse_decode(deserializer);
        let mut var_confirmationsRequired = <Option<u32>>::sse_decode(deserializer);
        let mut var_confirmations = <Option<u32>>::sse_decode(deserializer);
        let mut var_isOutbound = <bool>::sse_decode(deserializer);
        let mut var_isChannelReady = <bool>::sse_decode(deserializer);
        let mut var_isUsable = <bool>::sse_decode(deserializer);
        let mut var_isPublic = <bool>::sse_decode(deserializer);
        let mut var_cltvExpiryDelta = <Option<u16>>::sse_decode(deserializer);
        let mut var_counterpartyUnspendablePunishmentReserve = <u64>::sse_decode(deserializer);
        let mut var_counterpartyOutboundHtlcMinimumMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_counterpartyOutboundHtlcMaximumMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_counterpartyForwardingInfoFeeBaseMsat = <Option<u32>>::sse_decode(deserializer);
        let mut var_counterpartyForwardingInfoFeeProportionalMillionths =
            <Option<u32>>::sse_decode(deserializer);
        let mut var_counterpartyForwardingInfoCltvExpiryDelta =
            <Option<u16>>::sse_decode(deserializer);
        let mut var_nextOutboundHtlcLimitMsat = <u64>::sse_decode(deserializer);
        let mut var_nextOutboundHtlcMinimumMsat = <u64>::sse_decode(deserializer);
        let mut var_forceCloseSpendDelay = <Option<u16>>::sse_decode(deserializer);
        let mut var_inboundHtlcMinimumMsat = <u64>::sse_decode(deserializer);
        let mut var_inboundHtlcMaximumMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_config = <crate::api::types::ChannelConfig>::sse_decode(deserializer);
        return crate::api::types::ChannelDetails {
            channel_id: var_channelId,
            counterparty_node_id: var_counterpartyNodeId,
            funding_txo: var_fundingTxo,
            channel_value_sats: var_channelValueSats,
            unspendable_punishment_reserve: var_unspendablePunishmentReserve,
            user_channel_id: var_userChannelId,
            feerate_sat_per_1000_weight: var_feerateSatPer1000Weight,
            outbound_capacity_msat: var_outboundCapacityMsat,
            inbound_capacity_msat: var_inboundCapacityMsat,
            confirmations_required: var_confirmationsRequired,
            confirmations: var_confirmations,
            is_outbound: var_isOutbound,
            is_channel_ready: var_isChannelReady,
            is_usable: var_isUsable,
            is_public: var_isPublic,
            cltv_expiry_delta: var_cltvExpiryDelta,
            counterparty_unspendable_punishment_reserve:
                var_counterpartyUnspendablePunishmentReserve,
            counterparty_outbound_htlc_minimum_msat: var_counterpartyOutboundHtlcMinimumMsat,
            counterparty_outbound_htlc_maximum_msat: var_counterpartyOutboundHtlcMaximumMsat,
            counterparty_forwarding_info_fee_base_msat: var_counterpartyForwardingInfoFeeBaseMsat,
            counterparty_forwarding_info_fee_proportional_millionths:
                var_counterpartyForwardingInfoFeeProportionalMillionths,
            counterparty_forwarding_info_cltv_expiry_delta:
                var_counterpartyForwardingInfoCltvExpiryDelta,
            next_outbound_htlc_limit_msat: var_nextOutboundHtlcLimitMsat,
            next_outbound_htlc_minimum_msat: var_nextOutboundHtlcMinimumMsat,
            force_close_spend_delay: var_forceCloseSpendDelay,
            inbound_htlc_minimum_msat: var_inboundHtlcMinimumMsat,
            inbound_htlc_maximum_msat: var_inboundHtlcMaximumMsat,
            config: var_config,
        };
    }
}

impl SseDecode for crate::api::types::ChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::ChannelId { data: var_data };
    }
}

impl SseDecode for crate::api::types::ClosureReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_peerMsg = <String>::sse_decode(deserializer);
                return crate::api::types::ClosureReason::CounterpartyForceClosed {
                    peer_msg: var_peerMsg,
                };
            }
            1 => {
                return crate::api::types::ClosureReason::HolderForceClosed;
            }
            2 => {
                return crate::api::types::ClosureReason::LegacyCooperativeClosure;
            }
            3 => {
                return crate::api::types::ClosureReason::CounterpartyInitiatedCooperativeClosure;
            }
            4 => {
                return crate::api::types::ClosureReason::LocallyInitiatedCooperativeClosure;
            }
            5 => {
                return crate::api::types::ClosureReason::CommitmentTxConfirmed;
            }
            6 => {
                return crate::api::types::ClosureReason::FundingTimedOut;
            }
            7 => {
                let mut var_err = <String>::sse_decode(deserializer);
                return crate::api::types::ClosureReason::ProcessingError { err: var_err };
            }
            8 => {
                return crate::api::types::ClosureReason::DisconnectedPeer;
            }
            9 => {
                return crate::api::types::ClosureReason::OutdatedChannelManager;
            }
            10 => {
                return crate::api::types::ClosureReason::CounterpartyCoopClosedUnfundedChannel;
            }
            11 => {
                return crate::api::types::ClosureReason::FundingBatchClosure;
            }
            12 => {
                return crate::api::types::ClosureReason::HTLCsTimedOut;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_storageDirPath = <String>::sse_decode(deserializer);
        let mut var_logDirPath = <Option<String>>::sse_decode(deserializer);
        let mut var_network = <crate::api::types::Network>::sse_decode(deserializer);
        let mut var_listeningAddresses =
            <Option<Vec<crate::api::types::SocketAddress>>>::sse_decode(deserializer);
        let mut var_defaultCltvExpiryDelta = <u32>::sse_decode(deserializer);
        let mut var_onchainWalletSyncIntervalSecs = <u64>::sse_decode(deserializer);
        let mut var_walletSyncIntervalSecs = <u64>::sse_decode(deserializer);
        let mut var_feeRateCacheUpdateIntervalSecs = <u64>::sse_decode(deserializer);
        let mut var_trustedPeers0Conf =
            <Vec<crate::api::types::PublicKey>>::sse_decode(deserializer);
        let mut var_probingLiquidityLimitMultiplier = <u64>::sse_decode(deserializer);
        let mut var_logLevel = <crate::api::types::LogLevel>::sse_decode(deserializer);
        return crate::api::types::Config {
            storage_dir_path: var_storageDirPath,
            log_dir_path: var_logDirPath,
            network: var_network,
            listening_addresses: var_listeningAddresses,
            default_cltv_expiry_delta: var_defaultCltvExpiryDelta,
            onchain_wallet_sync_interval_secs: var_onchainWalletSyncIntervalSecs,
            wallet_sync_interval_secs: var_walletSyncIntervalSecs,
            fee_rate_cache_update_interval_secs: var_feeRateCacheUpdateIntervalSecs,
            trusted_peers_0conf: var_trustedPeers0Conf,
            probing_liquidity_limit_multiplier: var_probingLiquidityLimitMultiplier,
            log_level: var_logLevel,
        };
    }
}

impl SseDecode for crate::api::types::EntropySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::types::EntropySourceConfig::SeedFile(var_field0);
            }
            1 => {
                let mut var_field0 = <[u8; 64]>::sse_decode(deserializer);
                return crate::api::types::EntropySourceConfig::SeedBytes(var_field0);
            }
            2 => {
                let mut var_mnemonic = <crate::api::node::LdkMnemonic>::sse_decode(deserializer);
                let mut var_passphrase = <Option<String>>::sse_decode(deserializer);
                return crate::api::types::EntropySourceConfig::Bip39Mnemonic {
                    mnemonic: var_mnemonic,
                    passphrase: var_passphrase,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Event {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_paymentId =
                    <Option<crate::api::types::PaymentId>>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_feePaidMsat = <Option<u64>>::sse_decode(deserializer);
                return crate::api::types::Event::PaymentSuccessful {
                    payment_id: var_paymentId,
                    payment_hash: var_paymentHash,
                    fee_paid_msat: var_feePaidMsat,
                };
            }
            1 => {
                let mut var_paymentId =
                    <Option<crate::api::types::PaymentId>>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_reason =
                    <Option<crate::api::types::PaymentFailureReason>>::sse_decode(deserializer);
                return crate::api::types::Event::PaymentFailed {
                    payment_id: var_paymentId,
                    payment_hash: var_paymentHash,
                    reason: var_reason,
                };
            }
            2 => {
                let mut var_paymentId =
                    <Option<crate::api::types::PaymentId>>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_amountMsat = <u64>::sse_decode(deserializer);
                return crate::api::types::Event::PaymentReceived {
                    payment_id: var_paymentId,
                    payment_hash: var_paymentHash,
                    amount_msat: var_amountMsat,
                };
            }
            3 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_userChannelId =
                    <crate::api::types::UserChannelId>::sse_decode(deserializer);
                let mut var_formerTemporaryChannelId =
                    <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_fundingTxo = <crate::api::types::OutPoint>::sse_decode(deserializer);
                return crate::api::types::Event::ChannelPending {
                    channel_id: var_channelId,
                    user_channel_id: var_userChannelId,
                    former_temporary_channel_id: var_formerTemporaryChannelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    funding_txo: var_fundingTxo,
                };
            }
            4 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_userChannelId =
                    <crate::api::types::UserChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <Option<crate::api::types::PublicKey>>::sse_decode(deserializer);
                return crate::api::types::Event::ChannelReady {
                    channel_id: var_channelId,
                    user_channel_id: var_userChannelId,
                    counterparty_node_id: var_counterpartyNodeId,
                };
            }
            5 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_userChannelId =
                    <crate::api::types::UserChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <Option<crate::api::types::PublicKey>>::sse_decode(deserializer);
                let mut var_reason =
                    <Option<crate::api::types::ClosureReason>>::sse_decode(deserializer);
                return crate::api::types::Event::ChannelClosed {
                    channel_id: var_channelId,
                    user_channel_id: var_userChannelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    reason: var_reason,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::GossipSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::types::GossipSourceConfig::P2PNetwork;
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::types::GossipSourceConfig::RapidGossipSync(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::node::LdkBolt11Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr =
            <RustOpaqueNom<ldk_node::payment::Bolt11Payment>>::sse_decode(deserializer);
        return crate::api::node::LdkBolt11Payment { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::node::LdkMnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_seedPhrase = <String>::sse_decode(deserializer);
        return crate::api::node::LdkMnemonic {
            seed_phrase: var_seedPhrase,
        };
    }
}

impl SseDecode for crate::api::node::LdkNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr = <RustOpaqueNom<Node>>::sse_decode(deserializer);
        return crate::api::node::LdkNode { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::node::LdkOnChainPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr =
            <RustOpaqueNom<ldk_node::payment::OnchainPayment>>::sse_decode(deserializer);
        return crate::api::node::LdkOnChainPayment { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::node::LdkSpontaneousPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr =
            <RustOpaqueNom<ldk_node::payment::SpontaneousPayment>>::sse_decode(deserializer);
        return crate::api::node::LdkSpontaneousPayment { ptr: var_ptr };
    }
}

impl SseDecode for crate::api::types::LightningBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::ClaimableOnChannelClose {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            1 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_confirmationHeight = <u32>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::ClaimableAwaitingConfirmations {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    confirmation_height: var_confirmationHeight,
                };
            }
            2 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_timeoutHeight = <u32>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_paymentPreimage =
                    <crate::api::types::PaymentPreimage>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::ContentiousClaimable {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    timeout_height: var_timeoutHeight,
                    payment_hash: var_paymentHash,
                    payment_preimage: var_paymentPreimage,
                };
            }
            3 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_claimableHeight = <u32>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::MaybeTimeoutClaimableHTLC {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    claimable_height: var_claimableHeight,
                    payment_hash: var_paymentHash,
                };
            }
            4 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_expiryHeight = <u32>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::MaybePreimageClaimableHTLC {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    expiry_height: var_expiryHeight,
                    payment_hash: var_paymentHash,
                };
            }
            5 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::CounterpartyRevokedOutputClaimable {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::LiquiditySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lsps2Service = <(
            crate::api::types::SocketAddress,
            crate::api::types::PublicKey,
            Option<String>,
        )>::sse_decode(deserializer);
        return crate::api::types::LiquiditySourceConfig {
            lsps2_service: var_lsps2Service,
        };
    }
}

impl SseDecode for Vec<crate::api::types::ChannelDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::ChannelDetails>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::LightningBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::LightningBalance>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::PaymentDetails>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::PeerDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::PeerDetails>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::PendingSweepBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::PendingSweepBalance>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::PublicKey>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::SocketAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::SocketAddress>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::types::LogLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::LogLevel::Gossip,
            1 => crate::api::types::LogLevel::Trace,
            2 => crate::api::types::LogLevel::Debug,
            3 => crate::api::types::LogLevel::Info,
            4 => crate::api::types::LogLevel::Warn,
            5 => crate::api::types::LogLevel::Error,
            _ => unreachable!("Invalid variant for LogLevel: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::LSPFeeLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_maxTotalOpeningFeeMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_maxProportionalOpeningFeePpmMsat = <Option<u64>>::sse_decode(deserializer);
        return crate::api::types::LSPFeeLimits {
            max_total_opening_fee_msat: var_maxTotalOpeningFeeMsat,
            max_proportional_opening_fee_ppm_msat: var_maxProportionalOpeningFeePpmMsat,
        };
    }
}

impl SseDecode for crate::api::types::MaxDustHTLCExposure {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <u64>::sse_decode(deserializer);
                return crate::api::types::MaxDustHTLCExposure::FixedLimitMsat(var_field0);
            }
            1 => {
                let mut var_field0 = <u64>::sse_decode(deserializer);
                return crate::api::types::MaxDustHTLCExposure::FeeRateMultiplier(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::Network::Bitcoin,
            1 => crate::api::types::Network::Testnet,
            2 => crate::api::types::Network::Signet,
            3 => crate::api::types::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", inner),
        };
    }
}

impl SseDecode for crate::api::error::NodeException {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::error::NodeException::InvalidTxid,
            1 => crate::api::error::NodeException::AlreadyRunning,
            2 => crate::api::error::NodeException::NotRunning,
            3 => crate::api::error::NodeException::OnchainTxCreationFailed,
            4 => crate::api::error::NodeException::ConnectionFailed,
            5 => crate::api::error::NodeException::InvoiceCreationFailed,
            6 => crate::api::error::NodeException::PaymentSendingFailed,
            7 => crate::api::error::NodeException::ProbeSendingFailed,
            8 => crate::api::error::NodeException::ChannelCreationFailed,
            9 => crate::api::error::NodeException::ChannelClosingFailed,
            10 => crate::api::error::NodeException::ChannelConfigUpdateFailed,
            11 => crate::api::error::NodeException::PersistenceFailed,
            12 => crate::api::error::NodeException::WalletOperationFailed,
            13 => crate::api::error::NodeException::OnchainTxSigningFailed,
            14 => crate::api::error::NodeException::MessageSigningFailed,
            15 => crate::api::error::NodeException::TxSyncFailed,
            16 => crate::api::error::NodeException::GossipUpdateFailed,
            17 => crate::api::error::NodeException::InvalidAddress,
            18 => crate::api::error::NodeException::InvalidSocketAddress,
            19 => crate::api::error::NodeException::InvalidPublicKey,
            20 => crate::api::error::NodeException::InvalidSecretKey,
            21 => crate::api::error::NodeException::InvalidPaymentHash,
            22 => crate::api::error::NodeException::InvalidPaymentPreimage,
            23 => crate::api::error::NodeException::InvalidPaymentSecret,
            24 => crate::api::error::NodeException::InvalidAmount,
            25 => crate::api::error::NodeException::InvalidInvoice,
            26 => crate::api::error::NodeException::InvalidChannelId,
            27 => crate::api::error::NodeException::InvalidNetwork,
            28 => crate::api::error::NodeException::DuplicatePayment,
            29 => crate::api::error::NodeException::InsufficientFunds,
            30 => crate::api::error::NodeException::FeerateEstimationUpdateFailed,
            31 => crate::api::error::NodeException::LiquidityRequestFailed,
            32 => crate::api::error::NodeException::LiquiditySourceUnavailable,
            33 => crate::api::error::NodeException::LiquidityFeeTooHigh,
            34 => crate::api::error::NodeException::InvalidPaymentId,
            35 => crate::api::error::NodeException::DecodeError,
            _ => unreachable!("Invalid variant for NodeException: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::NodeStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_isRunning = <bool>::sse_decode(deserializer);
        let mut var_isListening = <bool>::sse_decode(deserializer);
        let mut var_currentBestBlock = <crate::api::types::BestBlock>::sse_decode(deserializer);
        let mut var_latestWalletSyncTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestOnchainWalletSyncTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestFeeRateCacheUpdateTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestRgsSnapshotTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestNodeAnnouncementBroadcastTimestamp =
            <Option<u64>>::sse_decode(deserializer);
        return crate::api::types::NodeStatus {
            is_running: var_isRunning,
            is_listening: var_isListening,
            current_best_block: var_currentBestBlock,
            latest_wallet_sync_timestamp: var_latestWalletSyncTimestamp,
            latest_onchain_wallet_sync_timestamp: var_latestOnchainWalletSyncTimestamp,
            latest_fee_rate_cache_update_timestamp: var_latestFeeRateCacheUpdateTimestamp,
            latest_rgs_snapshot_timestamp: var_latestRgsSnapshotTimestamp,
            latest_node_announcement_broadcast_timestamp:
                var_latestNodeAnnouncementBroadcastTimestamp,
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::ChainDataSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::ChainDataSourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::ChannelConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::ChannelConfig>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::ChannelId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::ChannelId>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::ClosureReason> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::ClosureReason>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::EntropySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::EntropySourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::Event> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::Event>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::GossipSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::GossipSourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::LiquiditySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::LiquiditySourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::MaxDustHTLCExposure> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::MaxDustHTLCExposure>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::OutPoint>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentDetails>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentFailureReason> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentFailureReason>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentId>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentPreimage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentPreimage>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentSecret> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentSecret>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PublicKey>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u16>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::api::types::SocketAddress>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::api::types::SocketAddress>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::types::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <crate::api::types::Txid>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        return crate::api::types::OutPoint {
            txid: var_txid,
            vout: var_vout,
        };
    }
}

impl SseDecode for crate::api::types::PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <crate::api::types::PaymentId>::sse_decode(deserializer);
        let mut var_kind = <crate::api::types::PaymentKind>::sse_decode(deserializer);
        let mut var_amountMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_direction = <crate::api::types::PaymentDirection>::sse_decode(deserializer);
        let mut var_status = <crate::api::types::PaymentStatus>::sse_decode(deserializer);
        return crate::api::types::PaymentDetails {
            id: var_id,
            kind: var_kind,
            amount_msat: var_amountMsat,
            direction: var_direction,
            status: var_status,
        };
    }
}

impl SseDecode for crate::api::types::PaymentDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::PaymentDirection::Inbound,
            1 => crate::api::types::PaymentDirection::Outbound,
            _ => unreachable!("Invalid variant for PaymentDirection: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::PaymentFailureReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::PaymentFailureReason::RecipientRejected,
            1 => crate::api::types::PaymentFailureReason::UserAbandoned,
            2 => crate::api::types::PaymentFailureReason::RetriesExhausted,
            3 => crate::api::types::PaymentFailureReason::PaymentExpired,
            4 => crate::api::types::PaymentFailureReason::RouteNotFound,
            5 => crate::api::types::PaymentFailureReason::UnexpectedError,
            _ => unreachable!("Invalid variant for PaymentFailureReason: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::PaymentHash {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::PaymentHash { data: var_data };
    }
}

impl SseDecode for crate::api::types::PaymentId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::PaymentId(var_field0);
    }
}

impl SseDecode for crate::api::types::PaymentKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::types::PaymentKind::Onchain;
            }
            1 => {
                let mut var_hash = <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_preimage =
                    <Option<crate::api::types::PaymentPreimage>>::sse_decode(deserializer);
                let mut var_secret =
                    <Option<crate::api::types::PaymentSecret>>::sse_decode(deserializer);
                return crate::api::types::PaymentKind::Bolt11 {
                    hash: var_hash,
                    preimage: var_preimage,
                    secret: var_secret,
                };
            }
            2 => {
                let mut var_hash = <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_preimage =
                    <Option<crate::api::types::PaymentPreimage>>::sse_decode(deserializer);
                let mut var_secret =
                    <Option<crate::api::types::PaymentSecret>>::sse_decode(deserializer);
                let mut var_lspFeeLimits =
                    <crate::api::types::LSPFeeLimits>::sse_decode(deserializer);
                return crate::api::types::PaymentKind::Bolt11Jit {
                    hash: var_hash,
                    preimage: var_preimage,
                    secret: var_secret,
                    lsp_fee_limits: var_lspFeeLimits,
                };
            }
            3 => {
                let mut var_hash = <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_preimage =
                    <Option<crate::api::types::PaymentPreimage>>::sse_decode(deserializer);
                return crate::api::types::PaymentKind::Spontaneous {
                    hash: var_hash,
                    preimage: var_preimage,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::PaymentPreimage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::PaymentPreimage { data: var_data };
    }
}

impl SseDecode for crate::api::types::PaymentSecret {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::PaymentSecret { data: var_data };
    }
}

impl SseDecode for crate::api::types::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::PaymentStatus::Pending,
            1 => crate::api::types::PaymentStatus::Succeeded,
            2 => crate::api::types::PaymentStatus::Failed,
            _ => unreachable!("Invalid variant for PaymentStatus: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::PeerDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nodeId = <crate::api::types::PublicKey>::sse_decode(deserializer);
        let mut var_address = <crate::api::types::SocketAddress>::sse_decode(deserializer);
        let mut var_isConnected = <bool>::sse_decode(deserializer);
        return crate::api::types::PeerDetails {
            node_id: var_nodeId,
            address: var_address,
            is_connected: var_isConnected,
        };
    }
}

impl SseDecode for crate::api::types::PendingSweepBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_channelId =
                    <Option<crate::api::types::ChannelId>>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return crate::api::types::PendingSweepBalance::PendingBroadcast {
                    channel_id: var_channelId,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            1 => {
                let mut var_channelId =
                    <Option<crate::api::types::ChannelId>>::sse_decode(deserializer);
                let mut var_latestBroadcastHeight = <u32>::sse_decode(deserializer);
                let mut var_latestSpendingTxid =
                    <crate::api::types::Txid>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return crate::api::types::PendingSweepBalance::BroadcastAwaitingConfirmation {
                    channel_id: var_channelId,
                    latest_broadcast_height: var_latestBroadcastHeight,
                    latest_spending_txid: var_latestSpendingTxid,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            2 => {
                let mut var_channelId =
                    <Option<crate::api::types::ChannelId>>::sse_decode(deserializer);
                let mut var_latestSpendingTxid =
                    <crate::api::types::Txid>::sse_decode(deserializer);
                let mut var_confirmationHash = <String>::sse_decode(deserializer);
                let mut var_confirmationHeight = <u32>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return crate::api::types::PendingSweepBalance::AwaitingThresholdConfirmations {
                    channel_id: var_channelId,
                    latest_spending_txid: var_latestSpendingTxid,
                    confirmation_hash: var_confirmationHash,
                    confirmation_height: var_confirmationHeight,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::PublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hex = <String>::sse_decode(deserializer);
        return crate::api::types::PublicKey { hex: var_hex };
    }
}

impl SseDecode
    for (
        crate::api::types::SocketAddress,
        crate::api::types::PublicKey,
        Option<String>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <crate::api::types::SocketAddress>::sse_decode(deserializer);
        let mut var_field1 = <crate::api::types::PublicKey>::sse_decode(deserializer);
        let mut var_field2 = <Option<String>>::sse_decode(deserializer);
        return (var_field0, var_field1, var_field2);
    }
}

impl SseDecode for crate::api::types::SocketAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_addr = <[u8; 4]>::sse_decode(deserializer);
                let mut var_port = <u16>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::TcpIpV4 {
                    addr: var_addr,
                    port: var_port,
                };
            }
            1 => {
                let mut var_addr = <[u8; 16]>::sse_decode(deserializer);
                let mut var_port = <u16>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::TcpIpV6 {
                    addr: var_addr,
                    port: var_port,
                };
            }
            2 => {
                let mut var_field0 = <[u8; 12]>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::OnionV2(var_field0);
            }
            3 => {
                let mut var_ed25519Pubkey = <[u8; 32]>::sse_decode(deserializer);
                let mut var_checksum = <u16>::sse_decode(deserializer);
                let mut var_version = <u8>::sse_decode(deserializer);
                let mut var_port = <u16>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::OnionV3 {
                    ed25519_pubkey: var_ed25519Pubkey,
                    checksum: var_checksum,
                    version: var_version,
                    port: var_port,
                };
            }
            4 => {
                let mut var_addr = <String>::sse_decode(deserializer);
                let mut var_port = <u16>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::Hostname {
                    addr: var_addr,
                    port: var_port,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Txid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hash = <String>::sse_decode(deserializer);
        return crate::api::types::Txid { hash: var_hash };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for [u8; 12] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 16] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 32] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 4] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 64] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::api::types::UserChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::types::UserChannelId { data: var_data };
    }
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<NodeBuilder> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<NodeBuilder> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<NodeBuilder>> for NodeBuilder {
    fn into_into_dart(self) -> FrbWrapper<NodeBuilder> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Address {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.s.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Address {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Address> for crate::api::types::Address {
    fn into_into_dart(self) -> crate::api::types::Address {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BalanceDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.total_onchain_balance_sats.into_into_dart().into_dart(),
            self.spendable_onchain_balance_sats
                .into_into_dart()
                .into_dart(),
            self.total_lightning_balance_sats
                .into_into_dart()
                .into_dart(),
            self.lightning_balances.into_into_dart().into_dart(),
            self.pending_balances_from_channel_closures
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::BalanceDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BalanceDetails>
    for crate::api::types::BalanceDetails
{
    fn into_into_dart(self) -> crate::api::types::BalanceDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BestBlock {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.block_hash.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::BestBlock {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BestBlock>
    for crate::api::types::BestBlock
{
    fn into_into_dart(self) -> crate::api::types::BestBlock {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Bolt11Invoice {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.signed_raw_invoice.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::Bolt11Invoice
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Bolt11Invoice>
    for crate::api::types::Bolt11Invoice
{
    fn into_into_dart(self) -> crate::api::types::Bolt11Invoice {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::BuilderException {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::SocketAddressParseError => 0.into_dart(),
            Self::InvalidSeedBytes => 1.into_dart(),
            Self::InvalidSeedFile => 2.into_dart(),
            Self::InvalidSystemTime => 3.into_dart(),
            Self::InvalidChannelMonitor => 4.into_dart(),
            Self::InvalidListeningAddress => 5.into_dart(),
            Self::ReadFailed => 6.into_dart(),
            Self::WriteFailed => 7.into_dart(),
            Self::StoragePathAccessFailed => 8.into_dart(),
            Self::KVStoreSetupFailed => 9.into_dart(),
            Self::WalletSetupFailed => 10.into_dart(),
            Self::LoggerSetupFailed => 11.into_dart(),
            Self::InvalidPublicKey => 12.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::BuilderException
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::BuilderException>
    for crate::api::error::BuilderException
{
    fn into_into_dart(self) -> crate::api::error::BuilderException {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChainDataSourceConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::ChainDataSourceConfig::Esplora(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChainDataSourceConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChainDataSourceConfig>
    for crate::api::types::ChainDataSourceConfig
{
    fn into_into_dart(self) -> crate::api::types::ChainDataSourceConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChannelConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.forwarding_fee_proportional_millionths
                .into_into_dart()
                .into_dart(),
            self.forwarding_fee_base_msat.into_into_dart().into_dart(),
            self.cltv_expiry_delta.into_into_dart().into_dart(),
            self.max_dust_htlc_exposure.into_into_dart().into_dart(),
            self.force_close_avoidance_max_fee_satoshis
                .into_into_dart()
                .into_dart(),
            self.accept_underpaying_htlcs.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChannelConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChannelConfig>
    for crate::api::types::ChannelConfig
{
    fn into_into_dart(self) -> crate::api::types::ChannelConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChannelDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.channel_id.into_into_dart().into_dart(),
            self.counterparty_node_id.into_into_dart().into_dart(),
            self.funding_txo.into_into_dart().into_dart(),
            self.channel_value_sats.into_into_dart().into_dart(),
            self.unspendable_punishment_reserve
                .into_into_dart()
                .into_dart(),
            self.user_channel_id.into_into_dart().into_dart(),
            self.feerate_sat_per_1000_weight
                .into_into_dart()
                .into_dart(),
            self.outbound_capacity_msat.into_into_dart().into_dart(),
            self.inbound_capacity_msat.into_into_dart().into_dart(),
            self.confirmations_required.into_into_dart().into_dart(),
            self.confirmations.into_into_dart().into_dart(),
            self.is_outbound.into_into_dart().into_dart(),
            self.is_channel_ready.into_into_dart().into_dart(),
            self.is_usable.into_into_dart().into_dart(),
            self.is_public.into_into_dart().into_dart(),
            self.cltv_expiry_delta.into_into_dart().into_dart(),
            self.counterparty_unspendable_punishment_reserve
                .into_into_dart()
                .into_dart(),
            self.counterparty_outbound_htlc_minimum_msat
                .into_into_dart()
                .into_dart(),
            self.counterparty_outbound_htlc_maximum_msat
                .into_into_dart()
                .into_dart(),
            self.counterparty_forwarding_info_fee_base_msat
                .into_into_dart()
                .into_dart(),
            self.counterparty_forwarding_info_fee_proportional_millionths
                .into_into_dart()
                .into_dart(),
            self.counterparty_forwarding_info_cltv_expiry_delta
                .into_into_dart()
                .into_dart(),
            self.next_outbound_htlc_limit_msat
                .into_into_dart()
                .into_dart(),
            self.next_outbound_htlc_minimum_msat
                .into_into_dart()
                .into_dart(),
            self.force_close_spend_delay.into_into_dart().into_dart(),
            self.inbound_htlc_minimum_msat.into_into_dart().into_dart(),
            self.inbound_htlc_maximum_msat.into_into_dart().into_dart(),
            self.config.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChannelDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChannelDetails>
    for crate::api::types::ChannelDetails
{
    fn into_into_dart(self) -> crate::api::types::ChannelDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChannelId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::ChannelId {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChannelId>
    for crate::api::types::ChannelId
{
    fn into_into_dart(self) -> crate::api::types::ChannelId {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ClosureReason {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::ClosureReason::CounterpartyForceClosed { peer_msg } => {
                [0.into_dart(), peer_msg.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::HolderForceClosed => [1.into_dart()].into_dart(),
            crate::api::types::ClosureReason::LegacyCooperativeClosure => {
                [2.into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::CounterpartyInitiatedCooperativeClosure => {
                [3.into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::LocallyInitiatedCooperativeClosure => {
                [4.into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::CommitmentTxConfirmed => [5.into_dart()].into_dart(),
            crate::api::types::ClosureReason::FundingTimedOut => [6.into_dart()].into_dart(),
            crate::api::types::ClosureReason::ProcessingError { err } => {
                [7.into_dart(), err.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::DisconnectedPeer => [8.into_dart()].into_dart(),
            crate::api::types::ClosureReason::OutdatedChannelManager => [9.into_dart()].into_dart(),
            crate::api::types::ClosureReason::CounterpartyCoopClosedUnfundedChannel => {
                [10.into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::FundingBatchClosure => [11.into_dart()].into_dart(),
            crate::api::types::ClosureReason::HTLCsTimedOut => [12.into_dart()].into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ClosureReason
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ClosureReason>
    for crate::api::types::ClosureReason
{
    fn into_into_dart(self) -> crate::api::types::ClosureReason {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Config {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.storage_dir_path.into_into_dart().into_dart(),
            self.log_dir_path.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.listening_addresses.into_into_dart().into_dart(),
            self.default_cltv_expiry_delta.into_into_dart().into_dart(),
            self.onchain_wallet_sync_interval_secs
                .into_into_dart()
                .into_dart(),
            self.wallet_sync_interval_secs.into_into_dart().into_dart(),
            self.fee_rate_cache_update_interval_secs
                .into_into_dart()
                .into_dart(),
            self.trusted_peers_0conf.into_into_dart().into_dart(),
            self.probing_liquidity_limit_multiplier
                .into_into_dart()
                .into_dart(),
            self.log_level.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Config {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Config> for crate::api::types::Config {
    fn into_into_dart(self) -> crate::api::types::Config {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::EntropySourceConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::EntropySourceConfig::SeedFile(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::EntropySourceConfig::SeedBytes(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::EntropySourceConfig::Bip39Mnemonic {
                mnemonic,
                passphrase,
            } => [
                2.into_dart(),
                mnemonic.into_into_dart().into_dart(),
                passphrase.into_into_dart().into_dart(),
            ]
            .into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::EntropySourceConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::EntropySourceConfig>
    for crate::api::types::EntropySourceConfig
{
    fn into_into_dart(self) -> crate::api::types::EntropySourceConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Event {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::Event::PaymentSuccessful {
                payment_id,
                payment_hash,
                fee_paid_msat,
            } => [
                0.into_dart(),
                payment_id.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                fee_paid_msat.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::PaymentFailed {
                payment_id,
                payment_hash,
                reason,
            } => [
                1.into_dart(),
                payment_id.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                reason.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::PaymentReceived {
                payment_id,
                payment_hash,
                amount_msat,
            } => [
                2.into_dart(),
                payment_id.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                amount_msat.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::ChannelPending {
                channel_id,
                user_channel_id,
                former_temporary_channel_id,
                counterparty_node_id,
                funding_txo,
            } => [
                3.into_dart(),
                channel_id.into_into_dart().into_dart(),
                user_channel_id.into_into_dart().into_dart(),
                former_temporary_channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                funding_txo.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::ChannelReady {
                channel_id,
                user_channel_id,
                counterparty_node_id,
            } => [
                4.into_dart(),
                channel_id.into_into_dart().into_dart(),
                user_channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::ChannelClosed {
                channel_id,
                user_channel_id,
                counterparty_node_id,
                reason,
            } => [
                5.into_dart(),
                channel_id.into_into_dart().into_dart(),
                user_channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                reason.into_into_dart().into_dart(),
            ]
            .into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Event {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Event> for crate::api::types::Event {
    fn into_into_dart(self) -> crate::api::types::Event {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::GossipSourceConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::GossipSourceConfig::P2PNetwork => [0.into_dart()].into_dart(),
            crate::api::types::GossipSourceConfig::RapidGossipSync(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::GossipSourceConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::GossipSourceConfig>
    for crate::api::types::GossipSourceConfig
{
    fn into_into_dart(self) -> crate::api::types::GossipSourceConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::node::LdkBolt11Payment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::node::LdkBolt11Payment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::node::LdkBolt11Payment>
    for crate::api::node::LdkBolt11Payment
{
    fn into_into_dart(self) -> crate::api::node::LdkBolt11Payment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::node::LdkMnemonic {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.seed_phrase.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::node::LdkMnemonic {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::node::LdkMnemonic>
    for crate::api::node::LdkMnemonic
{
    fn into_into_dart(self) -> crate::api::node::LdkMnemonic {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::node::LdkNode {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::node::LdkNode {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::node::LdkNode> for crate::api::node::LdkNode {
    fn into_into_dart(self) -> crate::api::node::LdkNode {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::node::LdkOnChainPayment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::node::LdkOnChainPayment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::node::LdkOnChainPayment>
    for crate::api::node::LdkOnChainPayment
{
    fn into_into_dart(self) -> crate::api::node::LdkOnChainPayment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::node::LdkSpontaneousPayment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ptr.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::node::LdkSpontaneousPayment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::node::LdkSpontaneousPayment>
    for crate::api::node::LdkSpontaneousPayment
{
    fn into_into_dart(self) -> crate::api::node::LdkSpontaneousPayment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LightningBalance {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::LightningBalance::ClaimableOnChannelClose {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
            } => [
                0.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::LightningBalance::ClaimableAwaitingConfirmations {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                confirmation_height,
            } => [
                1.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                confirmation_height.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::LightningBalance::ContentiousClaimable {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                timeout_height,
                payment_hash,
                payment_preimage,
            } => [
                2.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                timeout_height.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                payment_preimage.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::LightningBalance::MaybeTimeoutClaimableHTLC {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                claimable_height,
                payment_hash,
            } => [
                3.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                claimable_height.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::LightningBalance::MaybePreimageClaimableHTLC {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                expiry_height,
                payment_hash,
            } => [
                4.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                expiry_height.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::LightningBalance::CounterpartyRevokedOutputClaimable {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
            } => [
                5.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::LightningBalance
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LightningBalance>
    for crate::api::types::LightningBalance
{
    fn into_into_dart(self) -> crate::api::types::LightningBalance {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LiquiditySourceConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.lsps2_service.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::LiquiditySourceConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LiquiditySourceConfig>
    for crate::api::types::LiquiditySourceConfig
{
    fn into_into_dart(self) -> crate::api::types::LiquiditySourceConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LogLevel {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Gossip => 0.into_dart(),
            Self::Trace => 1.into_dart(),
            Self::Debug => 2.into_dart(),
            Self::Info => 3.into_dart(),
            Self::Warn => 4.into_dart(),
            Self::Error => 5.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::LogLevel {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LogLevel>
    for crate::api::types::LogLevel
{
    fn into_into_dart(self) -> crate::api::types::LogLevel {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LSPFeeLimits {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.max_total_opening_fee_msat.into_into_dart().into_dart(),
            self.max_proportional_opening_fee_ppm_msat
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::LSPFeeLimits
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LSPFeeLimits>
    for crate::api::types::LSPFeeLimits
{
    fn into_into_dart(self) -> crate::api::types::LSPFeeLimits {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::MaxDustHTLCExposure {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::MaxDustHTLCExposure::FixedLimitMsat(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::MaxDustHTLCExposure::FeeRateMultiplier(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::MaxDustHTLCExposure
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::MaxDustHTLCExposure>
    for crate::api::types::MaxDustHTLCExposure
{
    fn into_into_dart(self) -> crate::api::types::MaxDustHTLCExposure {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Network {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Bitcoin => 0.into_dart(),
            Self::Testnet => 1.into_dart(),
            Self::Signet => 2.into_dart(),
            Self::Regtest => 3.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Network {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Network> for crate::api::types::Network {
    fn into_into_dart(self) -> crate::api::types::Network {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::NodeException {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::InvalidTxid => 0.into_dart(),
            Self::AlreadyRunning => 1.into_dart(),
            Self::NotRunning => 2.into_dart(),
            Self::OnchainTxCreationFailed => 3.into_dart(),
            Self::ConnectionFailed => 4.into_dart(),
            Self::InvoiceCreationFailed => 5.into_dart(),
            Self::PaymentSendingFailed => 6.into_dart(),
            Self::ProbeSendingFailed => 7.into_dart(),
            Self::ChannelCreationFailed => 8.into_dart(),
            Self::ChannelClosingFailed => 9.into_dart(),
            Self::ChannelConfigUpdateFailed => 10.into_dart(),
            Self::PersistenceFailed => 11.into_dart(),
            Self::WalletOperationFailed => 12.into_dart(),
            Self::OnchainTxSigningFailed => 13.into_dart(),
            Self::MessageSigningFailed => 14.into_dart(),
            Self::TxSyncFailed => 15.into_dart(),
            Self::GossipUpdateFailed => 16.into_dart(),
            Self::InvalidAddress => 17.into_dart(),
            Self::InvalidSocketAddress => 18.into_dart(),
            Self::InvalidPublicKey => 19.into_dart(),
            Self::InvalidSecretKey => 20.into_dart(),
            Self::InvalidPaymentHash => 21.into_dart(),
            Self::InvalidPaymentPreimage => 22.into_dart(),
            Self::InvalidPaymentSecret => 23.into_dart(),
            Self::InvalidAmount => 24.into_dart(),
            Self::InvalidInvoice => 25.into_dart(),
            Self::InvalidChannelId => 26.into_dart(),
            Self::InvalidNetwork => 27.into_dart(),
            Self::DuplicatePayment => 28.into_dart(),
            Self::InsufficientFunds => 29.into_dart(),
            Self::FeerateEstimationUpdateFailed => 30.into_dart(),
            Self::LiquidityRequestFailed => 31.into_dart(),
            Self::LiquiditySourceUnavailable => 32.into_dart(),
            Self::LiquidityFeeTooHigh => 33.into_dart(),
            Self::InvalidPaymentId => 34.into_dart(),
            Self::DecodeError => 35.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::NodeException
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::NodeException>
    for crate::api::error::NodeException
{
    fn into_into_dart(self) -> crate::api::error::NodeException {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::NodeStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.is_running.into_into_dart().into_dart(),
            self.is_listening.into_into_dart().into_dart(),
            self.current_best_block.into_into_dart().into_dart(),
            self.latest_wallet_sync_timestamp
                .into_into_dart()
                .into_dart(),
            self.latest_onchain_wallet_sync_timestamp
                .into_into_dart()
                .into_dart(),
            self.latest_fee_rate_cache_update_timestamp
                .into_into_dart()
                .into_dart(),
            self.latest_rgs_snapshot_timestamp
                .into_into_dart()
                .into_dart(),
            self.latest_node_announcement_broadcast_timestamp
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::NodeStatus {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::NodeStatus>
    for crate::api::types::NodeStatus
{
    fn into_into_dart(self) -> crate::api::types::NodeStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::OutPoint {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.vout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::OutPoint {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::OutPoint>
    for crate::api::types::OutPoint
{
    fn into_into_dart(self) -> crate::api::types::OutPoint {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.amount_msat.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentDetails>
    for crate::api::types::PaymentDetails
{
    fn into_into_dart(self) -> crate::api::types::PaymentDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentDirection {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Inbound => 0.into_dart(),
            Self::Outbound => 1.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentDirection
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentDirection>
    for crate::api::types::PaymentDirection
{
    fn into_into_dart(self) -> crate::api::types::PaymentDirection {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentFailureReason {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::RecipientRejected => 0.into_dart(),
            Self::UserAbandoned => 1.into_dart(),
            Self::RetriesExhausted => 2.into_dart(),
            Self::PaymentExpired => 3.into_dart(),
            Self::RouteNotFound => 4.into_dart(),
            Self::UnexpectedError => 5.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentFailureReason
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentFailureReason>
    for crate::api::types::PaymentFailureReason
{
    fn into_into_dart(self) -> crate::api::types::PaymentFailureReason {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentHash {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentHash
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentHash>
    for crate::api::types::PaymentHash
{
    fn into_into_dart(self) -> crate::api::types::PaymentHash {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::PaymentId {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentId>
    for crate::api::types::PaymentId
{
    fn into_into_dart(self) -> crate::api::types::PaymentId {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentKind {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::PaymentKind::Onchain => [0.into_dart()].into_dart(),
            crate::api::types::PaymentKind::Bolt11 {
                hash,
                preimage,
                secret,
            } => [
                1.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
                secret.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::PaymentKind::Bolt11Jit {
                hash,
                preimage,
                secret,
                lsp_fee_limits,
            } => [
                2.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
                secret.into_into_dart().into_dart(),
                lsp_fee_limits.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::PaymentKind::Spontaneous { hash, preimage } => [
                3.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
            ]
            .into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentKind
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentKind>
    for crate::api::types::PaymentKind
{
    fn into_into_dart(self) -> crate::api::types::PaymentKind {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentPreimage {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentPreimage
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentPreimage>
    for crate::api::types::PaymentPreimage
{
    fn into_into_dart(self) -> crate::api::types::PaymentPreimage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentSecret {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentSecret
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentSecret>
    for crate::api::types::PaymentSecret
{
    fn into_into_dart(self) -> crate::api::types::PaymentSecret {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Pending => 0.into_dart(),
            Self::Succeeded => 1.into_dart(),
            Self::Failed => 2.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentStatus
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentStatus>
    for crate::api::types::PaymentStatus
{
    fn into_into_dart(self) -> crate::api::types::PaymentStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PeerDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.node_id.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
            self.is_connected.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PeerDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PeerDetails>
    for crate::api::types::PeerDetails
{
    fn into_into_dart(self) -> crate::api::types::PeerDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PendingSweepBalance {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::PendingSweepBalance::PendingBroadcast {
                channel_id,
                amount_satoshis,
            } => [
                0.into_dart(),
                channel_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::PendingSweepBalance::BroadcastAwaitingConfirmation {
                channel_id,
                latest_broadcast_height,
                latest_spending_txid,
                amount_satoshis,
            } => [
                1.into_dart(),
                channel_id.into_into_dart().into_dart(),
                latest_broadcast_height.into_into_dart().into_dart(),
                latest_spending_txid.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::PendingSweepBalance::AwaitingThresholdConfirmations {
                channel_id,
                latest_spending_txid,
                confirmation_hash,
                confirmation_height,
                amount_satoshis,
            } => [
                2.into_dart(),
                channel_id.into_into_dart().into_dart(),
                latest_spending_txid.into_into_dart().into_dart(),
                confirmation_hash.into_into_dart().into_dart(),
                confirmation_height.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PendingSweepBalance
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PendingSweepBalance>
    for crate::api::types::PendingSweepBalance
{
    fn into_into_dart(self) -> crate::api::types::PendingSweepBalance {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PublicKey {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.hex.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::PublicKey {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PublicKey>
    for crate::api::types::PublicKey
{
    fn into_into_dart(self) -> crate::api::types::PublicKey {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SocketAddress {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::SocketAddress::TcpIpV4 { addr, port } => [
                0.into_dart(),
                addr.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::SocketAddress::TcpIpV6 { addr, port } => [
                1.into_dart(),
                addr.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::SocketAddress::OnionV2(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::SocketAddress::OnionV3 {
                ed25519_pubkey,
                checksum,
                version,
                port,
            } => [
                3.into_dart(),
                ed25519_pubkey.into_into_dart().into_dart(),
                checksum.into_into_dart().into_dart(),
                version.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::SocketAddress::Hostname { addr, port } => [
                4.into_dart(),
                addr.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
            ]
            .into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::SocketAddress
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SocketAddress>
    for crate::api::types::SocketAddress
{
    fn into_into_dart(self) -> crate::api::types::SocketAddress {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Txid {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.hash.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Txid {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Txid> for crate::api::types::Txid {
    fn into_into_dart(self) -> crate::api::types::Txid {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::UserChannelId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::UserChannelId
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::UserChannelId>
    for crate::api::types::UserChannelId
{
    fn into_into_dart(self) -> crate::api::types::UserChannelId {
        self
    }
}

impl SseEncode for NodeBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<NodeBuilder>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for RustOpaqueNom<Node> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<NodeBuilder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<ldk_node::payment::Bolt11Payment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<ldk_node::payment::OnchainPayment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<ldk_node::payment::SpontaneousPayment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::types::Address {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.s, serializer);
    }
}

impl SseEncode for crate::api::types::BalanceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.total_onchain_balance_sats, serializer);
        <u64>::sse_encode(self.spendable_onchain_balance_sats, serializer);
        <u64>::sse_encode(self.total_lightning_balance_sats, serializer);
        <Vec<crate::api::types::LightningBalance>>::sse_encode(self.lightning_balances, serializer);
        <Vec<crate::api::types::PendingSweepBalance>>::sse_encode(
            self.pending_balances_from_channel_closures,
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::BestBlock {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.block_hash, serializer);
        <u32>::sse_encode(self.height, serializer);
    }
}

impl SseEncode for crate::api::types::Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.signed_raw_invoice, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::error::BuilderException {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::error::BuilderException::SocketAddressParseError => 0,
                crate::api::error::BuilderException::InvalidSeedBytes => 1,
                crate::api::error::BuilderException::InvalidSeedFile => 2,
                crate::api::error::BuilderException::InvalidSystemTime => 3,
                crate::api::error::BuilderException::InvalidChannelMonitor => 4,
                crate::api::error::BuilderException::InvalidListeningAddress => 5,
                crate::api::error::BuilderException::ReadFailed => 6,
                crate::api::error::BuilderException::WriteFailed => 7,
                crate::api::error::BuilderException::StoragePathAccessFailed => 8,
                crate::api::error::BuilderException::KVStoreSetupFailed => 9,
                crate::api::error::BuilderException::WalletSetupFailed => 10,
                crate::api::error::BuilderException::LoggerSetupFailed => 11,
                crate::api::error::BuilderException::InvalidPublicKey => 12,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::ChainDataSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::ChainDataSourceConfig::Esplora(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
        }
    }
}

impl SseEncode for crate::api::types::ChannelConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.forwarding_fee_proportional_millionths, serializer);
        <u32>::sse_encode(self.forwarding_fee_base_msat, serializer);
        <u16>::sse_encode(self.cltv_expiry_delta, serializer);
        <Option<crate::api::types::MaxDustHTLCExposure>>::sse_encode(
            self.max_dust_htlc_exposure,
            serializer,
        );
        <u64>::sse_encode(self.force_close_avoidance_max_fee_satoshis, serializer);
        <bool>::sse_encode(self.accept_underpaying_htlcs, serializer);
    }
}

impl SseEncode for crate::api::types::ChannelDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::ChannelId>::sse_encode(self.channel_id, serializer);
        <crate::api::types::PublicKey>::sse_encode(self.counterparty_node_id, serializer);
        <Option<crate::api::types::OutPoint>>::sse_encode(self.funding_txo, serializer);
        <u64>::sse_encode(self.channel_value_sats, serializer);
        <Option<u64>>::sse_encode(self.unspendable_punishment_reserve, serializer);
        <crate::api::types::UserChannelId>::sse_encode(self.user_channel_id, serializer);
        <u32>::sse_encode(self.feerate_sat_per_1000_weight, serializer);
        <u64>::sse_encode(self.outbound_capacity_msat, serializer);
        <u64>::sse_encode(self.inbound_capacity_msat, serializer);
        <Option<u32>>::sse_encode(self.confirmations_required, serializer);
        <Option<u32>>::sse_encode(self.confirmations, serializer);
        <bool>::sse_encode(self.is_outbound, serializer);
        <bool>::sse_encode(self.is_channel_ready, serializer);
        <bool>::sse_encode(self.is_usable, serializer);
        <bool>::sse_encode(self.is_public, serializer);
        <Option<u16>>::sse_encode(self.cltv_expiry_delta, serializer);
        <u64>::sse_encode(self.counterparty_unspendable_punishment_reserve, serializer);
        <Option<u64>>::sse_encode(self.counterparty_outbound_htlc_minimum_msat, serializer);
        <Option<u64>>::sse_encode(self.counterparty_outbound_htlc_maximum_msat, serializer);
        <Option<u32>>::sse_encode(self.counterparty_forwarding_info_fee_base_msat, serializer);
        <Option<u32>>::sse_encode(
            self.counterparty_forwarding_info_fee_proportional_millionths,
            serializer,
        );
        <Option<u16>>::sse_encode(
            self.counterparty_forwarding_info_cltv_expiry_delta,
            serializer,
        );
        <u64>::sse_encode(self.next_outbound_htlc_limit_msat, serializer);
        <u64>::sse_encode(self.next_outbound_htlc_minimum_msat, serializer);
        <Option<u16>>::sse_encode(self.force_close_spend_delay, serializer);
        <u64>::sse_encode(self.inbound_htlc_minimum_msat, serializer);
        <Option<u64>>::sse_encode(self.inbound_htlc_maximum_msat, serializer);
        <crate::api::types::ChannelConfig>::sse_encode(self.config, serializer);
    }
}

impl SseEncode for crate::api::types::ChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::api::types::ClosureReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::ClosureReason::CounterpartyForceClosed { peer_msg } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(peer_msg, serializer);
            }
            crate::api::types::ClosureReason::HolderForceClosed => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::types::ClosureReason::LegacyCooperativeClosure => {
                <i32>::sse_encode(2, serializer);
            }
            crate::api::types::ClosureReason::CounterpartyInitiatedCooperativeClosure => {
                <i32>::sse_encode(3, serializer);
            }
            crate::api::types::ClosureReason::LocallyInitiatedCooperativeClosure => {
                <i32>::sse_encode(4, serializer);
            }
            crate::api::types::ClosureReason::CommitmentTxConfirmed => {
                <i32>::sse_encode(5, serializer);
            }
            crate::api::types::ClosureReason::FundingTimedOut => {
                <i32>::sse_encode(6, serializer);
            }
            crate::api::types::ClosureReason::ProcessingError { err } => {
                <i32>::sse_encode(7, serializer);
                <String>::sse_encode(err, serializer);
            }
            crate::api::types::ClosureReason::DisconnectedPeer => {
                <i32>::sse_encode(8, serializer);
            }
            crate::api::types::ClosureReason::OutdatedChannelManager => {
                <i32>::sse_encode(9, serializer);
            }
            crate::api::types::ClosureReason::CounterpartyCoopClosedUnfundedChannel => {
                <i32>::sse_encode(10, serializer);
            }
            crate::api::types::ClosureReason::FundingBatchClosure => {
                <i32>::sse_encode(11, serializer);
            }
            crate::api::types::ClosureReason::HTLCsTimedOut => {
                <i32>::sse_encode(12, serializer);
            }
        }
    }
}

impl SseEncode for crate::api::types::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.storage_dir_path, serializer);
        <Option<String>>::sse_encode(self.log_dir_path, serializer);
        <crate::api::types::Network>::sse_encode(self.network, serializer);
        <Option<Vec<crate::api::types::SocketAddress>>>::sse_encode(
            self.listening_addresses,
            serializer,
        );
        <u32>::sse_encode(self.default_cltv_expiry_delta, serializer);
        <u64>::sse_encode(self.onchain_wallet_sync_interval_secs, serializer);
        <u64>::sse_encode(self.wallet_sync_interval_secs, serializer);
        <u64>::sse_encode(self.fee_rate_cache_update_interval_secs, serializer);
        <Vec<crate::api::types::PublicKey>>::sse_encode(self.trusted_peers_0conf, serializer);
        <u64>::sse_encode(self.probing_liquidity_limit_multiplier, serializer);
        <crate::api::types::LogLevel>::sse_encode(self.log_level, serializer);
    }
}

impl SseEncode for crate::api::types::EntropySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::EntropySourceConfig::SeedFile(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::types::EntropySourceConfig::SeedBytes(field0) => {
                <i32>::sse_encode(1, serializer);
                <[u8; 64]>::sse_encode(field0, serializer);
            }
            crate::api::types::EntropySourceConfig::Bip39Mnemonic {
                mnemonic,
                passphrase,
            } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::node::LdkMnemonic>::sse_encode(mnemonic, serializer);
                <Option<String>>::sse_encode(passphrase, serializer);
            }
        }
    }
}

impl SseEncode for crate::api::types::Event {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::Event::PaymentSuccessful {
                payment_id,
                payment_hash,
                fee_paid_msat,
            } => {
                <i32>::sse_encode(0, serializer);
                <Option<crate::api::types::PaymentId>>::sse_encode(payment_id, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
                <Option<u64>>::sse_encode(fee_paid_msat, serializer);
            }
            crate::api::types::Event::PaymentFailed {
                payment_id,
                payment_hash,
                reason,
            } => {
                <i32>::sse_encode(1, serializer);
                <Option<crate::api::types::PaymentId>>::sse_encode(payment_id, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
                <Option<crate::api::types::PaymentFailureReason>>::sse_encode(reason, serializer);
            }
            crate::api::types::Event::PaymentReceived {
                payment_id,
                payment_hash,
                amount_msat,
            } => {
                <i32>::sse_encode(2, serializer);
                <Option<crate::api::types::PaymentId>>::sse_encode(payment_id, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
                <u64>::sse_encode(amount_msat, serializer);
            }
            crate::api::types::Event::ChannelPending {
                channel_id,
                user_channel_id,
                former_temporary_channel_id,
                counterparty_node_id,
                funding_txo,
            } => {
                <i32>::sse_encode(3, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::UserChannelId>::sse_encode(user_channel_id, serializer);
                <crate::api::types::ChannelId>::sse_encode(former_temporary_channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <crate::api::types::OutPoint>::sse_encode(funding_txo, serializer);
            }
            crate::api::types::Event::ChannelReady {
                channel_id,
                user_channel_id,
                counterparty_node_id,
            } => {
                <i32>::sse_encode(4, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::UserChannelId>::sse_encode(user_channel_id, serializer);
                <Option<crate::api::types::PublicKey>>::sse_encode(
                    counterparty_node_id,
                    serializer,
                );
            }
            crate::api::types::Event::ChannelClosed {
                channel_id,
                user_channel_id,
                counterparty_node_id,
                reason,
            } => {
                <i32>::sse_encode(5, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::UserChannelId>::sse_encode(user_channel_id, serializer);
                <Option<crate::api::types::PublicKey>>::sse_encode(
                    counterparty_node_id,
                    serializer,
                );
                <Option<crate::api::types::ClosureReason>>::sse_encode(reason, serializer);
            }
        }
    }
}

impl SseEncode for crate::api::types::GossipSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::GossipSourceConfig::P2PNetwork => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::types::GossipSourceConfig::RapidGossipSync(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
        }
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::node::LdkBolt11Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<ldk_node::payment::Bolt11Payment>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::node::LdkMnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.seed_phrase, serializer);
    }
}

impl SseEncode for crate::api::node::LdkNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<Node>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::node::LdkOnChainPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<ldk_node::payment::OnchainPayment>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::node::LdkSpontaneousPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<ldk_node::payment::SpontaneousPayment>>::sse_encode(self.ptr, serializer);
    }
}

impl SseEncode for crate::api::types::LightningBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::LightningBalance::ClaimableOnChannelClose {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
            } => {
                <i32>::sse_encode(0, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
            crate::api::types::LightningBalance::ClaimableAwaitingConfirmations {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                confirmation_height,
            } => {
                <i32>::sse_encode(1, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u32>::sse_encode(confirmation_height, serializer);
            }
            crate::api::types::LightningBalance::ContentiousClaimable {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                timeout_height,
                payment_hash,
                payment_preimage,
            } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u32>::sse_encode(timeout_height, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
                <crate::api::types::PaymentPreimage>::sse_encode(payment_preimage, serializer);
            }
            crate::api::types::LightningBalance::MaybeTimeoutClaimableHTLC {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                claimable_height,
                payment_hash,
            } => {
                <i32>::sse_encode(3, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u32>::sse_encode(claimable_height, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
            }
            crate::api::types::LightningBalance::MaybePreimageClaimableHTLC {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                expiry_height,
                payment_hash,
            } => {
                <i32>::sse_encode(4, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u32>::sse_encode(expiry_height, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
            }
            crate::api::types::LightningBalance::CounterpartyRevokedOutputClaimable {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
            } => {
                <i32>::sse_encode(5, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
        }
    }
}

impl SseEncode for crate::api::types::LiquiditySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <(
            crate::api::types::SocketAddress,
            crate::api::types::PublicKey,
            Option<String>,
        )>::sse_encode(self.lsps2_service, serializer);
    }
}

impl SseEncode for Vec<crate::api::types::ChannelDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::ChannelDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::LightningBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::LightningBalance>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::PaymentDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::PeerDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::PeerDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::PendingSweepBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::PendingSweepBalance>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::PublicKey>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::SocketAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::SocketAddress>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::types::LogLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::LogLevel::Gossip => 0,
                crate::api::types::LogLevel::Trace => 1,
                crate::api::types::LogLevel::Debug => 2,
                crate::api::types::LogLevel::Info => 3,
                crate::api::types::LogLevel::Warn => 4,
                crate::api::types::LogLevel::Error => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::LSPFeeLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.max_total_opening_fee_msat, serializer);
        <Option<u64>>::sse_encode(self.max_proportional_opening_fee_ppm_msat, serializer);
    }
}

impl SseEncode for crate::api::types::MaxDustHTLCExposure {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::MaxDustHTLCExposure::FixedLimitMsat(field0) => {
                <i32>::sse_encode(0, serializer);
                <u64>::sse_encode(field0, serializer);
            }
            crate::api::types::MaxDustHTLCExposure::FeeRateMultiplier(field0) => {
                <i32>::sse_encode(1, serializer);
                <u64>::sse_encode(field0, serializer);
            }
        }
    }
}

impl SseEncode for crate::api::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::Network::Bitcoin => 0,
                crate::api::types::Network::Testnet => 1,
                crate::api::types::Network::Signet => 2,
                crate::api::types::Network::Regtest => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::error::NodeException {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::error::NodeException::InvalidTxid => 0,
                crate::api::error::NodeException::AlreadyRunning => 1,
                crate::api::error::NodeException::NotRunning => 2,
                crate::api::error::NodeException::OnchainTxCreationFailed => 3,
                crate::api::error::NodeException::ConnectionFailed => 4,
                crate::api::error::NodeException::InvoiceCreationFailed => 5,
                crate::api::error::NodeException::PaymentSendingFailed => 6,
                crate::api::error::NodeException::ProbeSendingFailed => 7,
                crate::api::error::NodeException::ChannelCreationFailed => 8,
                crate::api::error::NodeException::ChannelClosingFailed => 9,
                crate::api::error::NodeException::ChannelConfigUpdateFailed => 10,
                crate::api::error::NodeException::PersistenceFailed => 11,
                crate::api::error::NodeException::WalletOperationFailed => 12,
                crate::api::error::NodeException::OnchainTxSigningFailed => 13,
                crate::api::error::NodeException::MessageSigningFailed => 14,
                crate::api::error::NodeException::TxSyncFailed => 15,
                crate::api::error::NodeException::GossipUpdateFailed => 16,
                crate::api::error::NodeException::InvalidAddress => 17,
                crate::api::error::NodeException::InvalidSocketAddress => 18,
                crate::api::error::NodeException::InvalidPublicKey => 19,
                crate::api::error::NodeException::InvalidSecretKey => 20,
                crate::api::error::NodeException::InvalidPaymentHash => 21,
                crate::api::error::NodeException::InvalidPaymentPreimage => 22,
                crate::api::error::NodeException::InvalidPaymentSecret => 23,
                crate::api::error::NodeException::InvalidAmount => 24,
                crate::api::error::NodeException::InvalidInvoice => 25,
                crate::api::error::NodeException::InvalidChannelId => 26,
                crate::api::error::NodeException::InvalidNetwork => 27,
                crate::api::error::NodeException::DuplicatePayment => 28,
                crate::api::error::NodeException::InsufficientFunds => 29,
                crate::api::error::NodeException::FeerateEstimationUpdateFailed => 30,
                crate::api::error::NodeException::LiquidityRequestFailed => 31,
                crate::api::error::NodeException::LiquiditySourceUnavailable => 32,
                crate::api::error::NodeException::LiquidityFeeTooHigh => 33,
                crate::api::error::NodeException::InvalidPaymentId => 34,
                crate::api::error::NodeException::DecodeError => 35,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::NodeStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_running, serializer);
        <bool>::sse_encode(self.is_listening, serializer);
        <crate::api::types::BestBlock>::sse_encode(self.current_best_block, serializer);
        <Option<u64>>::sse_encode(self.latest_wallet_sync_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_onchain_wallet_sync_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_fee_rate_cache_update_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_rgs_snapshot_timestamp, serializer);
        <Option<u64>>::sse_encode(
            self.latest_node_announcement_broadcast_timestamp,
            serializer,
        );
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::ChainDataSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::ChainDataSourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::ChannelConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::ChannelConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::ChannelId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::ChannelId>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::ClosureReason> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::ClosureReason>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::EntropySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::EntropySourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::Event> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::Event>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::GossipSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::GossipSourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::LiquiditySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::LiquiditySourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::MaxDustHTLCExposure> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::MaxDustHTLCExposure>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::OutPoint>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentDetails>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentFailureReason> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentFailureReason>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentId>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentPreimage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentPreimage>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentSecret> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentSecret>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PublicKey>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u16>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::api::types::SocketAddress>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::api::types::SocketAddress>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::types::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::Txid>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::PaymentId>::sse_encode(self.id, serializer);
        <crate::api::types::PaymentKind>::sse_encode(self.kind, serializer);
        <Option<u64>>::sse_encode(self.amount_msat, serializer);
        <crate::api::types::PaymentDirection>::sse_encode(self.direction, serializer);
        <crate::api::types::PaymentStatus>::sse_encode(self.status, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::PaymentDirection::Inbound => 0,
                crate::api::types::PaymentDirection::Outbound => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::PaymentFailureReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::PaymentFailureReason::RecipientRejected => 0,
                crate::api::types::PaymentFailureReason::UserAbandoned => 1,
                crate::api::types::PaymentFailureReason::RetriesExhausted => 2,
                crate::api::types::PaymentFailureReason::PaymentExpired => 3,
                crate::api::types::PaymentFailureReason::RouteNotFound => 4,
                crate::api::types::PaymentFailureReason::UnexpectedError => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::PaymentHash {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::PaymentKind::Onchain => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::types::PaymentKind::Bolt11 {
                hash,
                preimage,
                secret,
            } => {
                <i32>::sse_encode(1, serializer);
                <crate::api::types::PaymentHash>::sse_encode(hash, serializer);
                <Option<crate::api::types::PaymentPreimage>>::sse_encode(preimage, serializer);
                <Option<crate::api::types::PaymentSecret>>::sse_encode(secret, serializer);
            }
            crate::api::types::PaymentKind::Bolt11Jit {
                hash,
                preimage,
                secret,
                lsp_fee_limits,
            } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::types::PaymentHash>::sse_encode(hash, serializer);
                <Option<crate::api::types::PaymentPreimage>>::sse_encode(preimage, serializer);
                <Option<crate::api::types::PaymentSecret>>::sse_encode(secret, serializer);
                <crate::api::types::LSPFeeLimits>::sse_encode(lsp_fee_limits, serializer);
            }
            crate::api::types::PaymentKind::Spontaneous { hash, preimage } => {
                <i32>::sse_encode(3, serializer);
                <crate::api::types::PaymentHash>::sse_encode(hash, serializer);
                <Option<crate::api::types::PaymentPreimage>>::sse_encode(preimage, serializer);
            }
        }
    }
}

impl SseEncode for crate::api::types::PaymentPreimage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentSecret {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::PaymentStatus::Pending => 0,
                crate::api::types::PaymentStatus::Succeeded => 1,
                crate::api::types::PaymentStatus::Failed => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::PeerDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::PublicKey>::sse_encode(self.node_id, serializer);
        <crate::api::types::SocketAddress>::sse_encode(self.address, serializer);
        <bool>::sse_encode(self.is_connected, serializer);
    }
}

impl SseEncode for crate::api::types::PendingSweepBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::PendingSweepBalance::PendingBroadcast {
                channel_id,
                amount_satoshis,
            } => {
                <i32>::sse_encode(0, serializer);
                <Option<crate::api::types::ChannelId>>::sse_encode(channel_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
            crate::api::types::PendingSweepBalance::BroadcastAwaitingConfirmation {
                channel_id,
                latest_broadcast_height,
                latest_spending_txid,
                amount_satoshis,
            } => {
                <i32>::sse_encode(1, serializer);
                <Option<crate::api::types::ChannelId>>::sse_encode(channel_id, serializer);
                <u32>::sse_encode(latest_broadcast_height, serializer);
                <crate::api::types::Txid>::sse_encode(latest_spending_txid, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
            crate::api::types::PendingSweepBalance::AwaitingThresholdConfirmations {
                channel_id,
                latest_spending_txid,
                confirmation_hash,
                confirmation_height,
                amount_satoshis,
            } => {
                <i32>::sse_encode(2, serializer);
                <Option<crate::api::types::ChannelId>>::sse_encode(channel_id, serializer);
                <crate::api::types::Txid>::sse_encode(latest_spending_txid, serializer);
                <String>::sse_encode(confirmation_hash, serializer);
                <u32>::sse_encode(confirmation_height, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
        }
    }
}

impl SseEncode for crate::api::types::PublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.hex, serializer);
    }
}

impl SseEncode
    for (
        crate::api::types::SocketAddress,
        crate::api::types::PublicKey,
        Option<String>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::SocketAddress>::sse_encode(self.0, serializer);
        <crate::api::types::PublicKey>::sse_encode(self.1, serializer);
        <Option<String>>::sse_encode(self.2, serializer);
    }
}

impl SseEncode for crate::api::types::SocketAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::SocketAddress::TcpIpV4 { addr, port } => {
                <i32>::sse_encode(0, serializer);
                <[u8; 4]>::sse_encode(addr, serializer);
                <u16>::sse_encode(port, serializer);
            }
            crate::api::types::SocketAddress::TcpIpV6 { addr, port } => {
                <i32>::sse_encode(1, serializer);
                <[u8; 16]>::sse_encode(addr, serializer);
                <u16>::sse_encode(port, serializer);
            }
            crate::api::types::SocketAddress::OnionV2(field0) => {
                <i32>::sse_encode(2, serializer);
                <[u8; 12]>::sse_encode(field0, serializer);
            }
            crate::api::types::SocketAddress::OnionV3 {
                ed25519_pubkey,
                checksum,
                version,
                port,
            } => {
                <i32>::sse_encode(3, serializer);
                <[u8; 32]>::sse_encode(ed25519_pubkey, serializer);
                <u16>::sse_encode(checksum, serializer);
                <u8>::sse_encode(version, serializer);
                <u16>::sse_encode(port, serializer);
            }
            crate::api::types::SocketAddress::Hostname { addr, port } => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(addr, serializer);
                <u16>::sse_encode(port, serializer);
            }
        }
    }
}

impl SseEncode for crate::api::types::Txid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.hash, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for [u8; 12] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 16] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 32] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 4] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 64] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::api::types::UserChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
#[path = "frb_generated.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
#[path = "frb_generated.web.rs"]
mod web;
#[cfg(target_family = "wasm")]
pub use web::*;
